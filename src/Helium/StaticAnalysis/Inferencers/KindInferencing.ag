-----------------------------------------------------------------------------
-- |The Helium Compiler : Static Analysis
-- 
-- Maintainer  :  bastiaan@cs.uu.nl
-- Stability   :  experimental
-- Portability :  unknown
--
-- Kind inference.
--
---------------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- Attributes for kind inferencing

ATTR Module
   [ importEnvironment : ImportEnvironment
     options           : {[Option]}
   |
   | debugString           : {String}
     kindEnvironment   : KindEnvironment
     kindErrors        : KindErrors
   ]
   
-------------------------------------------------------------------------------
-- Includes

INCLUDE "UHA_Syntax.ag"

optpragmas
{
  {-# OPTIONS_GHC -fno-warn-unused-binds #-}
}

MODULE {Helium.StaticAnalysis.Inferencers.KindInferencing}
{ inferKinds
, KindEnvironment
}

-------------------------------------------------------------------------------
-- Imports

{
import Top.Types
import Top.Solver.Greedy
import Top.Solver
import Helium.StaticAnalysis.Miscellaneous.TypeConstraints
import Helium.Syntax.UHA_Syntax
import Helium.Syntax.UHA_Utils
import Helium.Main.Args
import qualified Data.Map as M
import Data.Map(Map)

-- import StaticAnalysis.Miscellaneous.TypeConstraints
import Helium.Utils.Utils (internalError)
import Helium.ModuleSystem.ImportEnvironment hiding (setTypeSynonyms)
import Helium.StaticAnalysis.Messages.KindErrors
import Data.Char (isLower)
import Helium.StaticAnalysis.Inferencers.BindingGroupAnalysis (Assumptions, PatternAssumptions, noAssumptions, combine, single, topSort)
import Debug.Trace

}

{
inferKinds :: ImportEnvironment
           -> Module
           -> [Option]
           -> (String, KindEnvironment, KindErrors)
inferKinds importEnvironment module_ options =
      let res = wrap_Module (sem_Module module_) Inh_Module {
                   importEnvironment_Inh_Module = importEnvironment,
                   options_Inh_Module = options }
          kindEnv = kindEnvironment_Syn_Module res
      in ((debugString_Syn_Module res), kindEnv, kindErrors_Syn_Module res)
}


-------------------------------------------------------------------------------
-- Semantic functions

SEM Module
  | Module   lhs  . kindErrors      = @substitution |-> (map fst @kindErrors)
                  . debugString     = "Variables: \n" ++ unlines (map (\(i, d) -> show i ++ ": " ++ d) @body.vars) ++ "\n\n" ++ show @logEntries
             body . kappaUnique     = 0
             loc  . (SolveResult kappaUniqueAtTheEnd substitution kindSchemes _ kindErrors, logEntries) = 
                       solve (solveOptions { uniqueCounter = @body.kappaUnique }) @body.constraints greedyConstraintSolver
                  . kindEnvironment = let f kind = generalizeAll ([] .=>. defaultToStar (@substitution |-> kind))
                                      in M.map f @body.environment
  
ATTR Body [ | | constraints:KindConstraints environment:PatternAssumptions ]

{
  
}

SEM Body 
  | Hole
       lhs . constraints = []
           . environment = noAssumptions
  | Body 
       declarations . bindingGroups  = []
       lhs . constraints             = @newConstraints ++ @cs
       loc . (environment, aset, cs) = performBindingGroup @declarations.bindingGroups
           . newConstraints          = fst $ (@kindEnvironment .:::. @aset) (\n -> unexpected $ "Body.Body " ++ show n)
           . kindEnvironment         = getKindsFromImportEnvironment @lhs.importEnvironment `M.union`
                                       M.singleton (nameFromString "->") (makeScheme [] [] (star .->. star .->. star))

ATTR Body Declarations Declaration Expressions Expression Alternatives Alternative
     Statement Statements Qualifier Qualifiers RightHandSide FunctionBinding
     FunctionBindings Constructor Constructors RecordExpressionBinding RecordExpressionBindings
     MaybeExpression MaybeDeclarations GuardedExpression GuardedExpressions
     FieldDeclaration FieldDeclarations ContextItems ContextItem
     AnnotatedType AnnotatedTypes Type Types SimpleType
     [ | kappaUnique:Int | ]

ATTR Declaration Declarations Expressions Expression Alternatives Alternative 
     Statement Statements Qualifier Qualifiers RightHandSide FunctionBinding
     FunctionBindings MaybeExpression RecordExpressionBinding RecordExpressionBindings
     MaybeDeclarations GuardedExpression GuardedExpressions
     [ | bindingGroups:BindingGroups | ]
     
ATTR Declaration Declarations Expressions Expression Alternatives Alternative 
     Statement Statements Qualifier Qualifiers RightHandSide FunctionBinding
     FunctionBindings MaybeExpression RecordExpressionBinding RecordExpressionBindings
     MaybeDeclarations GuardedExpression GuardedExpressions Body Declaration Declarations
     ContextItems ContextItem SimpleType
     [ | | vars USE {`mappend`} {mempty} : {[(Int, String)]}  ]

SEM Declaration
  | Type
       simpletype . constraints = []
                  . kappaOfRHS  = @type.kappa
       lhs  . bindingGroups  = @newGroup : @lhs.bindingGroups
       loc  . newConstraints = fst $ (@simpletype.environment .===. @type.assumptions) (\n -> unexpected $ "Declaration.Type " ++ show n)
            . newGroup       = (@simpletype.declared, @type.assumptions, @newConstraints ++ @type.constraints)
            
  | Data
       simpletype . constraints = [] 
                  . kappaOfRHS  = star
       lhs . bindingGroups  = @newGroup : @lhs.bindingGroups
       loc . newConstraints = fst $ (@simpletype.environment .===. @constructors.assumptions) (\n -> unexpected $ "Declaration.Data " ++ show n)
           . newGroup       = (@simpletype.declared, @constructors.assumptions, @newConstraints ++ @constructors.constraints)
           
  | TypeSignature
       type . constraints  = [] 
       lhs  . bindingGroups = @newGroup : @lhs.bindingGroups
            . kappaUnique   = @type.kappaUnique + length @tvEnv
       loc  . newConstraint = (@type.kappa <==> star) (mustBeStar @range.self "type signature" @type.self)
            . tvEnv         = zip (getTypeVariables @type.assumptions) (map TVar [@type.kappaUnique..])
            . (cset, aset)  = (M.fromList @tvEnv .===. @type.assumptions) (\n -> unexpected $ "Declaration.TypeSignature " ++ show n) 
            . newGroup      = (M.empty, @aset, @cset ++ @type.constraints ++ [@newConstraint])

  | Class
       where . bindingGroups = @newGroup : @lhs.bindingGroups
       --loc . kappa           = @lhs.kappaUnique
       --context . kappaUnique = @kappa + 1
       lhs . kappaUnique     = @where.kappaUnique + 1
       loc . kappa           = @where.kappaUnique

       lhs . vars            = [(@kappa, "class " ++ getNameName @simpletype.name)]
                               `mappend` @context.vars `mappend` @simpletype.vars `mappend` @where.vars

       loc . newGroup        = ( M.singleton @simpletype.name (TVar @kappa)
                               , @whereAset `combine` @ctxAset
                               , @whereCset ++ @ctxCset ++ @where.constraints ++ @context.constraints ++ @constraints)
       loc . tvEnv           = @simpletype.environment
       loc . kappaOfRHS      = TVar @kappa
       loc . constraints     = [ (TVar @kappa .==.
                                 foldr (.->.) kConstraint @simpletype.kappasVars) (unexpected $ "Declaration.Class")
                               ]

       loc . (whereCset,
                  whereAset) = (@tvEnv .===. @where.assumptions)
                                    (\n -> unexpected $ "Declaration.Class " ++ show n)
       loc . (ctxCset,
                    ctxAset) = (@tvEnv .===. @context.assumptions)
                                    (\n -> unexpected $ "Declaration.Class " ++ show n)

  | Instance
       lhs . kappaUnique     =        @types.kappaUnique + length @tvEnv + 1
       loc . kappa           = TVar $ @types.kappaUnique + length @tvEnv
       lhs . vars            = [(@types.kappaUnique + length @tvEnv, "Instance expectation " ++ @loc.name ++ " " ++ show @types.assumeSingle)]
                               `mappend` @where.vars
       loc . tvEnv           = zip (getTypeVariables @types.assumptions) (map TVar [@types.kappaUnique ..])
       lhs . bindingGroups   = @newGroup : @where.bindingGroups
       loc . newGroup        = (mempty
                               , @aset `combine` @aset' `combine` @aset''
                               , @cset ++ @cset' ++ @cset'' ++ @importedConstraints)
                               -- TODO  @types.constraints, @context.constraints ?
           . (cset, aset)    = (M.fromList @tvEnv .===. @types.assumptions) (\n -> unexpected $ "Instance.Instance " ++ show n)
           . (cset', aset')  = (M.fromList @tvEnv .===. @context.assumptions) (\n -> unexpected $ "Instance.Instance " ++ show n)
           . name            = getNameName @name.self
           . hypotheticClass = foldr (.->.) kConstraint @types.kappas
           . (cset'', aset'') = {-trace (show (foldr (.->.) kConstraint @types.kappas) ++ " == " ++ show @kappa )
                                trace (show @name.self ++ " --- " ++ show @kappa)
                                trace (show @types.assumptions)-}
                                ( [(@hypotheticClass .==. @kappa) (kindInstance @range.self @loc.name @hypotheticClass @kappa)]
                                , @name.self `single` @kappa)
       loc . importedConstraints
                             = let kinds = getKindsFromImportEnvironment @lhs.importEnvironment
                               in case M.lookup @name.self kinds of
                                 Nothing -> []
                                 Just k -> trace ("\nIMPORT " ++ show k ++ "\n")
                                           [ (@kappa .::. k)
                                               (kindContext @range.self (getNameName @name.self) @kappa k)
                                           ]


{-       loc . myConstraints     = [ (TVar @kappa .==.
                                 foldr (.->.) kConstraint @simpletype.kappasVars) (unexpected $ "Declaration.Class") ]-}

-- TODO: (name `apply` @types) .==. kConstraint
--                \                     \
--                 '--> kind mismatch    '--> too few/many types
--
-- Currently implemented is only the kind mismatch
--  - types == [*]     -> ok
--  - types == [other] -> message
--  - otherwise        -> exception
                   -- ([((@types.assumeSingle <==> star) (\_ -> unexpected $ "Instance.Instance WIP"))], mempty)

  | Hole
       lhs . assumptions = noAssumptions

SEM Expression
  | Typed
       type . constraints   = []   
       lhs  . bindingGroups = @newGroup : @expression.bindingGroups
            . kappaUnique   = @type.kappaUnique + length @tvEnv
       loc  . newConstraint = (@type.kappa <==> star) (mustBeStar @range.self "type annotation" @type.self)
            . tvEnv         = zip (getTypeVariables @type.assumptions) (map TVar [@type.kappaUnique..])
            . (cset, aset)  = (M.fromList @tvEnv .===. @type.assumptions) (\n -> unexpected $ "Expression.Typed " ++ show n) 
            . newGroup      = (M.empty, @aset, @cset ++ @type.constraints ++ [@newConstraint])

ATTR SimpleType [ kappaOfRHS:Kind
                | constraints:KindConstraints
                | environment:PatternAssumptions
                  declared:PatternAssumptions
                  name:Name
                  kappasVars:{[Kind]}
                ]

SEM SimpleType
  | SimpleType
       lhs . environment   = M.fromList (zip @typevariables.self @kappasVars)
           . declared      = M.singleton @name.self @kappaCon
           . constraints   = @newConstraint : @lhs.constraints
           . kappaUnique   = 1 + length @typevariables.self + @lhs.kappaUnique
       lhs . name          = @name.self
       lhs . vars          = [(@lhs.kappaUnique, "SimpleType.kappaCon " ++ show @name.self)]
       loc . kappaCon      = TVar @lhs.kappaUnique
           . kappasVars    = take (length @typevariables.self) [ TVar i | i <- [ @lhs.kappaUnique+1 .. ]]
           . newConstraint = (@kappaCon .==. foldr (.->.) @lhs.kappaOfRHS @kappasVars) (unexpected "SimpleType.SimpleType")

ATTR AnnotatedTypes Types [ | constraints:KindConstraints | assumptions:Assumptions kappas:Kinds]
ATTR AnnotatedType  Type  [ | constraints:KindConstraints | assumptions:Assumptions kappa:Kind ]
ATTR MaybeDeclarations Declarations Declaration ContextItem ContextItems
                          [ | constraints:KindConstraints | assumptions:Assumptions ]

ATTR Types [ | | assumeSingle : Kind ]
SEM Types | Cons lhs.assumeSingle = @hd.kappa
          | Nil lhs.assumeSingle  = internalError "KindInferencing.ag" "n/a" "Use of multiple types is not yet supported here."

SEM Type
  | Application
       lhs . assumptions   = @function.assumptions `combine` @arguments.assumptions
           . constraints   = @arguments.constraints ++ [@newConstraint]
       lhs . kappaUnique   = @arguments.kappaUnique + 1
       loc . kappa         = TVar @arguments.kappaUnique
           . newConstraint = (@function.kappa <==> foldr (.->.) @kappa @arguments.kappas) (kindApplication @range.self @self @function.self)
           
           
  | Variable 
       lhs . assumptions = single @name.self @kappa
           . kappaUnique = @lhs.kappaUnique + 1
       loc . kappa       = TVar @lhs.kappaUnique
                 
  | Constructor   
       lhs . assumptions = single @name.self @kappa
           . kappaUnique = @lhs.kappaUnique + 1
       loc . kappa       = TVar @lhs.kappaUnique         

  | Qualified
       lhs . assumptions = @loc.assumptions
       loc . kappa       = TVar @lhs.kappaUnique
       type . kappaUnique = @lhs.kappaUnique + 1
       lhs . kappaUnique = @type.kappaUnique


SEM Types 
  | Cons   lhs . assumptions = @hd.assumptions `combine` @tl.assumptions
               . kappas      = @hd.kappa : @tl.kappas   
  | Nil    lhs . assumptions = noAssumptions
               . kappas      = []  

SEM AnnotatedType 
  | AnnotatedType
       lhs . constraints   = @type.constraints ++ [@newConstraint]
       loc . newConstraint = (@type.kappa <==> star) (mustBeStar @range.self "data type declaration" @type.self)

SEM AnnotatedTypes
  | Cons   lhs . assumptions = @hd.assumptions `combine` @tl.assumptions
               . kappas      = @hd.kappa : @tl.kappas
  | Nil    lhs . assumptions = noAssumptions
               . kappas      = []

ATTR Constructor Constructors [ | constraints:KindConstraints | assumptions:Assumptions ]

SEM Constructor
  | Infix   lhs . assumptions = @leftType.assumptions `combine` @rightType.assumptions

SEM Constructors
  | Cons   lhs . assumptions = @hd.assumptions `combine` @tl.assumptions
  | Nil    lhs . assumptions = noAssumptions

SEM MaybeDeclarations
  | Nothing lhs . assumptions = noAssumptions

SEM Declarations
  | Cons   lhs . assumptions = @hd.assumptions `combine` @tl.assumptions
  | Nil    lhs . assumptions = noAssumptions
  | Cons   lhs . constraints = @hd.constraints ++ @tl.constraints
  | Nil    lhs . constraints = mempty

SEM ContextItems
  | Nil    lhs . assumptions = noAssumptions
  | Cons   lhs . assumptions = @hd.assumptions `combine` @tl.assumptions

{- Example:

      kConstraint
    ______/\______
   /              \

   Distributive f g =>

        |       | |
        v       | |
      kappa     | |
                v v
            @types.kappas
 -}

SEM ContextItem 
  | ContextItem
  -- TODO: wtf these four lines
--       lhs . kappaUnique   = 2 + length @types.self + @lhs.kappaUnique
--       loc . kappa         = TVar (@lhs.kappaUnique + 1)
--       loc . kappa         = TVar $ @types.kappaUnique + 40 * length @types.kappas
--       lhs . kappaUnique   = @types.kappaUnique + 1 + 40 * length @types.kappas
       loc . kappa = TVar (@types.kappaUnique)
       lhs . kappaUnique = @types.kappaUnique + 1

       -- Determine kind for @kappa
                             
       loc . myAssumptions = @name.self `single` @kappa
       loc . importedConstraints
                           = let kinds = getKindsFromImportEnvironment @lhs.importEnvironment
                             in case M.lookup @name.self kinds of
                               Nothing -> []
                               Just k ->
                                 [(@kappa .::. k)
                                   (kindContext @range.self (getNameName @name.self) @kappa k)]


       -- Application of the types
       loc . usedAs        = foldr (.->.) kConstraint @types.kappas
       loc . use           = [(@kappa .==. @usedAs)
                               (kindContext'
                                  @range.self
                                  (getNameName @name.self)
                                  @usedAs
                                  @kappa)]

       -- Aggregating

       lhs . constraints   = if getNameName @name.self `elem` ["Num", "Eq", "Ord", "Show"]
                             then [] -- FIXME: these will have to be treated as normal classes
                             else @use ++ @importedConstraints ++ @types.constraints
                             
       lhs . assumptions   = @myAssumptions `combine` @types.assumptions

  {-
       loc . kappa         = TVar @lhs.kappaUnique
       range . kappaUnique = @lhs.kappaUnique + 1
       lhs . kappaUnique   = @lhs.kappaUnique + 1000 -- 2 + length @types.self + @types.kappaUnique
       lhs . constraints   = @importedConstraints ++ @types.constraints -- ++ @use
       lhs . assumptions   = {-@myAssumptions `combine`-} @types.assumptions
                                -- id of the constraint 'type' constructor

       loc . kappasVars    = @types.kappas
       loc . usedAs        = foldr (.->.) kConstraint @kappasVars
       loc . use           = [(@kappa .==. @usedAs)
                               (kindContext' @range.self (getNameName @name.self) @usedAs @kappa)]

       loc . importedConstraints
                           = let kinds = getKindsFromImportEnvironment @lhs.importEnvironment
                             in trace ("Imported constraints " ++ show @name.self ++ " " ++ show (M.lookup @name.self kinds)) $
                               case M.lookup @name.self kinds of
                               Nothing -> []
                               Just k ->
                                 [(@kappa .::. k)
                                   (kindContext @range.self (getNameName @name.self) @usedAs k)]

       loc . myAssumptions = @name.self `single` @kappa
-}

ATTR Alternative Alternatives AnnotatedType AnnotatedTypes Body Constructor Constructors ContextItem ContextItems Declaration Declarations Expression Expressions FieldDeclaration FieldDeclarations FunctionBinding FunctionBindings GuardedExpression GuardedExpressions MaybeExpression MaybeDeclarations Qualifier Qualifiers RecordExpressionBinding RecordExpressionBindings RightHandSide Statement Statements Type Types
     [ importEnvironment : ImportEnvironment | | ]

SEM FieldDeclaration 
  | FieldDeclaration    loc . constraints = internalError "KindInferencing.ag" "n/a" "Field decls are not supported"
SEM Declaration 
  | Default  loc . constraints = internalError "KindInferencing.ag" "n/a" "default decls is not supported"
  | Newtype  loc . (constraints,kappaOfRHS) = internalError "KindInferencing.ag" "n/a" "newtype decls are not supported"
  | FunctionBindings loc . assumptions = internalError "KindInferencing.ag" "n/a" "unexpected FunctionBindings while determining assumptions"
  | PatternBinding   loc . assumptions = internalError "KindInferencing.ag" "n/a" "unexpected PatternBindings while determining assumptions"
  | Fixity   loc . assumptions = internalError "KindInferencing.ag" "n/a" "unexpected Fixity while determining assumptions"
  | Empty   loc . assumptions = internalError "KindInferencing.ag" "n/a" "unexpected Empty while determining assumptions"
SEM Type  
  | Qualified   loc . assumptions = @type.assumptions
  | Forall      loc . (assumptions, kappa) = internalError "KindInferencing.ag" "n/a" "Universal types are not supported"
  | Exists      loc . (assumptions, kappa) = internalError "KindInferencing.ag" "n/a" "Existential types are not supported"
SEM Constructor
  | Record  lhs . assumptions = internalError "KindInferencing.ag" "n/a" "Record constructors are not supported"

{

  -- TODO: use this
type KindEnvironment = Map Name TpScheme

type KindConstraint  = TypeConstraint  KindError
type KindConstraints = TypeConstraints KindError

type BindingGroups = [BindingGroup]
type BindingGroup  = (PatternAssumptions,Assumptions,KindConstraints)

-- | Kind 'Constraint'
kConstraint :: Kind
kConstraint = TCon "Constraint"

combineBindingGroup :: BindingGroup -> BindingGroup -> BindingGroup
combineBindingGroup (e1,a1,c1) (e2,a2,c2) = (e1 `M.union` e2,a1 `combine` a2,c1++c2)

concatBindingGroups :: BindingGroups -> BindingGroup
concatBindingGroups = foldr combineBindingGroup emptyBindingGroup

emptyBindingGroup :: BindingGroup
emptyBindingGroup = (noAssumptions, noAssumptions, [])

performBindingGroup :: BindingGroups -> (PatternAssumptions, Assumptions, KindConstraints)
performBindingGroup = glueGroups . bindingGroupAnalysis
   where   
      bindingGroupAnalysis :: BindingGroups -> BindingGroups
      bindingGroupAnalysis cs
         = let indexMap = concat (zipWith f cs [0..])
               f (env,_,_) i = [ (n,i) | n <- M.keys env ]
               edges    = concat (zipWith f' cs [0..])
               f' (_,ass,_) i = [ (i,j)| n <- M.keys ass, (n',j) <- indexMap, n==n' ]
               list = topSort (length cs-1) edges
           in map (concatBindingGroups . map (cs !!)) list
           
      glueGroups :: BindingGroups -> (PatternAssumptions, Assumptions, KindConstraints)
      glueGroups = foldr op (noAssumptions, noAssumptions, []) 
         where
            op (env, aset, cset) (environment, assumptions, constraints) = 
               let (cset1,aset')        = (env .===. aset)            (\n -> unexpected $ "BindingGroup.same "++show n)
                   (cset2,assumptions') = (!<==!) [] env assumptions  (\n -> unexpected $ "BindingGroup.instance "++show n)
               in ( env `M.union` environment
                  , aset' `combine` assumptions'
                  , cset1 ++ cset ++ cset2 ++ constraints
                  )             

getKindsFromImportEnvironment :: ImportEnvironment -> KindEnvironment
getKindsFromImportEnvironment ie = typeKinds `M.union` classKinds
   where typeKinds = M.map f $ typeConstructors $ ie
         f i = generalizeAll ([] .=>. foldr (.->.) star (replicate i star)) -- ASSUMPTION: all data types have type parameters of kind *
         (ClassKindEnvironment classKinds) = classKindEnvironment ie

getTypeVariables :: Assumptions -> Names
getTypeVariables = filter p . M.keys
   where p n = case show n of
                  []  -> False
                  c:_ -> isLower c

unexpected :: String -> KindError
unexpected message = 
   internalError "KindInferencing.ag" "unexpected" ("unexpected kind error: "++message)

(<==>) :: Kind -> Kind -> ((Kind, Kind) -> KindError) -> KindConstraint
(k1 <==> k2) info = (k1 .==. k2) (info (k1, k2))
}
