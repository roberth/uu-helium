imports{
import UHA_Utils
import UHA_Syntax 
import UHA_Range
import OperatorTable
import Char
import ParseLibrary(intUnaryMinusName, floatUnaryMinusName)
import Utils
import Messages
}

INCLUDE "../syntax/UHA_Syntax.ag"

{

data ResolveError = 
    Ambiguous Assoc Name Assoc Name

instance HasMessage ResolveError where
    getRanges (Ambiguous _ n1 _ n2) = 
        [ getNameRange n1, getNameRange n2 ]
    
    getMessage (Ambiguous assoc1 op1 assoc2 op2) = 
        let 
            assocString AssocRight = "right-associative"
            assocString AssocLeft  = "left-associative"
            assocString AssocNone  = "non-associative"

            firstLine =
                    "Ambiguous use of "
                ++  assocString (assoc1)
                ++  " operator "
                ++  show op1
            secondLine = 
                    "with "
                ++  assocString (assoc2)
                ++  " operator "
                ++  show op2
        in [ MessageOneLiner ( MessageString firstLine) 
           , MessageOneLiner ( MessageString ("    " ++ secondLine ))
           ]
        
resolveOperators :: OperatorTable -> Module -> (Module, [ResolveError])
resolveOperators opTable m = 
    let (errs, newModule) = sem_Module m opTable []
    in (newModule, errs)

expression opTable e = -- !!! errors ignored
    let (errs, newE) = sem_Expression e opTable [] 
    in newE

operatorsFromModule :: Module -> OperatorTable
operatorsFromModule m =
    concatMap declToOps (collectInfixdecls m)
  where
    declToOps (Declaration_Fixity _ f (MaybeInt_Just p) os) = 
        [ (o, (p, fixityToAssoc f)) | o <- os ]
    fixityToAssoc f = case f of
        Fixity_Infixl _ -> AssocLeft
        Fixity_Infixr _ -> AssocRight
        Fixity_Infix  _ -> AssocNone

collectInfixdecls :: Module -> [Declaration]
collectInfixdecls 
    (Module_Module _ _ _ (Body_Body _ _ ds)) = filter isInfixdecl ds
    where
        isInfixdecl (Declaration_Fixity _ _ _ _) = True
        isInfixdecl _ = False
}

ATTR Module Body Declarations Declaration FunctionBindings RightHandSide
     FunctionBinding LeftHandSide MaybeDeclarations GuardedExpressions
     GuardedExpression Expression Patterns Pattern Alternatives Alternative
     Qualifiers Qualifier Statements Statement MaybeExpression Expressions
     RecordExpressionBinding RecordPatternBinding RecordPatternBindings
     RecordExpressionBindings
    [ opTable : OperatorTable 
    | resolveErrors : { [ResolveError] } 
    | 
    ]                

SEM Pattern 
    | List lhs.resolveErrors = @errs ++ @lhs.resolveErrors
           loc . (self, errs) = 
                    case @range of
                        Range_Range Position_Unknown Position_Unknown -> 
                            resolvePattern @lhs.opTable @patterns.self
                        _ -> 
                            (Pattern_List @range.self @patterns.self, [])
           
SEM Expression
    | List lhs . resolveErrors = @errs ++ @lhs.resolveErrors
           loc . (self, errs) = 
                    case @range of
                        Range_Range Position_Unknown Position_Unknown -> 
                            resolveExpression @lhs.opTable @expressions.self
                        _ -> (Expression_List @range.self @expressions.self, [])
            
{            
type State expr = 
    ( [Name] -- operator stack
    , [expr] -- expression/pattern stack
    , [ResolveError]
    )

resolveExpression :: OperatorTable -> [Expression] -> (Expression, [ResolveError])
resolveExpression opTable es = resolve opTable es (getOp, applyMinus, applyBinary) ([], [], []) 
  where
    getOp (Expression_Variable (Range_Range Position_Unknown Position_Unknown) n) = Just n
    getOp (Expression_Constructor (Range_Range Position_Unknown Position_Unknown) n) = Just n
    getOp _ = Nothing
    
    applyMinus :: Name -> Expression -> Expression
    applyMinus n e
        | n == intUnaryMinusName =
            Expression_Negate      (mergeRanges (getNameRange n) (getExprRange e)) e
        | n == floatUnaryMinusName = 
            Expression_NegateFloat (mergeRanges (getNameRange n) (getExprRange e)) e
        | otherwise = internalError 
            "ResolveOperators.hs" "resolveExpression.applyMinus" "unknown unary operator"        
            
    applyBinary :: Name -> Expression -> Expression -> Expression
    applyBinary n e1 e2 =
        Expression_InfixApplication 
            (mergeRanges (getExprRange e1) (getExprRange e2)) 
            (MaybeExpression_Just e1) 
            ((if isConstructor n then Expression_Constructor else Expression_Variable) (getNameRange n) n)
            (MaybeExpression_Just e2)
        
resolvePattern :: OperatorTable -> [Pattern] -> (Pattern, [ResolveError])
resolvePattern opTable ps = resolve opTable ps (getOp, applyMinus, applyBinary) ([], [], []) 
  where
    getOp (Pattern_Variable (Range_Range Position_Unknown Position_Unknown) n) = Just n
    getOp _ = Nothing
    
    applyMinus :: Name -> Pattern -> Pattern
    applyMinus n p@(Pattern_Literal r l) 
        | n == intUnaryMinusName =
            Pattern_Negate (mergeRanges (getNameRange n) r) l
        | n == floatUnaryMinusName = 
            Pattern_NegateFloat (mergeRanges (getNameRange n) r) l            
        | otherwise = internalError 
                "ResolveOperators.hs" "resolvePattern.applyMinus" "unknown unary operator"        
    applyMinus n _ =
        internalError "ResolveOperators" "resolvePattern" "in patterns unary minus is only allowed in front of literals"         
        
    applyBinary :: Name -> Pattern -> Pattern -> Pattern
    applyBinary n p1 p2 =
        Pattern_InfixConstructor 
            (mergeRanges (getPatRange p1) (getPatRange p2)) 
            p1 n p2

resolve :: 
    OperatorTable -> 
    [expr] -> 
    ( expr -> Maybe Name -- get operator name (if it is one)
    , Name -> expr -> expr -- apply minus
    , Name -> expr -> expr -> expr -- apply binary
    ) 
    -> State expr -> (expr, [ResolveError])
resolve opTable exprs fs@(getOp, applyMinus, applyBinary) state = 
    case exprs of 
        [] -> cleanup state
        (expr:exprs) ->
            let newState = 
                    case getOp expr of
                        Nothing   -> pushExpr expr state
                        Just name -> pushOp opTable name state
            in
                resolve opTable exprs fs newState
  where
--    popOp :: State expr -> State expr
    popOp (op:ops, exprs, errs) 
        | isUnary op =
            case exprs of
                (expr:rest) -> (ops, applyMinus op expr : rest, errs)
                _ -> internalError "ResolveOperators" "popOp" "1"
        | otherwise =
            case exprs of
                (expr2:expr1:rest) -> (ops, applyBinary op expr1 expr2 : rest, errs)
                _ -> internalError "ResolveOperators" "popOp" "2"
--    pushOp :: Name -> State expr -> State expr
    pushOp opTable op state@(top:ops, exprs, errs) =
        case strongerOp opTable top op of
            Left True -> pushOp opTable op (popOp state)
            Left False -> (op:top:ops, exprs, errs)
            Right err -> (op:top:ops, exprs, err : errs) -- arbitrary choice
    pushOp _ op ([], exprs, errs) =
        ([op], exprs, errs)
--    cleanup :: State expr -> expr
    cleanup state@(_:_, _, _)       = cleanup (popOp state)
    cleanup state@(_, [expr], errs) = (expr, errs)
    cleanup _ = internalError "ResolveOperators" "cleanup" "invalid state"
    

pushExpr :: expr -> State expr -> State expr
pushExpr expr (ops, exprs, errs) =
    (ops, expr:exprs, errs)
                
strongerOp :: OperatorTable -> Name -> Name -> Either Bool ResolveError
strongerOp opTable op1 op2
    | isBinary op1 && isBinary op2 =
        if prio1 == prio2 then
            if assoc1 == AssocLeft && assoc2 == AssocLeft then
                Left True
            else if assoc1 == AssocRight && assoc2 == AssocRight then
                Left False
            else
                Right (Ambiguous assoc1 op1 assoc2 op2)
        else
            Left (prio1 > prio2)
    | isUnary  op1 && isBinary op2 = 
        Left (prio1 >= prio2)
    | isUnary  op2 = 
        Left False
    | otherwise = internalError "ResolveOperators" "strongerOp" "unable to determine which operator binds stronger"
  where
    assoc1 = assoc opTable op1
    assoc2 = assoc opTable op2
    prio1 = prio opTable op1
    prio2 = prio opTable op2

isUnary :: Name -> Bool
isUnary name = name `elem` [ intUnaryMinusName, floatUnaryMinusName ]

isBinary :: Name -> Bool
isBinary = not . isUnary

}

-- Below is UHA_Self except Expression.List and Pattern.List

SEM Module [ | | self:Module ]
    | Module   loc . self = Module_Module @range.self @name.self @exports.self @body.self

SEM Exports [ | | self:Exports ]
    | Cons        loc . self = @hd.self : @tl.self
    | Nil         loc . self = []
    
SEM MaybeExports [ | | self:MaybeExports ]
    | Nothing   loc . self = MaybeExports_Nothing
    | Just      loc . self = MaybeExports_Just @exports.self

SEM Export [ | | self:Export]
    | Variable              loc . self = Export_Variable @range.self @name.self
    | TypeOrClass           loc . self = Export_TypeOrClass @range.self @name.self @names.self
    | TypeOrClassComplete   loc . self = Export_TypeOrClassComplete @range.self @name.self
    | Module                loc . self = Export_Module @range.self @name.self

SEM Body [ | | self:Body ]
    | Body   loc . self = Body_Body @range.self @importdeclarations.self @declarations.self

SEM ImportDeclarations [ | | self:ImportDeclarations ]
    | Cons        loc . self = @hd.self : @tl.self
    | Nil         loc . self = []
    
SEM ImportDeclaration [ | | self:ImportDeclaration ]
    | Import   loc . self = ImportDeclaration_Import @range.self @qualified @name.self @asname.self @importspecification.self
    | Empty    loc . self = ImportDeclaration_Empty @range.self

SEM MaybeImportSpecification [ | | self:MaybeImportSpecification ]
    | Nothing   loc . self = MaybeImportSpecification_Nothing
    | Just      loc . self = MaybeImportSpecification_Just @importspecification.self

SEM ImportSpecification [ | | self:ImportSpecification ]
    | Import   loc . self = ImportSpecification_Import @range.self @hiding @imports.self

SEM Imports [ | | self:Imports ]
    | Cons        loc . self = @hd.self : @tl.self
    | Nil         loc . self = []
    
SEM Import [ | | self:Import ]
    | Variable              loc . self = Import_Variable @range.self @name.self
    | TypeOrClass           loc . self = Import_TypeOrClass @range.self @name.self @names.self
    | TypeOrClassComplete   loc . self = Import_TypeOrClassComplete @range.self @name.self

-- ------------------------------------------------------------------------
-- -- Declarations                                                       --
-- ------------------------------------------------------------------------

SEM MaybeDeclarations [ | | self:MaybeDeclarations ]
    | Nothing    loc . self = MaybeDeclarations_Nothing
    | Just       loc . self = MaybeDeclarations_Just @declarations.self

SEM Declarations [ | | self:Declarations ]
    | Cons        loc . self = @hd.self : @tl.self
    | Nil         loc . self = []
    
SEM Declaration [ | | self:Declaration ]
    | Type               loc . self = Declaration_Type @range.self @simpletype.self @type.self
    | Data               loc . self = Declaration_Data @range.self @context.self @simpletype.self @constructors.self @derivings.self               
    | Newtype            loc . self = Declaration_Newtype @range.self @context.self @simpletype.self @constructor.self @derivings.self
    | Class              loc . self = Declaration_Class @range.self @context.self @simpletype.self @where.self         
    | Instance           loc . self = Declaration_Instance @range.self @context.self @name.self @types.self @where.self     
    | Default            loc . self = Declaration_Default @range.self @types.self 
    | FunctionBindings   loc . self = Declaration_FunctionBindings @range.self @bindings.self            
    | PatternBinding     loc . self = Declaration_PatternBinding @range.self @pattern.self @righthandside.self    
    | TypeSignature      loc . self = Declaration_TypeSignature @range.self @names.self @type.self
    | Fixity             loc . self = Declaration_Fixity @range.self @fixity.self @priority.self @operators.self   
    | Empty              loc . self = Declaration_Empty @range.self    

SEM Fixity [ | | self:Fixity ]
    | Infixl    loc . self = Fixity_Infixl @range.self
    | Infixr    loc . self = Fixity_Infixr @range.self
    | Infix     loc . self = Fixity_Infix @range.self

-- ------------------------------------------------------------------------
-- -- Types                                                              --
-- ------------------------------------------------------------------------

SEM Types [ | | self:Types ]
    | Cons        loc . self = @hd.self : @tl.self
    | Nil         loc . self = []
    
SEM Type [ | | self:Type ]
    | Application     loc . self = Type_Application @range.self @prefix @function.self @arguments.self                    
    | Variable        loc . self = Type_Variable @range.self @name.self                              
    | Constructor     loc . self = Type_Constructor @range.self @name.self                  
    | Qualified       loc . self = Type_Qualified @range.self @context.self @type.self
    | Forall          loc . self = Type_Forall @range.self @typevariables.self @type.self
    | Exists          loc . self = Type_Exists @range.self @typevariables.self @type.self
    | Parenthesized   loc . self = Type_Parenthesized @range.self @type.self

SEM SimpleType [ | | self:SimpleType ]
    | SimpleType   loc . self = SimpleType_SimpleType @range.self @name.self @typevariables.self

SEM ContextItems [ | | self:ContextItems ]
    | Cons        loc . self = @hd.self : @tl.self
    | Nil         loc . self = []
    
SEM ContextItem [ | | self:ContextItem ]
    | ContextItem   loc . self = ContextItem_ContextItem @range.self @name.self @types.self

SEM Constructors [ | | self:Constructors ]
    | Cons        loc . self = @hd.self : @tl.self
    | Nil         loc . self = []
    
SEM Constructor [ | | self:Constructor ]
    | Constructor    loc . self = Constructor_Constructor @range.self @constructor.self @types.self
    | Infix          loc . self = Constructor_Infix @range.self @leftType.self @constructorOperator.self @rightType.self
    | Record         loc . self = Constructor_Record @range.self @constructor.self @fieldDeclarations.self

SEM FieldDeclarations [ | | self:FieldDeclarations ] 
    | Cons        loc . self = @hd.self : @tl.self
    | Nil         loc . self = []
    
SEM FieldDeclaration [ | | self:FieldDeclaration ]
    | FieldDeclaration   loc . self = FieldDeclaration_FieldDeclaration @range.self @names.self @type.self      

SEM AnnotatedTypes [ | | self:AnnotatedTypes ]
    | Cons        loc . self = @hd.self : @tl.self
    | Nil         loc . self = []
    
SEM AnnotatedType [ | | self:AnnotatedType ]
    | AnnotatedType   loc . self = AnnotatedType_AnnotatedType @range.self @strict @type.self

-- ------------------------------------------------------------------------
-- -- Expressions                                                        --
-- ------------------------------------------------------------------------

SEM Expressions [ | | self:Expressions ]
    | Cons        loc . self = @hd.self : @tl.self
    | Nil         loc . self = []

SEM MaybeExpression [ | | self:MaybeExpression ]
    | Nothing     loc . self = MaybeExpression_Nothing
    | Just        loc . self = MaybeExpression_Just @expression.self

SEM Expression [ | | self:Expression ]
    | Literal             loc . self = Expression_Literal @range.self @literal.self          
    | Variable            loc . self = Expression_Variable @range.self @name.self            
    | Constructor         loc . self = Expression_Constructor @range.self @name.self            
    | Parenthesized       loc . self = Expression_Parenthesized @range.self @expression.self
    | NormalApplication   loc . self = Expression_NormalApplication @range.self @function.self @arguments.self       
    | InfixApplication    loc . self = Expression_InfixApplication @range.self @leftExpression.self @operator.self @rightExpression.self
    | If                  loc . self = Expression_If @range.self @guardExpression.self @thenExpression.self @elseExpression.self
    | Lambda              loc . self = Expression_Lambda @range.self @patterns.self @expression.self           
    | Case                loc . self = Expression_Case @range.self @expression.self @alternatives.self         
    | Let                 loc . self = Expression_Let @range.self @declarations.self @expression.self          
    | Do                  loc . self = Expression_Do @range.self @statements.self
    | Tuple               loc . self = Expression_Tuple @range.self @expressions.self
    | Comprehension       loc . self = Expression_Comprehension @range.self @expression.self @qualifiers.self
    | Typed               loc . self = Expression_Typed @range.self @expression.self @type.self       
    | RecordConstruction  loc . self = Expression_RecordConstruction @range.self @name.self @recordExpressionBindings.self
    | RecordUpdate        loc . self = Expression_RecordUpdate @range.self @expression.self @recordExpressionBindings.self
    | Enum                loc . self = Expression_Enum @range.self @from.self @then.self @to.self
    | Negate              loc . self = Expression_Negate @range.self @expression.self
    | NegateFloat         loc . self = Expression_NegateFloat @range.self @expression.self

SEM Statements [ | | self:Statements ]
    | Cons        loc . self = @hd.self : @tl.self
    | Nil         loc . self = []

SEM Statement [ | | self:Statement ]
    | Expression  loc . self = Statement_Expression @range.self @expression.self
    | Let         loc . self = Statement_Let @range.self @declarations.self
    | Generator   loc . self = Statement_Generator @range.self @pattern.self @expression.self
    | Empty       loc . self = Statement_Empty @range.self

SEM Qualifiers [ | | self:Qualifiers ]
    | Cons        loc . self = @hd.self : @tl.self
    | Nil         loc . self = []
    
SEM Qualifier [ | | self:Qualifier ]
    | Guard       loc . self = Qualifier_Guard @range.self @guard.self
    | Let         loc . self = Qualifier_Let @range.self @declarations.self
    | Generator   loc . self = Qualifier_Generator @range.self @pattern.self @expression.self
    | Empty       loc . self = Qualifier_Empty @range.self

SEM Alternatives [ | | self:Alternatives ]
    | Cons        loc . self = @hd.self : @tl.self
    | Nil         loc . self = []

SEM Alternative [ | | self:Alternative ] 
    | Alternative    loc . self = Alternative_Alternative @range.self @pattern.self @righthandside.self
    | Empty          loc . self = Alternative_Empty @range.self

SEM GuardedExpressions [ | | self:GuardedExpressions ]
    | Cons        loc . self = @hd.self : @tl.self
    | Nil         loc . self = []
    
SEM GuardedExpression [ | | self:GuardedExpression ]
    | GuardedExpression   loc . self = GuardedExpression_GuardedExpression @range.self @guard.self @expression.self

SEM RecordExpressionBindings [ | | self:RecordExpressionBindings ]
    | Cons        loc . self = @hd.self : @tl.self
    | Nil         loc . self = []
    
SEM RecordExpressionBinding [ | | self:RecordExpressionBinding ]
    | RecordExpressionBinding   loc . self = RecordExpressionBinding_RecordExpressionBinding @range.self @name.self @expression.self

SEM RecordPatternBindings [ | | self:RecordPatternBindings ]
    | Cons        loc . self = @hd.self : @tl.self    
    | Nil         loc . self = []
    
SEM RecordPatternBinding [ | | self:RecordPatternBinding ]
    | RecordPatternBinding   loc . self = RecordPatternBinding_RecordPatternBinding @range.self @name.self @pattern.self

SEM FunctionBindings [ | | self:FunctionBindings ]
    | Cons        loc . self = @hd.self : @tl.self
    | Nil         loc . self = []

SEM FunctionBinding [ | | self:FunctionBinding ]
    | FunctionBinding   loc . self = FunctionBinding_FunctionBinding @range.self @lefthandside.self @righthandside.self

SEM LeftHandSide [ | | self:LeftHandSide ]
    | Function       loc . self = LeftHandSide_Function @range.self @name.self @patterns.self
    | Infix          loc . self = LeftHandSide_Infix @range.self @leftPattern.self @operator.self @rightPattern.self
    | Parenthesized  loc . self = LeftHandSide_Parenthesized @range.self @lefthandside.self @patterns.self

SEM RightHandSide [ | | self:RightHandSide ]
    | Expression  loc . self = RightHandSide_Expression @range.self @expression.self @where.self
    | Guarded     loc . self = RightHandSide_Guarded @range.self @guardedexpressions.self @where.self

-- ------------------------------------------------------------------------
-- -- Patterns                                                           --
-- ------------------------------------------------------------------------

SEM Patterns [ | | self:Patterns ]
    | Cons        loc . self = @hd.self : @tl.self
    | Nil         loc . self = []
    

SEM Pattern [ | | self:Pattern ] 
    | Literal            loc . self = Pattern_Literal @range.self @literal.self               
    | Variable           loc . self = Pattern_Variable @range.self @name.self                 
    | Constructor        loc . self = Pattern_Constructor @range.self @name.self @patterns.self                
    | Parenthesized      loc . self = Pattern_Parenthesized @range.self @pattern.self
    | InfixConstructor   loc . self = Pattern_InfixConstructor @range.self @leftPattern.self @constructorOperator.self @rightPattern.self
    | Tuple              loc . self = Pattern_Tuple @range.self @patterns.self
    | Record             loc . self = Pattern_Record @range.self @name.self @recordPatternBindings.self
    | Negate             loc . self = Pattern_Negate @range.self @literal.self
    | NegateFloat        loc . self = Pattern_NegateFloat @range.self @literal.self
    | As                 loc . self = Pattern_As @range.self @name.self @pattern.self                 
    | Wildcard           loc . self = Pattern_Wildcard @range.self
    | Irrefutable        loc . self = Pattern_Irrefutable @range.self @pattern.self
    | Successor          loc . self = Pattern_Successor @range.self @name.self @literal.self

-- ------------------------------------------------------------------------
-- -- Basics                                                             --
-- ------------------------------------------------------------------------

SEM Literal [ | | self:Literal ]                                
    | Int         loc . self = Literal_Int @range.self @value                             
    | Char        loc . self = Literal_Char @range.self @value                         
    | Float       loc . self = Literal_Float @range.self @value
    | String      loc . self = Literal_String @range.self @value                      

SEM Names [ | | self:Names ]
    | Cons        loc . self = @hd.self : @tl.self
    | Nil         loc . self = []
     

SEM MaybeNames [ | | self:MaybeNames ]
    | Nothing     loc . self = MaybeNames_Nothing
    | Just        loc . self = MaybeNames_Just @names.self

SEM MaybeName [ | | self:MaybeName ]
    | Nothing     loc . self = MaybeName_Nothing
    | Just        loc . self = MaybeName_Just @name.self

SEM Name [ | | self:Name ]
    | Identifier  loc . self = Name_Identifier @range.self @module.self @name
    | Operator    loc . self = Name_Operator @range.self @module.self @name
    | Special     loc . self = Name_Special @range.self @module.self @name

SEM Strings [ | | self:Strings ]
    | Cons        loc . self = @hd : @tl.self
    | Nil         loc . self = []

SEM MaybeInt [ | | self:MaybeInt ]
    | Nothing     loc . self = MaybeInt_Nothing
    | Just        loc . self = MaybeInt_Just @int

SEM Range [ | | self:Range ]
    | Range       loc . self = Range_Range @start.self @stop.self

SEM Position [ | | self:Position ] 
    | Position    loc . self = Position_Position @filename @line @column
    | Unknown     loc . self = Position_Unknown
