-- do not edit; automatically generated by UU_AG
module CodeGeneration where

import UHA_Syntax
import UHA_Utils
import List (union)
import Messages () -- instance Show Name
import ImportEnvironment
import FiniteMap
import TypeConversion
import Char (ord)

import Id
import IdSet 
import Utils(internalError)

import Types
import PatternMatch
import DerivingShow

-- Semi-Daan
import CoreUtils

-- Daan
import qualified Core
import qualified Module
import qualified Byte
import qualified CoreParse

import Byte(bytesFromString)


intErr = internalError "UHA_ToCore"

type CoreDecl = Core.Decl Core.Expr

makeCoreModule name decls =
    Module.Module
        { Module.moduleName   =
            case name of
                Nothing -> idFromString "Main"
                Just n -> n
        , Module.moduleMajorVer = 0
        , Module.moduleMinorVer = 0
        , Module.moduleDecls    = decls
        }

interpreterMain = "interpreter_main"

-- Unfortunately we need a hack for the interpreter
-- The interpreter_main has te be wrapped inside unsafePerformIO etcetera, too
-- We can't just call it main because we'll get import clashes.  Sigh!

insertedMain :: ImportEnvironment -> CoreDecl
insertedMain importEnv =
    let maybeWrapMainAndType = 
            case lookupFM typeEnv (Name_Identifier noRange [] "main")  of
                Just t -> Just ("main", t)
                Nothing ->
                    case lookupFM typeEnv (Name_Identifier noRange [] interpreterMain) of
                        Just t -> Just (interpreterMain, t)
                        Nothing -> Nothing
    in
    decl False "main$" $
        app_ unsafePIO $
            case maybeWrapMainAndType of 
                Nothing -> 
                    var "primPutStrLn" `app_` 
                        (var "primPackedToString" `app_`
                            packedString "No 'main' function defined in this module")
                Just (name, tpScheme)
                    | isIOType tp -> 
                        var name
                    | otherwise ->
                        var "primPutStrLn" `app_` 
                            (showFunctionOfType True (makeTypeFromTp tp) `app_` 
                                var name)
                    where                        
                        tp = unsafeInstantiate tpScheme
    where
        unsafePIO = var "primUnsafePerformIO"
        typeEnv = typeEnvironment importEnv        
                

nameFromId :: Id -> Name
nameFromId i = Name_Identifier noRange [] (stringFromId i)

toplevelType :: Name -> ImportEnvironment -> Bool -> [Core.Custom]
toplevelType name ie isTopLevel
    | isTopLevel = [customType typeString]
    | otherwise  = []
    where
        typeString = maybe
            (internalError "UHA_ToCore" "Declaration" ("no type found for " ++ getNameName name))
            show
            (lookupFM (typeEnvironment ie) name)

constructorTypeAndArity :: Name -> ValueConstructorEnvironment -> [Core.Custom]
constructorTypeAndArity name env =
    maybe 
        (internalError "UHA_ToCore" "Constructor" ("no type found for " ++ show name))
        (\tpScheme -> 
            [ customType (show tpScheme)]
        )
        (lookupFM env name)


-- Function "bind" is used in the translation of do-expressions
bind :: Core.Expr -> Core.Expr -> Core.Expr
bind ma f = Core.Var primBindIOId `app_` ma `app_` f

( primBindIOId :  caseExprId :  okId :  parameterId : []) = map idFromString $
 "primBindIO"  : "caseExpr$" : "ok$" : "parameter$" : []

-- Function "chainCode" is used in the translation of do-expressions
chainCode :: [Maybe Core.Expr -> Core.Expr] -> Core.Expr
chainCode cores =
    case cores of
        [core] -> core Nothing
        (core:cores) -> core (Just (chainCode cores))


patternAlwaysSucceeds :: Pattern -> Bool
patternAlwaysSucceeds p = 
    case p of
        Pattern_Variable _ _ -> True
        Pattern_Wildcard _ -> True
        Pattern_As _ _ p -> patternAlwaysSucceeds p
        Pattern_Parenthesized _ p -> patternAlwaysSucceeds p
        _ -> False

throwException :: String -> Core.Expr
throwException message = 
    var "primErrorPacked"
        `app_` packedString message

patternMatchFail :: Range -> Core.Expr
patternMatchFail range =
    var "primPatternFailPacked"
        `app_` packedString (showRange range)

showRange :: Range -> String
showRange (Range_Range (Position_Position mod line column) _) = mod ++ show (line, column)
showRange _ = internalError "ToCorePat.ag" "showRange" "unknown position"
-- Alternative -------------------------------------------------
-- semantic domain
type T_Alternative = (( Core.Expr -> Core.Expr ),(Alternative))
-- cata
sem_Alternative :: (Alternative) ->
                   (T_Alternative)
sem_Alternative ((Alternative_Alternative (_range) (_pattern) (_righthandside))) =
    (sem_Alternative_Alternative ((sem_Range (_range))) ((sem_Pattern (_pattern))) ((sem_RightHandSide (_righthandside))))
sem_Alternative ((Alternative_Empty (_range))) =
    (sem_Alternative_Empty ((sem_Range (_range))))
sem_Alternative_Alternative :: (T_Range) ->
                               (T_Pattern) ->
                               (T_RightHandSide) ->
                               (T_Alternative)
sem_Alternative_Alternative (_range) (_pattern) (_righthandside) =
    let (_self) =
            Alternative_Alternative _range_self _pattern_self _righthandside_self
        ( _range_self) =
            (_range )
        ( _pattern_self,_pattern_vars) =
            (_pattern )
        ( _righthandside_core,_righthandside_isGuarded,_righthandside_self) =
            (_righthandside )
    in  (\nextCase  ->
            let thisCase =
                    patternToCore
                        (caseExprId, _pattern_self)
                        _righthandside_core
            in
                let_ nextClauseId nextCase thisCase
        ,_self
        )
sem_Alternative_Empty :: (T_Range) ->
                         (T_Alternative)
sem_Alternative_Empty (_range) =
    let (_self) =
            Alternative_Empty _range_self
        ( _range_self) =
            (_range )
    in  (id,_self)
-- Alternatives ------------------------------------------------
-- semantic domain
type T_Alternatives = (Range) ->
                      (( Core.Expr ),(Alternatives))
-- cata
sem_Alternatives :: (Alternatives) ->
                    (T_Alternatives)
sem_Alternatives (list) =
    (foldr (sem_Alternatives_Cons) (sem_Alternatives_Nil) ((map sem_Alternative list)))
sem_Alternatives_Cons :: (T_Alternative) ->
                         (T_Alternatives) ->
                         (T_Alternatives)
sem_Alternatives_Cons (_hd) (_tl) (_lhs_caseRange) =
    let (_self) =
            _hd_self : _tl_self
        ( _hd_core,_hd_self) =
            (_hd )
        ( _tl_core,_tl_self) =
            (_tl (_lhs_caseRange))
    in  (_hd_core _tl_core,_self)
sem_Alternatives_Nil :: (T_Alternatives)
sem_Alternatives_Nil (_lhs_caseRange) =
    let (_self) =
            []
    in  (patternMatchFail _lhs_caseRange,_self)
-- AnnotatedType -----------------------------------------------
-- semantic domain
type T_AnnotatedType = ((AnnotatedType))
-- cata
sem_AnnotatedType :: (AnnotatedType) ->
                     (T_AnnotatedType)
sem_AnnotatedType ((AnnotatedType_AnnotatedType (_range) (_strict) (_type))) =
    (sem_AnnotatedType_AnnotatedType ((sem_Range (_range))) (_strict) ((sem_Type (_type))))
sem_AnnotatedType_AnnotatedType :: (T_Range) ->
                                   (Bool) ->
                                   (T_Type) ->
                                   (T_AnnotatedType)
sem_AnnotatedType_AnnotatedType (_range) (_strict) (_type) =
    let (_self) =
            AnnotatedType_AnnotatedType _range_self _strict _type_self
        ( _range_self) =
            (_range )
        ( _type_self) =
            (_type )
    in  (_self)
-- AnnotatedTypes ----------------------------------------------
-- semantic domain
type T_AnnotatedTypes = ((Int),(AnnotatedTypes))
-- cata
sem_AnnotatedTypes :: (AnnotatedTypes) ->
                      (T_AnnotatedTypes)
sem_AnnotatedTypes (list) =
    (foldr (sem_AnnotatedTypes_Cons) (sem_AnnotatedTypes_Nil) ((map sem_AnnotatedType list)))
sem_AnnotatedTypes_Cons :: (T_AnnotatedType) ->
                           (T_AnnotatedTypes) ->
                           (T_AnnotatedTypes)
sem_AnnotatedTypes_Cons (_hd) (_tl) =
    let (_self) =
            _hd_self : _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_length,_tl_self) =
            (_tl )
    in  (1 + _tl_length,_self)
sem_AnnotatedTypes_Nil :: (T_AnnotatedTypes)
sem_AnnotatedTypes_Nil  =
    let (_self) =
            []
    in  (0,_self)
-- Body --------------------------------------------------------
-- semantic domain
type T_Body = (ImportEnvironment) ->
              (( [CoreDecl] ),(Body))
-- cata
sem_Body :: (Body) ->
            (T_Body)
sem_Body ((Body_Body (_range) (_importdeclarations) (_declarations))) =
    (sem_Body_Body ((sem_Range (_range))) ((sem_ImportDeclarations (_importdeclarations))) ((sem_Declarations (_declarations))))
sem_Body_Body :: (T_Range) ->
                 (T_ImportDeclarations) ->
                 (T_Declarations) ->
                 (T_Body)
sem_Body_Body (_range) (_importdeclarations) (_declarations) (_lhs_importEnv) =
    let (_self) =
            Body_Body _range_self _importdeclarations_self _declarations_self
        ( _range_self) =
            (_range )
        ( _importdeclarations_self) =
            (_importdeclarations )
        ( _declarations_decls,_declarations_patBindNr,_declarations_self) =
            (_declarations (_lhs_importEnv) (True) (0))
    in  (_declarations_decls,_self)
-- Constructor -------------------------------------------------
-- semantic domain
type T_Constructor = (ImportEnvironment) ->
                     (Int) ->
                     (( [(Id, CoreDecl)] ),(Constructor))
-- cata
sem_Constructor :: (Constructor) ->
                   (T_Constructor)
sem_Constructor ((Constructor_Constructor (_range) (_constructor) (_types))) =
    (sem_Constructor_Constructor ((sem_Range (_range))) ((sem_Name (_constructor))) ((sem_AnnotatedTypes (_types))))
sem_Constructor ((Constructor_Infix (_range) (_leftType) (_constructorOperator) (_rightType))) =
    (sem_Constructor_Infix ((sem_Range (_range))) ((sem_AnnotatedType (_leftType))) ((sem_Name (_constructorOperator))) ((sem_AnnotatedType (_rightType))))
sem_Constructor ((Constructor_Record (_range) (_constructor) (_fieldDeclarations))) =
    (sem_Constructor_Record ((sem_Range (_range))) ((sem_Name (_constructor))) ((sem_FieldDeclarations (_fieldDeclarations))))
sem_Constructor_Constructor :: (T_Range) ->
                               (T_Name) ->
                               (T_AnnotatedTypes) ->
                               (T_Constructor)
sem_Constructor_Constructor (_range) (_constructor) (_types) (_lhs_importEnv) (_lhs_tag) =
    let (_self) =
            Constructor_Constructor _range_self _constructor_self _types_self
        ( _range_self) =
            (_range )
        ( _constructor_id,_constructor_self) =
            (_constructor )
        ( _types_length,_types_self) =
            (_types )
    in  ([ (_constructor_id, Core.DeclCon
             { Core.declName    = _constructor_id
             , Core.declAccess  = Core.private
             , Core.declArity   = _types_length
             , Core.conTag      = _lhs_tag
             , Core.declCustoms = constructorTypeAndArity _constructor_self
                                     (valueConstructors _lhs_importEnv)
             }
           )
         ]
        ,_self
        )
sem_Constructor_Infix :: (T_Range) ->
                         (T_AnnotatedType) ->
                         (T_Name) ->
                         (T_AnnotatedType) ->
                         (T_Constructor)
sem_Constructor_Infix (_range) (_leftType) (_constructorOperator) (_rightType) (_lhs_importEnv) (_lhs_tag) =
    let (_self) =
            Constructor_Infix _range_self _leftType_self _constructorOperator_self _rightType_self
        ( _range_self) =
            (_range )
        ( _leftType_self) =
            (_leftType )
        ( _constructorOperator_id,_constructorOperator_self) =
            (_constructorOperator )
        ( _rightType_self) =
            (_rightType )
    in  ([ (_constructorOperator_id, Core.DeclCon
             { Core.declName    = _constructorOperator_id
             , Core.declAccess  = Core.private
             , Core.declArity   = 2
             , Core.conTag      = _lhs_tag
             , Core.declCustoms = constructorTypeAndArity _constructorOperator_self
                                     (valueConstructors _lhs_importEnv)
             }
           )
         ]
        ,_self
        )
sem_Constructor_Record :: (T_Range) ->
                          (T_Name) ->
                          (T_FieldDeclarations) ->
                          (T_Constructor)
sem_Constructor_Record (_range) (_constructor) (_fieldDeclarations) (_lhs_importEnv) (_lhs_tag) =
    let (_self) =
            Constructor_Record _range_self _constructor_self _fieldDeclarations_self
        ( _range_self) =
            (_range )
        ( _constructor_id,_constructor_self) =
            (_constructor )
        ( _fieldDeclarations_self) =
            (_fieldDeclarations )
    in  (intErr "Constructor" "records not supported",_self)
-- Constructors ------------------------------------------------
-- semantic domain
type T_Constructors = (ImportEnvironment) ->
                      (Int) ->
                      (( [(Id, CoreDecl)] ),(Constructors))
-- cata
sem_Constructors :: (Constructors) ->
                    (T_Constructors)
sem_Constructors (list) =
    (foldr (sem_Constructors_Cons) (sem_Constructors_Nil) ((map sem_Constructor list)))
sem_Constructors_Cons :: (T_Constructor) ->
                         (T_Constructors) ->
                         (T_Constructors)
sem_Constructors_Cons (_hd) (_tl) (_lhs_importEnv) (_lhs_tag) =
    let (_self) =
            _hd_self : _tl_self
        ( _hd_cons,_hd_self) =
            (_hd (_lhs_importEnv) (_lhs_tag))
        ( _tl_cons,_tl_self) =
            (_tl (_lhs_importEnv) (_lhs_tag + 1))
    in  (_hd_cons  ++  _tl_cons,_self)
sem_Constructors_Nil :: (T_Constructors)
sem_Constructors_Nil (_lhs_importEnv) (_lhs_tag) =
    let (_self) =
            []
    in  ([],_self)
-- ContextItem -------------------------------------------------
-- semantic domain
type T_ContextItem = ((ContextItem))
-- cata
sem_ContextItem :: (ContextItem) ->
                   (T_ContextItem)
sem_ContextItem ((ContextItem_ContextItem (_range) (_name) (_types))) =
    (sem_ContextItem_ContextItem ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Types (_types))))
sem_ContextItem_ContextItem :: (T_Range) ->
                               (T_Name) ->
                               (T_Types) ->
                               (T_ContextItem)
sem_ContextItem_ContextItem (_range) (_name) (_types) =
    let (_self) =
            ContextItem_ContextItem _range_self _name_self _types_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
        ( _types_self) =
            (_types )
    in  (_self)
-- ContextItems ------------------------------------------------
-- semantic domain
type T_ContextItems = ((ContextItems))
-- cata
sem_ContextItems :: (ContextItems) ->
                    (T_ContextItems)
sem_ContextItems (list) =
    (foldr (sem_ContextItems_Cons) (sem_ContextItems_Nil) ((map sem_ContextItem list)))
sem_ContextItems_Cons :: (T_ContextItem) ->
                         (T_ContextItems) ->
                         (T_ContextItems)
sem_ContextItems_Cons (_hd) (_tl) =
    let (_self) =
            _hd_self : _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  (_self)
sem_ContextItems_Nil :: (T_ContextItems)
sem_ContextItems_Nil  =
    let (_self) =
            []
    in  (_self)
-- Declaration -------------------------------------------------
-- semantic domain
type T_Declaration = (ImportEnvironment) ->
                     (Bool) ->
                     (Int) ->
                     (( [CoreDecl] ),(Int),(Declaration))
-- cata
sem_Declaration :: (Declaration) ->
                   (T_Declaration)
sem_Declaration ((Declaration_Class (_range) (_context) (_simpletype) (_where))) =
    (sem_Declaration_Class ((sem_Range (_range))) ((sem_ContextItems (_context))) ((sem_SimpleType (_simpletype))) ((sem_MaybeDeclarations (_where))))
sem_Declaration ((Declaration_Data (_range) (_context) (_simpletype) (_constructors) (_derivings))) =
    (sem_Declaration_Data ((sem_Range (_range))) ((sem_ContextItems (_context))) ((sem_SimpleType (_simpletype))) ((sem_Constructors (_constructors))) ((sem_Names (_derivings))))
sem_Declaration ((Declaration_Default (_range) (_types))) =
    (sem_Declaration_Default ((sem_Range (_range))) ((sem_Types (_types))))
sem_Declaration ((Declaration_Empty (_range))) =
    (sem_Declaration_Empty ((sem_Range (_range))))
sem_Declaration ((Declaration_Fixity (_range) (_fixity) (_priority) (_operators))) =
    (sem_Declaration_Fixity ((sem_Range (_range))) ((sem_Fixity (_fixity))) ((sem_MaybeInt (_priority))) ((sem_Names (_operators))))
sem_Declaration ((Declaration_FunctionBindings (_range) (_bindings))) =
    (sem_Declaration_FunctionBindings ((sem_Range (_range))) ((sem_FunctionBindings (_bindings))))
sem_Declaration ((Declaration_Instance (_range) (_context) (_name) (_types) (_where))) =
    (sem_Declaration_Instance ((sem_Range (_range))) ((sem_ContextItems (_context))) ((sem_Name (_name))) ((sem_Types (_types))) ((sem_MaybeDeclarations (_where))))
sem_Declaration ((Declaration_Newtype (_range) (_context) (_simpletype) (_constructor) (_derivings))) =
    (sem_Declaration_Newtype ((sem_Range (_range))) ((sem_ContextItems (_context))) ((sem_SimpleType (_simpletype))) ((sem_Constructor (_constructor))) ((sem_Names (_derivings))))
sem_Declaration ((Declaration_PatternBinding (_range) (_pattern) (_righthandside))) =
    (sem_Declaration_PatternBinding ((sem_Range (_range))) ((sem_Pattern (_pattern))) ((sem_RightHandSide (_righthandside))))
sem_Declaration ((Declaration_Type (_range) (_simpletype) (_type))) =
    (sem_Declaration_Type ((sem_Range (_range))) ((sem_SimpleType (_simpletype))) ((sem_Type (_type))))
sem_Declaration ((Declaration_TypeSignature (_range) (_names) (_type))) =
    (sem_Declaration_TypeSignature ((sem_Range (_range))) ((sem_Names (_names))) ((sem_Type (_type))))
sem_Declaration_Class :: (T_Range) ->
                         (T_ContextItems) ->
                         (T_SimpleType) ->
                         (T_MaybeDeclarations) ->
                         (T_Declaration)
sem_Declaration_Class (_range) (_context) (_simpletype) (_where) (_lhs_importEnv) (_lhs_isTopLevel) (_lhs_patBindNr) =
    let (_self) =
            Declaration_Class _range_self _context_self _simpletype_self _where_self
        ( _range_self) =
            (_range )
        ( _context_self) =
            (_context )
        ( _simpletype_name,_simpletype_self,_simpletype_typevariables) =
            (_simpletype )
        ( _where_core,_where_self) =
            (_where )
    in  (intErr "Declaration" "'class' not supported",_lhs_patBindNr,_self)
sem_Declaration_Data :: (T_Range) ->
                        (T_ContextItems) ->
                        (T_SimpleType) ->
                        (T_Constructors) ->
                        (T_Names) ->
                        (T_Declaration)
sem_Declaration_Data (_range) (_context) (_simpletype) (_constructors) (_derivings) (_lhs_importEnv) (_lhs_isTopLevel) (_lhs_patBindNr) =
    let (_self) =
            Declaration_Data _range_self _context_self _simpletype_self _constructors_self _derivings_self
        ( _range_self) =
            (_range )
        ( _context_self) =
            (_context )
        ( _simpletype_name,_simpletype_self,_simpletype_typevariables) =
            (_simpletype )
        ( _constructors_cons,_constructors_self) =
            (_constructors (_lhs_importEnv) (0))
        ( _derivings_ids,_derivings_self) =
            (_derivings )
    in  (map snd _constructors_cons
         ++
         [ Core.DeclCustom
             { Core.declName    = idFromString (getNameName _simpletype_name)
             , Core.declAccess  = Core.private
             , Core.declKind    = Core.DeclKindCustom (idFromString "data")
             , Core.declCustoms = [Core.CustomInt (length _simpletype_typevariables)]
             }
         ]
         ++
         [derivingShow _self]
        ,_lhs_patBindNr
        ,_self
        )
sem_Declaration_Default :: (T_Range) ->
                           (T_Types) ->
                           (T_Declaration)
sem_Declaration_Default (_range) (_types) (_lhs_importEnv) (_lhs_isTopLevel) (_lhs_patBindNr) =
    let (_self) =
            Declaration_Default _range_self _types_self
        ( _range_self) =
            (_range )
        ( _types_self) =
            (_types )
    in  (intErr "Declaration" "'default' not supported",_lhs_patBindNr,_self)
sem_Declaration_Empty :: (T_Range) ->
                         (T_Declaration)
sem_Declaration_Empty (_range) (_lhs_importEnv) (_lhs_isTopLevel) (_lhs_patBindNr) =
    let (_self) =
            Declaration_Empty _range_self
        ( _range_self) =
            (_range )
    in  (intErr "Declaration" "empty declarations not supported",_lhs_patBindNr,_self)
sem_Declaration_Fixity :: (T_Range) ->
                          (T_Fixity) ->
                          (T_MaybeInt) ->
                          (T_Names) ->
                          (T_Declaration)
sem_Declaration_Fixity (_range) (_fixity) (_priority) (_operators) (_lhs_importEnv) (_lhs_isTopLevel) (_lhs_patBindNr) =
    let (_self) =
            Declaration_Fixity _range_self _fixity_self _priority_self _operators_self
        ( _range_self) =
            (_range )
        ( _fixity_self) =
            (_fixity )
        ( _priority_self) =
            (_priority )
        ( _operators_ids,_operators_self) =
            (_operators )
    in  (map
             ( ( \n ->
                 Core.DeclCustom
                     { Core.declName    = idFromString n
                     , Core.declAccess  = Core.private
                     , Core.declKind    = (Core.DeclKindCustom . idFromString) "infix"
                     , Core.declCustoms =
                         [ Core.CustomInt
                              ( case _priority_self of
                                   MaybeInt_Just i  -> i
                                   MaybeInt_Nothing -> 9 )
                         , (Core.CustomBytes . bytesFromString)
                               ( case _fixity_self of
                                    Fixity_Infixr _ -> "right"
                                    Fixity_Infixl _ -> "left"
                                    Fixity_Infix  _ -> "none"
                                    _               -> internalError
                                                         "ToCoreDecl.ag"
                                                         "SEM Declaration.Fixity"
                                                         "unknown fixity"
                               )
                         ]
                     }
               )
               .
               getNameName
             )
             _operators_self
        ,_lhs_patBindNr
        ,_self
        )
sem_Declaration_FunctionBindings :: (T_Range) ->
                                    (T_FunctionBindings) ->
                                    (T_Declaration)
sem_Declaration_FunctionBindings (_range) (_bindings) (_lhs_importEnv) (_lhs_isTopLevel) (_lhs_patBindNr) =
    let (_self) =
            Declaration_FunctionBindings _range_self _bindings_self
        (_ids) =
            freshIds "u$" _bindings_arity
        ( _range_self) =
            (_range )
        ( _bindings_arity,_bindings_core,_bindings_id,_bindings_self) =
            (_bindings (_ids) (_range_self))
    in  ([ Core.DeclValue
             { Core.declName    = _bindings_id
             , Core.declAccess  = Core.private
             , Core.valueEnc    = Nothing
             , Core.valueValue  = foldr Core.Lam _bindings_core _ids
             , Core.declCustoms = toplevelType (nameFromId _bindings_id) _lhs_importEnv _lhs_isTopLevel
             }
         ]
        ,_lhs_patBindNr
        ,_self
        )
sem_Declaration_Instance :: (T_Range) ->
                            (T_ContextItems) ->
                            (T_Name) ->
                            (T_Types) ->
                            (T_MaybeDeclarations) ->
                            (T_Declaration)
sem_Declaration_Instance (_range) (_context) (_name) (_types) (_where) (_lhs_importEnv) (_lhs_isTopLevel) (_lhs_patBindNr) =
    let (_self) =
            Declaration_Instance _range_self _context_self _name_self _types_self _where_self
        ( _range_self) =
            (_range )
        ( _context_self) =
            (_context )
        ( _name_id,_name_self) =
            (_name )
        ( _types_self) =
            (_types )
        ( _where_core,_where_self) =
            (_where )
    in  (intErr "Declaration" "'instance' not supported",_lhs_patBindNr,_self)
sem_Declaration_Newtype :: (T_Range) ->
                           (T_ContextItems) ->
                           (T_SimpleType) ->
                           (T_Constructor) ->
                           (T_Names) ->
                           (T_Declaration)
sem_Declaration_Newtype (_range) (_context) (_simpletype) (_constructor) (_derivings) (_lhs_importEnv) (_lhs_isTopLevel) (_lhs_patBindNr) =
    let (_self) =
            Declaration_Newtype _range_self _context_self _simpletype_self _constructor_self _derivings_self
        ( _range_self) =
            (_range )
        ( _context_self) =
            (_context )
        ( _simpletype_name,_simpletype_self,_simpletype_typevariables) =
            (_simpletype )
        ( _constructor_cons,_constructor_self) =
            (_constructor (_lhs_importEnv) (0))
        ( _derivings_ids,_derivings_self) =
            (_derivings )
    in  (intErr "Declaration" "'newType' not supported",_lhs_patBindNr,_self)
sem_Declaration_PatternBinding :: (T_Range) ->
                                  (T_Pattern) ->
                                  (T_RightHandSide) ->
                                  (T_Declaration)
sem_Declaration_PatternBinding (_range) (_pattern) (_righthandside) (_lhs_importEnv) (_lhs_isTopLevel) (_lhs_patBindNr) =
    let (_self) =
            Declaration_PatternBinding _range_self _pattern_self _righthandside_self
        ( _range_self) =
            (_range )
        ( _pattern_self,_pattern_vars) =
            (_pattern )
        ( _righthandside_core,_righthandside_isGuarded,_righthandside_self) =
            (_righthandside )
    in  (case _pattern_self of
             Pattern_Variable _ n ->
                 [ Core.DeclValue
                     { Core.declName    = idFromName n
                     , Core.declAccess  = Core.private
                     , Core.valueEnc    = Nothing
                     , Core.valueValue  =
                         let_
                             nextClauseId (patternMatchFail _range_self)
                             _righthandside_core
                     , Core.declCustoms = toplevelType n _lhs_importEnv _lhs_isTopLevel
                     }
                ]
             _ ->
                 Core.DeclValue
                     { Core.declName    = patBindId
                     , Core.declAccess  = Core.private
                     , Core.valueEnc    = Nothing
                     , Core.valueValue  = _righthandside_core
                     , Core.declCustoms = []
                     }
                 :
                 [ Core.DeclValue
                     { Core.declName    = v
                     , Core.declAccess  = Core.private
                     , Core.valueEnc    = Nothing
                     , Core.valueValue  =
                         (let_ nextClauseId (patternMatchFail _range_self)
                             (patternToCore (patBindId, _pattern_self) (Core.Var v))
                         )
                     , Core.declCustoms = toplevelType (nameFromId v) _lhs_importEnv _lhs_isTopLevel
                     }
                 | v <- _pattern_vars
                 ]
                 where
                     patBindId = idFromString ("patBind$" ++ show _lhs_patBindNr)
        ,_lhs_patBindNr + 1
        ,_self
        )
sem_Declaration_Type :: (T_Range) ->
                        (T_SimpleType) ->
                        (T_Type) ->
                        (T_Declaration)
sem_Declaration_Type (_range) (_simpletype) (_type) (_lhs_importEnv) (_lhs_isTopLevel) (_lhs_patBindNr) =
    let (_self) =
            Declaration_Type _range_self _simpletype_self _type_self
        ( _range_self) =
            (_range )
        ( _simpletype_name,_simpletype_self,_simpletype_typevariables) =
            (_simpletype )
        ( _type_self) =
            (_type )
    in  (let
             (t1,[t2])   = convertFromSimpleTypeAndTypes _simpletype_self [_type_self]
             allTypeVars = ftv [t1,t2]
             (ts1,ts2)   = (Scheme allTypeVars [] t1,Scheme allTypeVars [] t2)
         in
         [ Core.DeclCustom
             { Core.declName    = idFromString (getNameName _simpletype_name)
             , Core.declAccess  = Core.private
             , Core.declKind    = Core.DeclKindCustom (idFromString "typedecl")
             , Core.declCustoms =
                 [ Core.CustomBytes
                     (Byte.bytesFromString
                         (  show ts1
                         ++ " = "
                         ++ show ts2
                         )
                     )
                 , Core.CustomInt
                     (length _simpletype_typevariables)
                 ]
             }
         ]
         ++
         [derivingShow _self]
        ,_lhs_patBindNr
        ,_self
        )
sem_Declaration_TypeSignature :: (T_Range) ->
                                 (T_Names) ->
                                 (T_Type) ->
                                 (T_Declaration)
sem_Declaration_TypeSignature (_range) (_names) (_type) (_lhs_importEnv) (_lhs_isTopLevel) (_lhs_patBindNr) =
    let (_self) =
            Declaration_TypeSignature _range_self _names_self _type_self
        ( _range_self) =
            (_range )
        ( _names_ids,_names_self) =
            (_names )
        ( _type_self) =
            (_type )
    in  ([],_lhs_patBindNr,_self)
-- Declarations ------------------------------------------------
-- semantic domain
type T_Declarations = (ImportEnvironment) ->
                      (Bool) ->
                      (Int) ->
                      (( [CoreDecl] ),(Int),(Declarations))
-- cata
sem_Declarations :: (Declarations) ->
                    (T_Declarations)
sem_Declarations (list) =
    (foldr (sem_Declarations_Cons) (sem_Declarations_Nil) ((map sem_Declaration list)))
sem_Declarations_Cons :: (T_Declaration) ->
                         (T_Declarations) ->
                         (T_Declarations)
sem_Declarations_Cons (_hd) (_tl) (_lhs_importEnv) (_lhs_isTopLevel) (_lhs_patBindNr) =
    let (_self) =
            _hd_self : _tl_self
        ( _hd_decls,_hd_patBindNr,_hd_self) =
            (_hd (_lhs_importEnv) (_lhs_isTopLevel) (_lhs_patBindNr))
        ( _tl_decls,_tl_patBindNr,_tl_self) =
            (_tl (_lhs_importEnv) (_lhs_isTopLevel) (_hd_patBindNr))
    in  (_hd_decls  ++  _tl_decls,_tl_patBindNr,_self)
sem_Declarations_Nil :: (T_Declarations)
sem_Declarations_Nil (_lhs_importEnv) (_lhs_isTopLevel) (_lhs_patBindNr) =
    let (_self) =
            []
    in  ([],_lhs_patBindNr,_self)
-- Export ------------------------------------------------------
-- semantic domain
type T_Export = ((IdSet),(IdSet),(Export),(IdSet),(IdSet))
-- cata
sem_Export :: (Export) ->
              (T_Export)
sem_Export ((Export_Module (_range) (_name))) =
    (sem_Export_Module ((sem_Range (_range))) ((sem_Name (_name))))
sem_Export ((Export_TypeOrClass (_range) (_name) (_names))) =
    (sem_Export_TypeOrClass ((sem_Range (_range))) ((sem_Name (_name))) ((sem_MaybeNames (_names))))
sem_Export ((Export_TypeOrClassComplete (_range) (_name))) =
    (sem_Export_TypeOrClassComplete ((sem_Range (_range))) ((sem_Name (_name))))
sem_Export ((Export_Variable (_range) (_name))) =
    (sem_Export_Variable ((sem_Range (_range))) ((sem_Name (_name))))
sem_Export_Module :: (T_Range) ->
                     (T_Name) ->
                     (T_Export)
sem_Export_Module (_range) (_name) =
    let (_self) =
            Export_Module _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
    in  (emptySet,singleSet _name_id,_self,emptySet,emptySet)
sem_Export_TypeOrClass :: (T_Range) ->
                          (T_Name) ->
                          (T_MaybeNames) ->
                          (T_Export)
sem_Export_TypeOrClass (_range) (_name) (_names) =
    let (_self) =
            Export_TypeOrClass _range_self _name_self _names_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
        ( _names_ids,_names_self) =
            (_names )
    in  (setFromList (maybe [] id _names_ids),emptySet,_self,singleSet _name_id,emptySet)
sem_Export_TypeOrClassComplete :: (T_Range) ->
                                  (T_Name) ->
                                  (T_Export)
sem_Export_TypeOrClassComplete (_range) (_name) =
    let (_self) =
            Export_TypeOrClassComplete _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
    in  (internalError "UHA_ToCore" "exports.tocc" "Unsupported export declaration",internalError "UHA_ToCore" "exports.tocc" "Unsupported export declaration",_self,internalError "UHA_ToCore" "exports.tocc" "Unsupported export declaration",internalError "UHA_ToCore" "exports.tocc" "Unsupported export declaration")
sem_Export_Variable :: (T_Range) ->
                       (T_Name) ->
                       (T_Export)
sem_Export_Variable (_range) (_name) =
    let (_self) =
            Export_Variable _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
    in  (emptySet,emptySet,_self,emptySet,singleSet _name_id)
-- Exports -----------------------------------------------------
-- semantic domain
type T_Exports = ((IdSet),(IdSet),(Exports),(IdSet),(IdSet))
-- cata
sem_Exports :: (Exports) ->
               (T_Exports)
sem_Exports (list) =
    (foldr (sem_Exports_Cons) (sem_Exports_Nil) ((map sem_Export list)))
sem_Exports_Cons :: (T_Export) ->
                    (T_Exports) ->
                    (T_Exports)
sem_Exports_Cons (_hd) (_tl) =
    let (_self) =
            _hd_self : _tl_self
        ( _hd_cons,_hd_mods,_hd_self,_hd_types,_hd_values) =
            (_hd )
        ( _tl_cons,_tl_mods,_tl_self,_tl_types,_tl_values) =
            (_tl )
    in  (_hd_cons  `unionSet`  _tl_cons,_hd_mods  `unionSet`  _tl_mods,_self,_hd_types  `unionSet`  _tl_types,_hd_values  `unionSet`  _tl_values)
sem_Exports_Nil :: (T_Exports)
sem_Exports_Nil  =
    let (_self) =
            []
    in  (emptySet,emptySet,_self,emptySet,emptySet)
-- Expression --------------------------------------------------
-- semantic domain
type T_Expression = (( Core.Expr ),(Expression))
-- cata
sem_Expression :: (Expression) ->
                  (T_Expression)
sem_Expression ((Expression_Case (_range) (_expression) (_alternatives))) =
    (sem_Expression_Case ((sem_Range (_range))) ((sem_Expression (_expression))) ((sem_Alternatives (_alternatives))))
sem_Expression ((Expression_Comprehension (_range) (_expression) (_qualifiers))) =
    (sem_Expression_Comprehension ((sem_Range (_range))) ((sem_Expression (_expression))) ((sem_Qualifiers (_qualifiers))))
sem_Expression ((Expression_Constructor (_range) (_name))) =
    (sem_Expression_Constructor ((sem_Range (_range))) ((sem_Name (_name))))
sem_Expression ((Expression_Do (_range) (_statements))) =
    (sem_Expression_Do ((sem_Range (_range))) ((sem_Statements (_statements))))
sem_Expression ((Expression_Enum (_range) (_from) (_then) (_to))) =
    (sem_Expression_Enum ((sem_Range (_range))) ((sem_Expression (_from))) ((sem_MaybeExpression (_then))) ((sem_MaybeExpression (_to))))
sem_Expression ((Expression_If (_range) (_guardExpression) (_thenExpression) (_elseExpression))) =
    (sem_Expression_If ((sem_Range (_range))) ((sem_Expression (_guardExpression))) ((sem_Expression (_thenExpression))) ((sem_Expression (_elseExpression))))
sem_Expression ((Expression_InfixApplication (_range) (_leftExpression) (_operator) (_rightExpression))) =
    (sem_Expression_InfixApplication ((sem_Range (_range))) ((sem_MaybeExpression (_leftExpression))) ((sem_Expression (_operator))) ((sem_MaybeExpression (_rightExpression))))
sem_Expression ((Expression_Lambda (_range) (_patterns) (_expression))) =
    (sem_Expression_Lambda ((sem_Range (_range))) ((sem_Patterns (_patterns))) ((sem_Expression (_expression))))
sem_Expression ((Expression_Let (_range) (_declarations) (_expression))) =
    (sem_Expression_Let ((sem_Range (_range))) ((sem_Declarations (_declarations))) ((sem_Expression (_expression))))
sem_Expression ((Expression_List (_range) (_expressions))) =
    (sem_Expression_List ((sem_Range (_range))) ((sem_Expressions (_expressions))))
sem_Expression ((Expression_Literal (_range) (_literal))) =
    (sem_Expression_Literal ((sem_Range (_range))) ((sem_Literal (_literal))))
sem_Expression ((Expression_Negate (_range) (_expression))) =
    (sem_Expression_Negate ((sem_Range (_range))) ((sem_Expression (_expression))))
sem_Expression ((Expression_NegateFloat (_range) (_expression))) =
    (sem_Expression_NegateFloat ((sem_Range (_range))) ((sem_Expression (_expression))))
sem_Expression ((Expression_NormalApplication (_range) (_function) (_arguments))) =
    (sem_Expression_NormalApplication ((sem_Range (_range))) ((sem_Expression (_function))) ((sem_Expressions (_arguments))))
sem_Expression ((Expression_Parenthesized (_range) (_expression))) =
    (sem_Expression_Parenthesized ((sem_Range (_range))) ((sem_Expression (_expression))))
sem_Expression ((Expression_RecordConstruction (_range) (_name) (_recordExpressionBindings))) =
    (sem_Expression_RecordConstruction ((sem_Range (_range))) ((sem_Name (_name))) ((sem_RecordExpressionBindings (_recordExpressionBindings))))
sem_Expression ((Expression_RecordUpdate (_range) (_expression) (_recordExpressionBindings))) =
    (sem_Expression_RecordUpdate ((sem_Range (_range))) ((sem_Expression (_expression))) ((sem_RecordExpressionBindings (_recordExpressionBindings))))
sem_Expression ((Expression_Tuple (_range) (_expressions))) =
    (sem_Expression_Tuple ((sem_Range (_range))) ((sem_Expressions (_expressions))))
sem_Expression ((Expression_Typed (_range) (_expression) (_type))) =
    (sem_Expression_Typed ((sem_Range (_range))) ((sem_Expression (_expression))) ((sem_Type (_type))))
sem_Expression ((Expression_Variable (_range) (_name))) =
    (sem_Expression_Variable ((sem_Range (_range))) ((sem_Name (_name))))
sem_Expression_Case :: (T_Range) ->
                       (T_Expression) ->
                       (T_Alternatives) ->
                       (T_Expression)
sem_Expression_Case (_range) (_expression) (_alternatives) =
    let (_self) =
            Expression_Case _range_self _expression_self _alternatives_self
        ( _range_self) =
            (_range )
        ( _expression_core,_expression_self) =
            (_expression )
        ( _alternatives_core,_alternatives_self) =
            (_alternatives (_range_self))
    in  (let_ caseExprId _expression_core _alternatives_core,_self)
sem_Expression_Comprehension :: (T_Range) ->
                                (T_Expression) ->
                                (T_Qualifiers) ->
                                (T_Expression)
sem_Expression_Comprehension (_range) (_expression) (_qualifiers) =
    let (_self) =
            Expression_Comprehension _range_self _expression_self _qualifiers_self
        ( _range_self) =
            (_range )
        ( _expression_core,_expression_self) =
            (_expression )
        ( _qualifiers_core,_qualifiers_self) =
            (_qualifiers )
    in  (let singleton x = cons x nil
         in foldr ($) (singleton _expression_core) _qualifiers_core
        ,_self
        )
sem_Expression_Constructor :: (T_Range) ->
                              (T_Name) ->
                              (T_Expression)
sem_Expression_Constructor (_range) (_name) =
    let (_self) =
            Expression_Constructor _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
    in  (Core.Con (Core.ConId _name_id),_self)
sem_Expression_Do :: (T_Range) ->
                     (T_Statements) ->
                     (T_Expression)
sem_Expression_Do (_range) (_statements) =
    let (_self) =
            Expression_Do _range_self _statements_self
        ( _range_self) =
            (_range )
        ( _statements_core,_statements_self) =
            (_statements )
    in  (chainCode _statements_core,_self)
sem_Expression_Enum :: (T_Range) ->
                       (T_Expression) ->
                       (T_MaybeExpression) ->
                       (T_MaybeExpression) ->
                       (T_Expression)
sem_Expression_Enum (_range) (_from) (_then) (_to) =
    let (_self) =
            Expression_Enum _range_self _from_self _then_self _to_self
        ( _range_self) =
            (_range )
        ( _from_core,_from_self) =
            (_from )
        ( _then_core,_then_self) =
            (_then )
        ( _to_core,_to_self) =
            (_to )
    in  (case (_then_core, _to_core) of
             (Just then_, Just to) ->
                 var "primEnumFromThenTo" `app_` _from_core `app_` then_ `app_` to
             (Just then_, Nothing) ->
                 var "primEnumFromThen" `app_` _from_core `app_` then_
             (Nothing, Just to) ->
                 var "primEnumFromTo" `app_` _from_core `app_` to
             (Nothing, Nothing) ->
                 var "primEnumFrom" `app_` _from_core
        ,_self
        )
sem_Expression_If :: (T_Range) ->
                     (T_Expression) ->
                     (T_Expression) ->
                     (T_Expression) ->
                     (T_Expression)
sem_Expression_If (_range) (_guardExpression) (_thenExpression) (_elseExpression) =
    let (_self) =
            Expression_If _range_self _guardExpression_self _thenExpression_self _elseExpression_self
        ( _range_self) =
            (_range )
        ( _guardExpression_core,_guardExpression_self) =
            (_guardExpression )
        ( _thenExpression_core,_thenExpression_self) =
            (_thenExpression )
        ( _elseExpression_core,_elseExpression_self) =
            (_elseExpression )
    in  (if_ _guardExpression_core _thenExpression_core _elseExpression_core,_self)
sem_Expression_InfixApplication :: (T_Range) ->
                                   (T_MaybeExpression) ->
                                   (T_Expression) ->
                                   (T_MaybeExpression) ->
                                   (T_Expression)
sem_Expression_InfixApplication (_range) (_leftExpression) (_operator) (_rightExpression) =
    let (_self) =
            Expression_InfixApplication _range_self _leftExpression_self _operator_self _rightExpression_self
        ( _range_self) =
            (_range )
        ( _leftExpression_core,_leftExpression_self) =
            (_leftExpression )
        ( _operator_core,_operator_self) =
            (_operator )
        ( _rightExpression_core,_rightExpression_self) =
            (_rightExpression )
    in  (case (_leftExpression_core, _rightExpression_core) of
             (Nothing, Nothing) -> _operator_core
             (Just l , Nothing) -> Core.Ap _operator_core l
             (Nothing, Just r ) -> Core.Lam parameterId
                                     (foldl Core.Ap _operator_core [Core.Var parameterId, r])
             (Just l , Just r ) -> foldl Core.Ap _operator_core [l,r]
        ,_self
        )
sem_Expression_Lambda :: (T_Range) ->
                         (T_Patterns) ->
                         (T_Expression) ->
                         (T_Expression)
sem_Expression_Lambda (_range) (_patterns) (_expression) =
    let (_self) =
            Expression_Lambda _range_self _patterns_self _expression_self
        ( _range_self) =
            (_range )
        ( _patterns_length,_patterns_self,_patterns_vars) =
            (_patterns )
        ( _expression_core,_expression_self) =
            (_expression )
    in  (let ids = freshIds "u$" _patterns_length
         in let_ nextClauseId (patternMatchFail _range_self)
             (foldr
                 Core.Lam
                 (patternsToCore
                     (zip ids _patterns_self)
                     _expression_core
                 )
                 ids
             )
        ,_self
        )
sem_Expression_Let :: (T_Range) ->
                      (T_Declarations) ->
                      (T_Expression) ->
                      (T_Expression)
sem_Expression_Let (_range) (_declarations) (_expression) =
    let (_importEnv) =
            intErr "CodeGeneration.ag" "Expression.Let" ""
        (_self) =
            Expression_Let _range_self _declarations_self _expression_self
        ( _range_self) =
            (_range )
        ( _declarations_decls,_declarations_patBindNr,_declarations_self) =
            (_declarations (_importEnv) (False) (0))
        ( _expression_core,_expression_self) =
            (_expression )
    in  (letrec_ _declarations_decls _expression_core,_self)
sem_Expression_List :: (T_Range) ->
                       (T_Expressions) ->
                       (T_Expression)
sem_Expression_List (_range) (_expressions) =
    let (_self) =
            Expression_List _range_self _expressions_self
        ( _range_self) =
            (_range )
        ( _expressions_core,_expressions_self) =
            (_expressions )
    in  (coreList _expressions_core,_self)
sem_Expression_Literal :: (T_Range) ->
                          (T_Literal) ->
                          (T_Expression)
sem_Expression_Literal (_range) (_literal) =
    let (_self) =
            Expression_Literal _range_self _literal_self
        ( _range_self) =
            (_range )
        ( _literal_core,_literal_self) =
            (_literal )
    in  (_literal_core,_self)
sem_Expression_Negate :: (T_Range) ->
                         (T_Expression) ->
                         (T_Expression)
sem_Expression_Negate (_range) (_expression) =
    let (_self) =
            Expression_Negate _range_self _expression_self
        ( _range_self) =
            (_range )
        ( _expression_core,_expression_self) =
            (_expression )
    in  (var "primNegInt" `app_` _expression_core,_self)
sem_Expression_NegateFloat :: (T_Range) ->
                              (T_Expression) ->
                              (T_Expression)
sem_Expression_NegateFloat (_range) (_expression) =
    let (_self) =
            Expression_NegateFloat _range_self _expression_self
        ( _range_self) =
            (_range )
        ( _expression_core,_expression_self) =
            (_expression )
    in  (var "primNegFloat" `app_` _expression_core,_self)
sem_Expression_NormalApplication :: (T_Range) ->
                                    (T_Expression) ->
                                    (T_Expressions) ->
                                    (T_Expression)
sem_Expression_NormalApplication (_range) (_function) (_arguments) =
    let (_self) =
            Expression_NormalApplication _range_self _function_self _arguments_self
        ( _range_self) =
            (_range )
        ( _function_core,_function_self) =
            (_function )
        ( _arguments_core,_arguments_self) =
            (_arguments )
    in  (foldl Core.Ap _function_core _arguments_core,_self)
sem_Expression_Parenthesized :: (T_Range) ->
                                (T_Expression) ->
                                (T_Expression)
sem_Expression_Parenthesized (_range) (_expression) =
    let (_self) =
            Expression_Parenthesized _range_self _expression_self
        ( _range_self) =
            (_range )
        ( _expression_core,_expression_self) =
            (_expression )
    in  (_expression_core,_self)
sem_Expression_RecordConstruction :: (T_Range) ->
                                     (T_Name) ->
                                     (T_RecordExpressionBindings) ->
                                     (T_Expression)
sem_Expression_RecordConstruction (_range) (_name) (_recordExpressionBindings) =
    let (_self) =
            Expression_RecordConstruction _range_self _name_self _recordExpressionBindings_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
        ( _recordExpressionBindings_self) =
            (_recordExpressionBindings )
    in  (intErr "Expression" "records not supported",_self)
sem_Expression_RecordUpdate :: (T_Range) ->
                               (T_Expression) ->
                               (T_RecordExpressionBindings) ->
                               (T_Expression)
sem_Expression_RecordUpdate (_range) (_expression) (_recordExpressionBindings) =
    let (_self) =
            Expression_RecordUpdate _range_self _expression_self _recordExpressionBindings_self
        ( _range_self) =
            (_range )
        ( _expression_core,_expression_self) =
            (_expression )
        ( _recordExpressionBindings_self) =
            (_recordExpressionBindings )
    in  (intErr "Expression" "records not supported",_self)
sem_Expression_Tuple :: (T_Range) ->
                        (T_Expressions) ->
                        (T_Expression)
sem_Expression_Tuple (_range) (_expressions) =
    let (_self) =
            Expression_Tuple _range_self _expressions_self
        ( _range_self) =
            (_range )
        ( _expressions_core,_expressions_self) =
            (_expressions )
    in  (foldl
             Core.Ap
             (Core.Con
                 (Core.ConTag
                     (Core.Lit (Core.LitInt 0))
                     (length _expressions_core)
                 )
             )
             _expressions_core
        ,_self
        )
sem_Expression_Typed :: (T_Range) ->
                        (T_Expression) ->
                        (T_Type) ->
                        (T_Expression)
sem_Expression_Typed (_range) (_expression) (_type) =
    let (_self) =
            Expression_Typed _range_self _expression_self _type_self
        ( _range_self) =
            (_range )
        ( _expression_core,_expression_self) =
            (_expression )
        ( _type_self) =
            (_type )
    in  (_expression_core,_self)
sem_Expression_Variable :: (T_Range) ->
                           (T_Name) ->
                           (T_Expression)
sem_Expression_Variable (_range) (_name) =
    let (_self) =
            Expression_Variable _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
    in  (Core.Var _name_id,_self)
-- Expressions -------------------------------------------------
-- semantic domain
type T_Expressions = (( [Core.Expr] ),(Expressions))
-- cata
sem_Expressions :: (Expressions) ->
                   (T_Expressions)
sem_Expressions (list) =
    (foldr (sem_Expressions_Cons) (sem_Expressions_Nil) ((map sem_Expression list)))
sem_Expressions_Cons :: (T_Expression) ->
                        (T_Expressions) ->
                        (T_Expressions)
sem_Expressions_Cons (_hd) (_tl) =
    let (_self) =
            _hd_self : _tl_self
        ( _hd_core,_hd_self) =
            (_hd )
        ( _tl_core,_tl_self) =
            (_tl )
    in  (_hd_core  :  _tl_core,_self)
sem_Expressions_Nil :: (T_Expressions)
sem_Expressions_Nil  =
    let (_self) =
            []
    in  ([],_self)
-- FieldDeclaration --------------------------------------------
-- semantic domain
type T_FieldDeclaration = ((FieldDeclaration))
-- cata
sem_FieldDeclaration :: (FieldDeclaration) ->
                        (T_FieldDeclaration)
sem_FieldDeclaration ((FieldDeclaration_FieldDeclaration (_range) (_names) (_type))) =
    (sem_FieldDeclaration_FieldDeclaration ((sem_Range (_range))) ((sem_Names (_names))) ((sem_AnnotatedType (_type))))
sem_FieldDeclaration_FieldDeclaration :: (T_Range) ->
                                         (T_Names) ->
                                         (T_AnnotatedType) ->
                                         (T_FieldDeclaration)
sem_FieldDeclaration_FieldDeclaration (_range) (_names) (_type) =
    let (_self) =
            FieldDeclaration_FieldDeclaration _range_self _names_self _type_self
        ( _range_self) =
            (_range )
        ( _names_ids,_names_self) =
            (_names )
        ( _type_self) =
            (_type )
    in  (_self)
-- FieldDeclarations -------------------------------------------
-- semantic domain
type T_FieldDeclarations = ((FieldDeclarations))
-- cata
sem_FieldDeclarations :: (FieldDeclarations) ->
                         (T_FieldDeclarations)
sem_FieldDeclarations (list) =
    (foldr (sem_FieldDeclarations_Cons) (sem_FieldDeclarations_Nil) ((map sem_FieldDeclaration list)))
sem_FieldDeclarations_Cons :: (T_FieldDeclaration) ->
                              (T_FieldDeclarations) ->
                              (T_FieldDeclarations)
sem_FieldDeclarations_Cons (_hd) (_tl) =
    let (_self) =
            _hd_self : _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  (_self)
sem_FieldDeclarations_Nil :: (T_FieldDeclarations)
sem_FieldDeclarations_Nil  =
    let (_self) =
            []
    in  (_self)
-- Fixity ------------------------------------------------------
-- semantic domain
type T_Fixity = ((Fixity))
-- cata
sem_Fixity :: (Fixity) ->
              (T_Fixity)
sem_Fixity ((Fixity_Infix (_range))) =
    (sem_Fixity_Infix ((sem_Range (_range))))
sem_Fixity ((Fixity_Infixl (_range))) =
    (sem_Fixity_Infixl ((sem_Range (_range))))
sem_Fixity ((Fixity_Infixr (_range))) =
    (sem_Fixity_Infixr ((sem_Range (_range))))
sem_Fixity_Infix :: (T_Range) ->
                    (T_Fixity)
sem_Fixity_Infix (_range) =
    let (_self) =
            Fixity_Infix _range_self
        ( _range_self) =
            (_range )
    in  (_self)
sem_Fixity_Infixl :: (T_Range) ->
                     (T_Fixity)
sem_Fixity_Infixl (_range) =
    let (_self) =
            Fixity_Infixl _range_self
        ( _range_self) =
            (_range )
    in  (_self)
sem_Fixity_Infixr :: (T_Range) ->
                     (T_Fixity)
sem_Fixity_Infixr (_range) =
    let (_self) =
            Fixity_Infixr _range_self
        ( _range_self) =
            (_range )
    in  (_self)
-- FunctionBinding ---------------------------------------------
-- semantic domain
type T_FunctionBinding = ( [Id] ) ->
                         ((Int),( Core.Expr -> Core.Expr ),(Id),(FunctionBinding))
-- cata
sem_FunctionBinding :: (FunctionBinding) ->
                       (T_FunctionBinding)
sem_FunctionBinding ((FunctionBinding_FunctionBinding (_range) (_lefthandside) (_righthandside))) =
    (sem_FunctionBinding_FunctionBinding ((sem_Range (_range))) ((sem_LeftHandSide (_lefthandside))) ((sem_RightHandSide (_righthandside))))
sem_FunctionBinding_FunctionBinding :: (T_Range) ->
                                       (T_LeftHandSide) ->
                                       (T_RightHandSide) ->
                                       (T_FunctionBinding)
sem_FunctionBinding_FunctionBinding (_range) (_lefthandside) (_righthandside) (_lhs_ids) =
    let (_self) =
            FunctionBinding_FunctionBinding _range_self _lefthandside_self _righthandside_self
        ( _range_self) =
            (_range )
        ( _lefthandside_arity,_lefthandside_id,_lefthandside_patterns,_lefthandside_self) =
            (_lefthandside )
        ( _righthandside_core,_righthandside_isGuarded,_righthandside_self) =
            (_righthandside )
    in  (_lefthandside_arity
        ,\nextClause ->
             let thisClause =
                     patternsToCore
                         (zip _lhs_ids _lefthandside_patterns)
                         _righthandside_core in
             if all patternAlwaysSucceeds _lefthandside_patterns
                &&
                not _righthandside_isGuarded
             then
                 thisClause
             else
                 let_ nextClauseId nextClause thisClause
        ,_lefthandside_id
        ,_self
        )
-- FunctionBindings --------------------------------------------
-- semantic domain
type T_FunctionBindings = ( [Id] ) ->
                          (Range) ->
                          ((Int),(Core.Expr),(Id),(FunctionBindings))
-- cata
sem_FunctionBindings :: (FunctionBindings) ->
                        (T_FunctionBindings)
sem_FunctionBindings (list) =
    (foldr (sem_FunctionBindings_Cons) (sem_FunctionBindings_Nil) ((map sem_FunctionBinding list)))
sem_FunctionBindings_Cons :: (T_FunctionBinding) ->
                             (T_FunctionBindings) ->
                             (T_FunctionBindings)
sem_FunctionBindings_Cons (_hd) (_tl) (_lhs_ids) (_lhs_range) =
    let (_self) =
            _hd_self : _tl_self
        ( _hd_arity,_hd_core,_hd_id,_hd_self) =
            (_hd (_lhs_ids))
        ( _tl_arity,_tl_core,_tl_id,_tl_self) =
            (_tl (_lhs_ids) (_lhs_range))
    in  (_hd_arity,_hd_core _tl_core,_hd_id,_self)
sem_FunctionBindings_Nil :: (T_FunctionBindings)
sem_FunctionBindings_Nil (_lhs_ids) (_lhs_range) =
    let (_self) =
            []
    in  (intErr "FunctionBindings" "empty list of function bindings",patternMatchFail _lhs_range,intErr "FunctionBindings" "empty list of function bindings",_self)
-- GuardedExpression -------------------------------------------
-- semantic domain
type T_GuardedExpression = (( Core.Expr -> Core.Expr ),(GuardedExpression))
-- cata
sem_GuardedExpression :: (GuardedExpression) ->
                         (T_GuardedExpression)
sem_GuardedExpression ((GuardedExpression_GuardedExpression (_range) (_guard) (_expression))) =
    (sem_GuardedExpression_GuardedExpression ((sem_Range (_range))) ((sem_Expression (_guard))) ((sem_Expression (_expression))))
sem_GuardedExpression_GuardedExpression :: (T_Range) ->
                                           (T_Expression) ->
                                           (T_Expression) ->
                                           (T_GuardedExpression)
sem_GuardedExpression_GuardedExpression (_range) (_guard) (_expression) =
    let (_self) =
            GuardedExpression_GuardedExpression _range_self _guard_self _expression_self
        ( _range_self) =
            (_range )
        ( _guard_core,_guard_self) =
            (_guard )
        ( _expression_core,_expression_self) =
            (_expression )
    in  (\fail -> if_ _guard_core _expression_core fail,_self)
-- GuardedExpressions ------------------------------------------
-- semantic domain
type T_GuardedExpressions = (( [Core.Expr -> Core.Expr] ),(GuardedExpressions))
-- cata
sem_GuardedExpressions :: (GuardedExpressions) ->
                          (T_GuardedExpressions)
sem_GuardedExpressions (list) =
    (foldr (sem_GuardedExpressions_Cons) (sem_GuardedExpressions_Nil) ((map sem_GuardedExpression list)))
sem_GuardedExpressions_Cons :: (T_GuardedExpression) ->
                               (T_GuardedExpressions) ->
                               (T_GuardedExpressions)
sem_GuardedExpressions_Cons (_hd) (_tl) =
    let (_self) =
            _hd_self : _tl_self
        ( _hd_core,_hd_self) =
            (_hd )
        ( _tl_core,_tl_self) =
            (_tl )
    in  (_hd_core  :  _tl_core,_self)
sem_GuardedExpressions_Nil :: (T_GuardedExpressions)
sem_GuardedExpressions_Nil  =
    let (_self) =
            []
    in  ([],_self)
-- Import ------------------------------------------------------
-- semantic domain
type T_Import = ((Import))
-- cata
sem_Import :: (Import) ->
              (T_Import)
sem_Import ((Import_TypeOrClass (_range) (_name) (_names))) =
    (sem_Import_TypeOrClass ((sem_Range (_range))) ((sem_Name (_name))) ((sem_MaybeNames (_names))))
sem_Import ((Import_TypeOrClassComplete (_range) (_name))) =
    (sem_Import_TypeOrClassComplete ((sem_Range (_range))) ((sem_Name (_name))))
sem_Import ((Import_Variable (_range) (_name))) =
    (sem_Import_Variable ((sem_Range (_range))) ((sem_Name (_name))))
sem_Import_TypeOrClass :: (T_Range) ->
                          (T_Name) ->
                          (T_MaybeNames) ->
                          (T_Import)
sem_Import_TypeOrClass (_range) (_name) (_names) =
    let (_self) =
            Import_TypeOrClass _range_self _name_self _names_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
        ( _names_ids,_names_self) =
            (_names )
    in  (_self)
sem_Import_TypeOrClassComplete :: (T_Range) ->
                                  (T_Name) ->
                                  (T_Import)
sem_Import_TypeOrClassComplete (_range) (_name) =
    let (_self) =
            Import_TypeOrClassComplete _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
    in  (_self)
sem_Import_Variable :: (T_Range) ->
                       (T_Name) ->
                       (T_Import)
sem_Import_Variable (_range) (_name) =
    let (_self) =
            Import_Variable _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
    in  (_self)
-- ImportDeclaration -------------------------------------------
-- semantic domain
type T_ImportDeclaration = ((ImportDeclaration))
-- cata
sem_ImportDeclaration :: (ImportDeclaration) ->
                         (T_ImportDeclaration)
sem_ImportDeclaration ((ImportDeclaration_Empty (_range))) =
    (sem_ImportDeclaration_Empty ((sem_Range (_range))))
sem_ImportDeclaration ((ImportDeclaration_Import (_range) (_qualified) (_name) (_asname) (_importspecification))) =
    (sem_ImportDeclaration_Import ((sem_Range (_range))) (_qualified) ((sem_Name (_name))) ((sem_MaybeName (_asname))) ((sem_MaybeImportSpecification (_importspecification))))
sem_ImportDeclaration_Empty :: (T_Range) ->
                               (T_ImportDeclaration)
sem_ImportDeclaration_Empty (_range) =
    let (_self) =
            ImportDeclaration_Empty _range_self
        ( _range_self) =
            (_range )
    in  (_self)
sem_ImportDeclaration_Import :: (T_Range) ->
                                (Bool) ->
                                (T_Name) ->
                                (T_MaybeName) ->
                                (T_MaybeImportSpecification) ->
                                (T_ImportDeclaration)
sem_ImportDeclaration_Import (_range) (_qualified) (_name) (_asname) (_importspecification) =
    let (_self) =
            ImportDeclaration_Import _range_self _qualified _name_self _asname_self _importspecification_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
        ( _asname_id,_asname_isNothing,_asname_self) =
            (_asname )
        ( _importspecification_self) =
            (_importspecification )
    in  (_self)
-- ImportDeclarations ------------------------------------------
-- semantic domain
type T_ImportDeclarations = ((ImportDeclarations))
-- cata
sem_ImportDeclarations :: (ImportDeclarations) ->
                          (T_ImportDeclarations)
sem_ImportDeclarations (list) =
    (foldr (sem_ImportDeclarations_Cons) (sem_ImportDeclarations_Nil) ((map sem_ImportDeclaration list)))
sem_ImportDeclarations_Cons :: (T_ImportDeclaration) ->
                               (T_ImportDeclarations) ->
                               (T_ImportDeclarations)
sem_ImportDeclarations_Cons (_hd) (_tl) =
    let (_self) =
            _hd_self : _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  (_self)
sem_ImportDeclarations_Nil :: (T_ImportDeclarations)
sem_ImportDeclarations_Nil  =
    let (_self) =
            []
    in  (_self)
-- ImportSpecification -----------------------------------------
-- semantic domain
type T_ImportSpecification = ((ImportSpecification))
-- cata
sem_ImportSpecification :: (ImportSpecification) ->
                           (T_ImportSpecification)
sem_ImportSpecification ((ImportSpecification_Import (_range) (_hiding) (_imports))) =
    (sem_ImportSpecification_Import ((sem_Range (_range))) (_hiding) ((sem_Imports (_imports))))
sem_ImportSpecification_Import :: (T_Range) ->
                                  (Bool) ->
                                  (T_Imports) ->
                                  (T_ImportSpecification)
sem_ImportSpecification_Import (_range) (_hiding) (_imports) =
    let (_self) =
            ImportSpecification_Import _range_self _hiding _imports_self
        ( _range_self) =
            (_range )
        ( _imports_self) =
            (_imports )
    in  (_self)
-- Imports -----------------------------------------------------
-- semantic domain
type T_Imports = ((Imports))
-- cata
sem_Imports :: (Imports) ->
               (T_Imports)
sem_Imports (list) =
    (foldr (sem_Imports_Cons) (sem_Imports_Nil) ((map sem_Import list)))
sem_Imports_Cons :: (T_Import) ->
                    (T_Imports) ->
                    (T_Imports)
sem_Imports_Cons (_hd) (_tl) =
    let (_self) =
            _hd_self : _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  (_self)
sem_Imports_Nil :: (T_Imports)
sem_Imports_Nil  =
    let (_self) =
            []
    in  (_self)
-- LeftHandSide ------------------------------------------------
-- semantic domain
type T_LeftHandSide = ((Int),(Id),(Patterns),(LeftHandSide))
-- cata
sem_LeftHandSide :: (LeftHandSide) ->
                    (T_LeftHandSide)
sem_LeftHandSide ((LeftHandSide_Function (_range) (_name) (_patterns))) =
    (sem_LeftHandSide_Function ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Patterns (_patterns))))
sem_LeftHandSide ((LeftHandSide_Infix (_range) (_leftPattern) (_operator) (_rightPattern))) =
    (sem_LeftHandSide_Infix ((sem_Range (_range))) ((sem_Pattern (_leftPattern))) ((sem_Name (_operator))) ((sem_Pattern (_rightPattern))))
sem_LeftHandSide ((LeftHandSide_Parenthesized (_range) (_lefthandside) (_patterns))) =
    (sem_LeftHandSide_Parenthesized ((sem_Range (_range))) ((sem_LeftHandSide (_lefthandside))) ((sem_Patterns (_patterns))))
sem_LeftHandSide_Function :: (T_Range) ->
                             (T_Name) ->
                             (T_Patterns) ->
                             (T_LeftHandSide)
sem_LeftHandSide_Function (_range) (_name) (_patterns) =
    let (_self) =
            LeftHandSide_Function _range_self _name_self _patterns_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
        ( _patterns_length,_patterns_self,_patterns_vars) =
            (_patterns )
    in  (_patterns_length,_name_id,_patterns_self,_self)
sem_LeftHandSide_Infix :: (T_Range) ->
                          (T_Pattern) ->
                          (T_Name) ->
                          (T_Pattern) ->
                          (T_LeftHandSide)
sem_LeftHandSide_Infix (_range) (_leftPattern) (_operator) (_rightPattern) =
    let (_self) =
            LeftHandSide_Infix _range_self _leftPattern_self _operator_self _rightPattern_self
        ( _range_self) =
            (_range )
        ( _leftPattern_self,_leftPattern_vars) =
            (_leftPattern )
        ( _operator_id,_operator_self) =
            (_operator )
        ( _rightPattern_self,_rightPattern_vars) =
            (_rightPattern )
    in  (2,_operator_id,[_leftPattern_self, _rightPattern_self ],_self)
sem_LeftHandSide_Parenthesized :: (T_Range) ->
                                  (T_LeftHandSide) ->
                                  (T_Patterns) ->
                                  (T_LeftHandSide)
sem_LeftHandSide_Parenthesized (_range) (_lefthandside) (_patterns) =
    let (_self) =
            LeftHandSide_Parenthesized _range_self _lefthandside_self _patterns_self
        ( _range_self) =
            (_range )
        ( _lefthandside_arity,_lefthandside_id,_lefthandside_patterns,_lefthandside_self) =
            (_lefthandside )
        ( _patterns_length,_patterns_self,_patterns_vars) =
            (_patterns )
    in  (_lefthandside_arity + _patterns_length,_lefthandside_id,_lefthandside_patterns ++ _patterns_self,_self)
-- Literal -----------------------------------------------------
-- semantic domain
type T_Literal = (( Core.Expr ),(Literal))
-- cata
sem_Literal :: (Literal) ->
               (T_Literal)
sem_Literal ((Literal_Char (_range) (_value))) =
    (sem_Literal_Char ((sem_Range (_range))) (_value))
sem_Literal ((Literal_Float (_range) (_value))) =
    (sem_Literal_Float ((sem_Range (_range))) (_value))
sem_Literal ((Literal_Int (_range) (_value))) =
    (sem_Literal_Int ((sem_Range (_range))) (_value))
sem_Literal ((Literal_String (_range) (_value))) =
    (sem_Literal_String ((sem_Range (_range))) (_value))
sem_Literal_Char :: (T_Range) ->
                    (String) ->
                    (T_Literal)
sem_Literal_Char (_range) (_value) =
    let (_self) =
            Literal_Char _range_self _value
        ( _range_self) =
            (_range )
    in  (Core.Lit (Core.LitInt (ord (head _value))),_self)
sem_Literal_Float :: (T_Range) ->
                     (String) ->
                     (T_Literal)
sem_Literal_Float (_range) (_value) =
    let (_self) =
            Literal_Float _range_self _value
        ( _range_self) =
            (_range )
    in  (float _value,_self)
sem_Literal_Int :: (T_Range) ->
                   (String) ->
                   (T_Literal)
sem_Literal_Int (_range) (_value) =
    let (_self) =
            Literal_Int _range_self _value
        ( _range_self) =
            (_range )
    in  (Core.Lit (Core.LitInt (read _value)),_self)
sem_Literal_String :: (T_Range) ->
                      (String) ->
                      (T_Literal)
sem_Literal_String (_range) (_value) =
    let (_self) =
            Literal_String _range_self _value
        ( _range_self) =
            (_range )
    in  (var "primPackedToString" `app_` packedString _value,_self)
-- MaybeDeclarations -------------------------------------------
-- semantic domain
type T_MaybeDeclarations = (( Core.Expr -> Core.Expr ),(MaybeDeclarations))
-- cata
sem_MaybeDeclarations :: (MaybeDeclarations) ->
                         (T_MaybeDeclarations)
sem_MaybeDeclarations ((MaybeDeclarations_Just (_declarations))) =
    (sem_MaybeDeclarations_Just ((sem_Declarations (_declarations))))
sem_MaybeDeclarations ((MaybeDeclarations_Nothing )) =
    (sem_MaybeDeclarations_Nothing )
sem_MaybeDeclarations_Just :: (T_Declarations) ->
                              (T_MaybeDeclarations)
sem_MaybeDeclarations_Just (_declarations) =
    let (_importEnv) =
            intErr "CodeGeneration.ag" "MaybeDeclarations.Just" ""
        (_self) =
            MaybeDeclarations_Just _declarations_self
        ( _declarations_decls,_declarations_patBindNr,_declarations_self) =
            (_declarations (_importEnv) (False) (0))
    in  (\continue -> letrec_ _declarations_decls continue,_self)
sem_MaybeDeclarations_Nothing :: (T_MaybeDeclarations)
sem_MaybeDeclarations_Nothing  =
    let (_self) =
            MaybeDeclarations_Nothing
    in  (\continue -> continue,_self)
-- MaybeExports ------------------------------------------------
-- semantic domain
type T_MaybeExports = ((IdSet),(IdSet),(MaybeExports),(IdSet),(IdSet))
-- cata
sem_MaybeExports :: (MaybeExports) ->
                    (T_MaybeExports)
sem_MaybeExports ((MaybeExports_Just (_exports))) =
    (sem_MaybeExports_Just ((sem_Exports (_exports))))
sem_MaybeExports ((MaybeExports_Nothing )) =
    (sem_MaybeExports_Nothing )
sem_MaybeExports_Just :: (T_Exports) ->
                         (T_MaybeExports)
sem_MaybeExports_Just (_exports) =
    let (_self) =
            MaybeExports_Just _exports_self
        ( _exports_cons,_exports_mods,_exports_self,_exports_types,_exports_values) =
            (_exports )
    in  (_exports_cons,_exports_mods,_self,_exports_types,_exports_values)
sem_MaybeExports_Nothing :: (T_MaybeExports)
sem_MaybeExports_Nothing  =
    let (_self) =
            MaybeExports_Nothing
    in  (emptySet,emptySet,_self,emptySet,emptySet)
-- MaybeExpression ---------------------------------------------
-- semantic domain
type T_MaybeExpression = (( Maybe Core.Expr ),(MaybeExpression))
-- cata
sem_MaybeExpression :: (MaybeExpression) ->
                       (T_MaybeExpression)
sem_MaybeExpression ((MaybeExpression_Just (_expression))) =
    (sem_MaybeExpression_Just ((sem_Expression (_expression))))
sem_MaybeExpression ((MaybeExpression_Nothing )) =
    (sem_MaybeExpression_Nothing )
sem_MaybeExpression_Just :: (T_Expression) ->
                            (T_MaybeExpression)
sem_MaybeExpression_Just (_expression) =
    let (_self) =
            MaybeExpression_Just _expression_self
        ( _expression_core,_expression_self) =
            (_expression )
    in  (Just _expression_core,_self)
sem_MaybeExpression_Nothing :: (T_MaybeExpression)
sem_MaybeExpression_Nothing  =
    let (_self) =
            MaybeExpression_Nothing
    in  (Nothing,_self)
-- MaybeImportSpecification ------------------------------------
-- semantic domain
type T_MaybeImportSpecification = ((MaybeImportSpecification))
-- cata
sem_MaybeImportSpecification :: (MaybeImportSpecification) ->
                                (T_MaybeImportSpecification)
sem_MaybeImportSpecification ((MaybeImportSpecification_Just (_importspecification))) =
    (sem_MaybeImportSpecification_Just ((sem_ImportSpecification (_importspecification))))
sem_MaybeImportSpecification ((MaybeImportSpecification_Nothing )) =
    (sem_MaybeImportSpecification_Nothing )
sem_MaybeImportSpecification_Just :: (T_ImportSpecification) ->
                                     (T_MaybeImportSpecification)
sem_MaybeImportSpecification_Just (_importspecification) =
    let (_self) =
            MaybeImportSpecification_Just _importspecification_self
        ( _importspecification_self) =
            (_importspecification )
    in  (_self)
sem_MaybeImportSpecification_Nothing :: (T_MaybeImportSpecification)
sem_MaybeImportSpecification_Nothing  =
    let (_self) =
            MaybeImportSpecification_Nothing
    in  (_self)
-- MaybeInt ----------------------------------------------------
-- semantic domain
type T_MaybeInt = ((MaybeInt))
-- cata
sem_MaybeInt :: (MaybeInt) ->
                (T_MaybeInt)
sem_MaybeInt ((MaybeInt_Just (_int))) =
    (sem_MaybeInt_Just (_int))
sem_MaybeInt ((MaybeInt_Nothing )) =
    (sem_MaybeInt_Nothing )
sem_MaybeInt_Just :: (Int) ->
                     (T_MaybeInt)
sem_MaybeInt_Just (_int) =
    let (_self) =
            MaybeInt_Just _int
    in  (_self)
sem_MaybeInt_Nothing :: (T_MaybeInt)
sem_MaybeInt_Nothing  =
    let (_self) =
            MaybeInt_Nothing
    in  (_self)
-- MaybeName ---------------------------------------------------
-- semantic domain
type T_MaybeName = (( Maybe Id ),(Bool),(MaybeName))
-- cata
sem_MaybeName :: (MaybeName) ->
                 (T_MaybeName)
sem_MaybeName ((MaybeName_Just (_name))) =
    (sem_MaybeName_Just ((sem_Name (_name))))
sem_MaybeName ((MaybeName_Nothing )) =
    (sem_MaybeName_Nothing )
sem_MaybeName_Just :: (T_Name) ->
                      (T_MaybeName)
sem_MaybeName_Just (_name) =
    let (_self) =
            MaybeName_Just _name_self
        ( _name_id,_name_self) =
            (_name )
    in  (Just _name_id,False,_self)
sem_MaybeName_Nothing :: (T_MaybeName)
sem_MaybeName_Nothing  =
    let (_self) =
            MaybeName_Nothing
    in  (Nothing,True,_self)
-- MaybeNames --------------------------------------------------
-- semantic domain
type T_MaybeNames = (( Maybe [Id] ),(MaybeNames))
-- cata
sem_MaybeNames :: (MaybeNames) ->
                  (T_MaybeNames)
sem_MaybeNames ((MaybeNames_Just (_names))) =
    (sem_MaybeNames_Just ((sem_Names (_names))))
sem_MaybeNames ((MaybeNames_Nothing )) =
    (sem_MaybeNames_Nothing )
sem_MaybeNames_Just :: (T_Names) ->
                       (T_MaybeNames)
sem_MaybeNames_Just (_names) =
    let (_self) =
            MaybeNames_Just _names_self
        ( _names_ids,_names_self) =
            (_names )
    in  (Just _names_ids,_self)
sem_MaybeNames_Nothing :: (T_MaybeNames)
sem_MaybeNames_Nothing  =
    let (_self) =
            MaybeNames_Nothing
    in  (Nothing,_self)
-- Module ------------------------------------------------------
-- semantic domain
type T_Module = (ImportEnvironment) ->
                ( [Core.CoreDecl] ) ->
                (( Core.CoreModule ))
-- cata
sem_Module :: (Module) ->
              (T_Module)
sem_Module ((Module_Module (_range) (_name) (_exports) (_body))) =
    (sem_Module_Module ((sem_Range (_range))) ((sem_MaybeName (_name))) ((sem_MaybeExports (_exports))) ((sem_Body (_body))))
sem_Module_Module :: (T_Range) ->
                     (T_MaybeName) ->
                     (T_MaybeExports) ->
                     (T_Body) ->
                     (T_Module)
sem_Module_Module (_range) (_name) (_exports) (_body) (_lhs_importEnv) (_lhs_indirectionDecls) =
    let (_self) =
            Module_Module _range_self _name_self _exports_self _body_self
        (_module_) =
            CoreParse.modulePublic
                ( case _exports_self of
                    MaybeExports_Nothing -> True
                    _                    -> False
                )
                ( _exports_values
                , _exports_cons
                , _exports_types
                , emptySet
                , _exports_mods
                )
                (makeCoreModule _name_id
                    ( _body_decls ++ _lhs_indirectionDecls
                    ))
        ( _range_self) =
            (_range )
        ( _name_id,_name_isNothing,_name_self) =
            (_name )
        ( _exports_cons,_exports_mods,_exports_self,_exports_types,_exports_values) =
            (_exports )
        ( _body_decls,_body_self) =
            (_body (_lhs_importEnv))
    in  (_module_ { Module.moduleDecls =
              insertedMain _lhs_importEnv : Module.moduleDecls _module_ }
        )
-- Name --------------------------------------------------------
-- semantic domain
type T_Name = ((Id),(Name))
-- cata
sem_Name :: (Name) ->
            (T_Name)
sem_Name ((Name_Identifier (_range) (_module) (_name))) =
    (sem_Name_Identifier ((sem_Range (_range))) ((sem_Strings (_module))) (_name))
sem_Name ((Name_Operator (_range) (_module) (_name))) =
    (sem_Name_Operator ((sem_Range (_range))) ((sem_Strings (_module))) (_name))
sem_Name ((Name_Special (_range) (_module) (_name))) =
    (sem_Name_Special ((sem_Range (_range))) ((sem_Strings (_module))) (_name))
sem_Name_Identifier :: (T_Range) ->
                       (T_Strings) ->
                       (String) ->
                       (T_Name)
sem_Name_Identifier (_range) (_module) (_name) =
    let (_self) =
            Name_Identifier _range_self _module_self _name
        ( _range_self) =
            (_range )
        ( _module_self) =
            (_module )
    in  (idFromString _name,_self)
sem_Name_Operator :: (T_Range) ->
                     (T_Strings) ->
                     (String) ->
                     (T_Name)
sem_Name_Operator (_range) (_module) (_name) =
    let (_self) =
            Name_Operator _range_self _module_self _name
        ( _range_self) =
            (_range )
        ( _module_self) =
            (_module )
    in  (idFromString _name,_self)
sem_Name_Special :: (T_Range) ->
                    (T_Strings) ->
                    (String) ->
                    (T_Name)
sem_Name_Special (_range) (_module) (_name) =
    let (_self) =
            Name_Special _range_self _module_self _name
        ( _range_self) =
            (_range )
        ( _module_self) =
            (_module )
    in  (idFromString _name,_self)
-- Names -------------------------------------------------------
-- semantic domain
type T_Names = (([Id]),(Names))
-- cata
sem_Names :: (Names) ->
             (T_Names)
sem_Names (list) =
    (foldr (sem_Names_Cons) (sem_Names_Nil) ((map sem_Name list)))
sem_Names_Cons :: (T_Name) ->
                  (T_Names) ->
                  (T_Names)
sem_Names_Cons (_hd) (_tl) =
    let (_self) =
            _hd_self : _tl_self
        ( _hd_id,_hd_self) =
            (_hd )
        ( _tl_ids,_tl_self) =
            (_tl )
    in  (_hd_id : _tl_ids,_self)
sem_Names_Nil :: (T_Names)
sem_Names_Nil  =
    let (_self) =
            []
    in  ([],_self)
-- Pattern -----------------------------------------------------
-- semantic domain
type T_Pattern = ((Pattern),( [Id] ))
-- cata
sem_Pattern :: (Pattern) ->
               (T_Pattern)
sem_Pattern ((Pattern_As (_range) (_name) (_pattern))) =
    (sem_Pattern_As ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Pattern (_pattern))))
sem_Pattern ((Pattern_Constructor (_range) (_name) (_patterns))) =
    (sem_Pattern_Constructor ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Patterns (_patterns))))
sem_Pattern ((Pattern_InfixConstructor (_range) (_leftPattern) (_constructorOperator) (_rightPattern))) =
    (sem_Pattern_InfixConstructor ((sem_Range (_range))) ((sem_Pattern (_leftPattern))) ((sem_Name (_constructorOperator))) ((sem_Pattern (_rightPattern))))
sem_Pattern ((Pattern_Irrefutable (_range) (_pattern))) =
    (sem_Pattern_Irrefutable ((sem_Range (_range))) ((sem_Pattern (_pattern))))
sem_Pattern ((Pattern_List (_range) (_patterns))) =
    (sem_Pattern_List ((sem_Range (_range))) ((sem_Patterns (_patterns))))
sem_Pattern ((Pattern_Literal (_range) (_literal))) =
    (sem_Pattern_Literal ((sem_Range (_range))) ((sem_Literal (_literal))))
sem_Pattern ((Pattern_Negate (_range) (_literal))) =
    (sem_Pattern_Negate ((sem_Range (_range))) ((sem_Literal (_literal))))
sem_Pattern ((Pattern_NegateFloat (_range) (_literal))) =
    (sem_Pattern_NegateFloat ((sem_Range (_range))) ((sem_Literal (_literal))))
sem_Pattern ((Pattern_Parenthesized (_range) (_pattern))) =
    (sem_Pattern_Parenthesized ((sem_Range (_range))) ((sem_Pattern (_pattern))))
sem_Pattern ((Pattern_Record (_range) (_name) (_recordPatternBindings))) =
    (sem_Pattern_Record ((sem_Range (_range))) ((sem_Name (_name))) ((sem_RecordPatternBindings (_recordPatternBindings))))
sem_Pattern ((Pattern_Successor (_range) (_name) (_literal))) =
    (sem_Pattern_Successor ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Literal (_literal))))
sem_Pattern ((Pattern_Tuple (_range) (_patterns))) =
    (sem_Pattern_Tuple ((sem_Range (_range))) ((sem_Patterns (_patterns))))
sem_Pattern ((Pattern_Variable (_range) (_name))) =
    (sem_Pattern_Variable ((sem_Range (_range))) ((sem_Name (_name))))
sem_Pattern ((Pattern_Wildcard (_range))) =
    (sem_Pattern_Wildcard ((sem_Range (_range))))
sem_Pattern_As :: (T_Range) ->
                  (T_Name) ->
                  (T_Pattern) ->
                  (T_Pattern)
sem_Pattern_As (_range) (_name) (_pattern) =
    let (_self) =
            Pattern_As _range_self _name_self _pattern_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
        ( _pattern_self,_pattern_vars) =
            (_pattern )
    in  (_self,_name_id : _pattern_vars)
sem_Pattern_Constructor :: (T_Range) ->
                           (T_Name) ->
                           (T_Patterns) ->
                           (T_Pattern)
sem_Pattern_Constructor (_range) (_name) (_patterns) =
    let (_self) =
            Pattern_Constructor _range_self _name_self _patterns_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
        ( _patterns_length,_patterns_self,_patterns_vars) =
            (_patterns )
    in  (_self,_patterns_vars)
sem_Pattern_InfixConstructor :: (T_Range) ->
                                (T_Pattern) ->
                                (T_Name) ->
                                (T_Pattern) ->
                                (T_Pattern)
sem_Pattern_InfixConstructor (_range) (_leftPattern) (_constructorOperator) (_rightPattern) =
    let (_self) =
            Pattern_InfixConstructor _range_self _leftPattern_self _constructorOperator_self _rightPattern_self
        ( _range_self) =
            (_range )
        ( _leftPattern_self,_leftPattern_vars) =
            (_leftPattern )
        ( _constructorOperator_id,_constructorOperator_self) =
            (_constructorOperator )
        ( _rightPattern_self,_rightPattern_vars) =
            (_rightPattern )
    in  (_self,_leftPattern_vars  ++  _rightPattern_vars)
sem_Pattern_Irrefutable :: (T_Range) ->
                           (T_Pattern) ->
                           (T_Pattern)
sem_Pattern_Irrefutable (_range) (_pattern) =
    let (_self) =
            Pattern_Irrefutable _range_self _pattern_self
        ( _range_self) =
            (_range )
        ( _pattern_self,_pattern_vars) =
            (_pattern )
    in  (_self,_pattern_vars)
sem_Pattern_List :: (T_Range) ->
                    (T_Patterns) ->
                    (T_Pattern)
sem_Pattern_List (_range) (_patterns) =
    let (_self) =
            Pattern_List _range_self _patterns_self
        ( _range_self) =
            (_range )
        ( _patterns_length,_patterns_self,_patterns_vars) =
            (_patterns )
    in  (_self,_patterns_vars)
sem_Pattern_Literal :: (T_Range) ->
                       (T_Literal) ->
                       (T_Pattern)
sem_Pattern_Literal (_range) (_literal) =
    let (_self) =
            Pattern_Literal _range_self _literal_self
        ( _range_self) =
            (_range )
        ( _literal_core,_literal_self) =
            (_literal )
    in  (_self,[])
sem_Pattern_Negate :: (T_Range) ->
                      (T_Literal) ->
                      (T_Pattern)
sem_Pattern_Negate (_range) (_literal) =
    let (_self) =
            Pattern_Negate _range_self _literal_self
        ( _range_self) =
            (_range )
        ( _literal_core,_literal_self) =
            (_literal )
    in  (_self,[])
sem_Pattern_NegateFloat :: (T_Range) ->
                           (T_Literal) ->
                           (T_Pattern)
sem_Pattern_NegateFloat (_range) (_literal) =
    let (_self) =
            Pattern_NegateFloat _range_self _literal_self
        ( _range_self) =
            (_range )
        ( _literal_core,_literal_self) =
            (_literal )
    in  (_self,[])
sem_Pattern_Parenthesized :: (T_Range) ->
                             (T_Pattern) ->
                             (T_Pattern)
sem_Pattern_Parenthesized (_range) (_pattern) =
    let (_self) =
            Pattern_Parenthesized _range_self _pattern_self
        ( _range_self) =
            (_range )
        ( _pattern_self,_pattern_vars) =
            (_pattern )
    in  (_self,_pattern_vars)
sem_Pattern_Record :: (T_Range) ->
                      (T_Name) ->
                      (T_RecordPatternBindings) ->
                      (T_Pattern)
sem_Pattern_Record (_range) (_name) (_recordPatternBindings) =
    let (_self) =
            Pattern_Record _range_self _name_self _recordPatternBindings_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
        ( _recordPatternBindings_self) =
            (_recordPatternBindings )
    in  (_self,[])
sem_Pattern_Successor :: (T_Range) ->
                         (T_Name) ->
                         (T_Literal) ->
                         (T_Pattern)
sem_Pattern_Successor (_range) (_name) (_literal) =
    let (_self) =
            Pattern_Successor _range_self _name_self _literal_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
        ( _literal_core,_literal_self) =
            (_literal )
    in  (_self,[])
sem_Pattern_Tuple :: (T_Range) ->
                     (T_Patterns) ->
                     (T_Pattern)
sem_Pattern_Tuple (_range) (_patterns) =
    let (_self) =
            Pattern_Tuple _range_self _patterns_self
        ( _range_self) =
            (_range )
        ( _patterns_length,_patterns_self,_patterns_vars) =
            (_patterns )
    in  (_self,_patterns_vars)
sem_Pattern_Variable :: (T_Range) ->
                        (T_Name) ->
                        (T_Pattern)
sem_Pattern_Variable (_range) (_name) =
    let (_self) =
            Pattern_Variable _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
    in  (_self,[ _name_id ])
sem_Pattern_Wildcard :: (T_Range) ->
                        (T_Pattern)
sem_Pattern_Wildcard (_range) =
    let (_self) =
            Pattern_Wildcard _range_self
        ( _range_self) =
            (_range )
    in  (_self,[])
-- Patterns ----------------------------------------------------
-- semantic domain
type T_Patterns = ((Int),(Patterns),( [Id] ))
-- cata
sem_Patterns :: (Patterns) ->
                (T_Patterns)
sem_Patterns (list) =
    (foldr (sem_Patterns_Cons) (sem_Patterns_Nil) ((map sem_Pattern list)))
sem_Patterns_Cons :: (T_Pattern) ->
                     (T_Patterns) ->
                     (T_Patterns)
sem_Patterns_Cons (_hd) (_tl) =
    let (_self) =
            _hd_self : _tl_self
        ( _hd_self,_hd_vars) =
            (_hd )
        ( _tl_length,_tl_self,_tl_vars) =
            (_tl )
    in  (1 + _tl_length,_self,_hd_vars  ++  _tl_vars)
sem_Patterns_Nil :: (T_Patterns)
sem_Patterns_Nil  =
    let (_self) =
            []
    in  (0,_self,[])
-- Position ----------------------------------------------------
-- semantic domain
type T_Position = ((Position))
-- cata
sem_Position :: (Position) ->
                (T_Position)
sem_Position ((Position_Position (_filename) (_line) (_column))) =
    (sem_Position_Position (_filename) (_line) (_column))
sem_Position ((Position_Unknown )) =
    (sem_Position_Unknown )
sem_Position_Position :: (String) ->
                         (Int) ->
                         (Int) ->
                         (T_Position)
sem_Position_Position (_filename) (_line) (_column) =
    let (_self) =
            Position_Position _filename _line _column
    in  (_self)
sem_Position_Unknown :: (T_Position)
sem_Position_Unknown  =
    let (_self) =
            Position_Unknown
    in  (_self)
-- Qualifier ---------------------------------------------------
-- semantic domain
type T_Qualifier = (( Core.Expr -> Core.Expr ),(Qualifier))
-- cata
sem_Qualifier :: (Qualifier) ->
                 (T_Qualifier)
sem_Qualifier ((Qualifier_Empty (_range))) =
    (sem_Qualifier_Empty ((sem_Range (_range))))
sem_Qualifier ((Qualifier_Generator (_range) (_pattern) (_expression))) =
    (sem_Qualifier_Generator ((sem_Range (_range))) ((sem_Pattern (_pattern))) ((sem_Expression (_expression))))
sem_Qualifier ((Qualifier_Guard (_range) (_guard))) =
    (sem_Qualifier_Guard ((sem_Range (_range))) ((sem_Expression (_guard))))
sem_Qualifier ((Qualifier_Let (_range) (_declarations))) =
    (sem_Qualifier_Let ((sem_Range (_range))) ((sem_Declarations (_declarations))))
sem_Qualifier_Empty :: (T_Range) ->
                       (T_Qualifier)
sem_Qualifier_Empty (_range) =
    let (_self) =
            Qualifier_Empty _range_self
        ( _range_self) =
            (_range )
    in  (intErr "Qualifier" "empty qualifiers not supported",_self)
sem_Qualifier_Generator :: (T_Range) ->
                           (T_Pattern) ->
                           (T_Expression) ->
                           (T_Qualifier)
sem_Qualifier_Generator (_range) (_pattern) (_expression) =
    let (_self) =
            Qualifier_Generator _range_self _pattern_self _expression_self
        ( _range_self) =
            (_range )
        ( _pattern_self,_pattern_vars) =
            (_pattern )
        ( _expression_core,_expression_self) =
            (_expression )
    in  (\continue ->
             let_ nextClauseId nil
                 (let_
                     okId
                     (Core.Lam parameterId
                         (patternToCore (parameterId, _pattern_self) continue)
                     )
                     (var "primConcatMap"
                         `app_` Core.Var okId
                         `app_` _expression_core
                     )
                 )
        ,_self
        )
sem_Qualifier_Guard :: (T_Range) ->
                       (T_Expression) ->
                       (T_Qualifier)
sem_Qualifier_Guard (_range) (_guard) =
    let (_self) =
            Qualifier_Guard _range_self _guard_self
        ( _range_self) =
            (_range )
        ( _guard_core,_guard_self) =
            (_guard )
    in  (\continue -> if_ _guard_core continue nil,_self)
sem_Qualifier_Let :: (T_Range) ->
                     (T_Declarations) ->
                     (T_Qualifier)
sem_Qualifier_Let (_range) (_declarations) =
    let (_importEnv) =
            intErr "CodeGeneration.ag" "Qualifier.Let" ""
        (_self) =
            Qualifier_Let _range_self _declarations_self
        ( _range_self) =
            (_range )
        ( _declarations_decls,_declarations_patBindNr,_declarations_self) =
            (_declarations (_importEnv) (False) (0))
    in  (\continue -> letrec_ _declarations_decls continue,_self)
-- Qualifiers --------------------------------------------------
-- semantic domain
type T_Qualifiers = (( [Core.Expr -> Core.Expr] ),(Qualifiers))
-- cata
sem_Qualifiers :: (Qualifiers) ->
                  (T_Qualifiers)
sem_Qualifiers (list) =
    (foldr (sem_Qualifiers_Cons) (sem_Qualifiers_Nil) ((map sem_Qualifier list)))
sem_Qualifiers_Cons :: (T_Qualifier) ->
                       (T_Qualifiers) ->
                       (T_Qualifiers)
sem_Qualifiers_Cons (_hd) (_tl) =
    let (_self) =
            _hd_self : _tl_self
        ( _hd_core,_hd_self) =
            (_hd )
        ( _tl_core,_tl_self) =
            (_tl )
    in  (_hd_core  :  _tl_core,_self)
sem_Qualifiers_Nil :: (T_Qualifiers)
sem_Qualifiers_Nil  =
    let (_self) =
            []
    in  ([],_self)
-- Range -------------------------------------------------------
-- semantic domain
type T_Range = ((Range))
-- cata
sem_Range :: (Range) ->
             (T_Range)
sem_Range ((Range_Range (_start) (_stop))) =
    (sem_Range_Range ((sem_Position (_start))) ((sem_Position (_stop))))
sem_Range_Range :: (T_Position) ->
                   (T_Position) ->
                   (T_Range)
sem_Range_Range (_start) (_stop) =
    let (_self) =
            Range_Range _start_self _stop_self
        ( _start_self) =
            (_start )
        ( _stop_self) =
            (_stop )
    in  (_self)
-- RecordExpressionBinding -------------------------------------
-- semantic domain
type T_RecordExpressionBinding = ((RecordExpressionBinding))
-- cata
sem_RecordExpressionBinding :: (RecordExpressionBinding) ->
                               (T_RecordExpressionBinding)
sem_RecordExpressionBinding ((RecordExpressionBinding_RecordExpressionBinding (_range) (_name) (_expression))) =
    (sem_RecordExpressionBinding_RecordExpressionBinding ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Expression (_expression))))
sem_RecordExpressionBinding_RecordExpressionBinding :: (T_Range) ->
                                                       (T_Name) ->
                                                       (T_Expression) ->
                                                       (T_RecordExpressionBinding)
sem_RecordExpressionBinding_RecordExpressionBinding (_range) (_name) (_expression) =
    let (_self) =
            RecordExpressionBinding_RecordExpressionBinding _range_self _name_self _expression_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
        ( _expression_core,_expression_self) =
            (_expression )
    in  (_self)
-- RecordExpressionBindings ------------------------------------
-- semantic domain
type T_RecordExpressionBindings = ((RecordExpressionBindings))
-- cata
sem_RecordExpressionBindings :: (RecordExpressionBindings) ->
                                (T_RecordExpressionBindings)
sem_RecordExpressionBindings (list) =
    (foldr (sem_RecordExpressionBindings_Cons) (sem_RecordExpressionBindings_Nil) ((map sem_RecordExpressionBinding list)))
sem_RecordExpressionBindings_Cons :: (T_RecordExpressionBinding) ->
                                     (T_RecordExpressionBindings) ->
                                     (T_RecordExpressionBindings)
sem_RecordExpressionBindings_Cons (_hd) (_tl) =
    let (_self) =
            _hd_self : _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  (_self)
sem_RecordExpressionBindings_Nil :: (T_RecordExpressionBindings)
sem_RecordExpressionBindings_Nil  =
    let (_self) =
            []
    in  (_self)
-- RecordPatternBinding ----------------------------------------
-- semantic domain
type T_RecordPatternBinding = ((RecordPatternBinding))
-- cata
sem_RecordPatternBinding :: (RecordPatternBinding) ->
                            (T_RecordPatternBinding)
sem_RecordPatternBinding ((RecordPatternBinding_RecordPatternBinding (_range) (_name) (_pattern))) =
    (sem_RecordPatternBinding_RecordPatternBinding ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Pattern (_pattern))))
sem_RecordPatternBinding_RecordPatternBinding :: (T_Range) ->
                                                 (T_Name) ->
                                                 (T_Pattern) ->
                                                 (T_RecordPatternBinding)
sem_RecordPatternBinding_RecordPatternBinding (_range) (_name) (_pattern) =
    let (_self) =
            RecordPatternBinding_RecordPatternBinding _range_self _name_self _pattern_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
        ( _pattern_self,_pattern_vars) =
            (_pattern )
    in  (_self)
-- RecordPatternBindings ---------------------------------------
-- semantic domain
type T_RecordPatternBindings = ((RecordPatternBindings))
-- cata
sem_RecordPatternBindings :: (RecordPatternBindings) ->
                             (T_RecordPatternBindings)
sem_RecordPatternBindings (list) =
    (foldr (sem_RecordPatternBindings_Cons) (sem_RecordPatternBindings_Nil) ((map sem_RecordPatternBinding list)))
sem_RecordPatternBindings_Cons :: (T_RecordPatternBinding) ->
                                  (T_RecordPatternBindings) ->
                                  (T_RecordPatternBindings)
sem_RecordPatternBindings_Cons (_hd) (_tl) =
    let (_self) =
            _hd_self : _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  (_self)
sem_RecordPatternBindings_Nil :: (T_RecordPatternBindings)
sem_RecordPatternBindings_Nil  =
    let (_self) =
            []
    in  (_self)
-- RightHandSide -----------------------------------------------
-- semantic domain
type T_RightHandSide = (( Core.Expr ),(Bool),(RightHandSide))
-- cata
sem_RightHandSide :: (RightHandSide) ->
                     (T_RightHandSide)
sem_RightHandSide ((RightHandSide_Expression (_range) (_expression) (_where))) =
    (sem_RightHandSide_Expression ((sem_Range (_range))) ((sem_Expression (_expression))) ((sem_MaybeDeclarations (_where))))
sem_RightHandSide ((RightHandSide_Guarded (_range) (_guardedexpressions) (_where))) =
    (sem_RightHandSide_Guarded ((sem_Range (_range))) ((sem_GuardedExpressions (_guardedexpressions))) ((sem_MaybeDeclarations (_where))))
sem_RightHandSide_Expression :: (T_Range) ->
                                (T_Expression) ->
                                (T_MaybeDeclarations) ->
                                (T_RightHandSide)
sem_RightHandSide_Expression (_range) (_expression) (_where) =
    let (_self) =
            RightHandSide_Expression _range_self _expression_self _where_self
        ( _range_self) =
            (_range )
        ( _expression_core,_expression_self) =
            (_expression )
        ( _where_core,_where_self) =
            (_where )
    in  (_where_core _expression_core,False,_self)
sem_RightHandSide_Guarded :: (T_Range) ->
                             (T_GuardedExpressions) ->
                             (T_MaybeDeclarations) ->
                             (T_RightHandSide)
sem_RightHandSide_Guarded (_range) (_guardedexpressions) (_where) =
    let (_self) =
            RightHandSide_Guarded _range_self _guardedexpressions_self _where_self
        ( _range_self) =
            (_range )
        ( _guardedexpressions_core,_guardedexpressions_self) =
            (_guardedexpressions )
        ( _where_core,_where_self) =
            (_where )
    in  (_where_core (foldr ($) (Core.Var nextClauseId) _guardedexpressions_core),True,_self)
-- SimpleType --------------------------------------------------
-- semantic domain
type T_SimpleType = ((Name),(SimpleType),(Names))
-- cata
sem_SimpleType :: (SimpleType) ->
                  (T_SimpleType)
sem_SimpleType ((SimpleType_SimpleType (_range) (_name) (_typevariables))) =
    (sem_SimpleType_SimpleType ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Names (_typevariables))))
sem_SimpleType_SimpleType :: (T_Range) ->
                             (T_Name) ->
                             (T_Names) ->
                             (T_SimpleType)
sem_SimpleType_SimpleType (_range) (_name) (_typevariables) =
    let (_self) =
            SimpleType_SimpleType _range_self _name_self _typevariables_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
        ( _typevariables_ids,_typevariables_self) =
            (_typevariables )
    in  (_name_self,_self,_typevariables_self)
-- Statement ---------------------------------------------------
-- semantic domain
type T_Statement = (( Maybe Core.Expr -> Core.Expr ),(Statement))
-- cata
sem_Statement :: (Statement) ->
                 (T_Statement)
sem_Statement ((Statement_Empty (_range))) =
    (sem_Statement_Empty ((sem_Range (_range))))
sem_Statement ((Statement_Expression (_range) (_expression))) =
    (sem_Statement_Expression ((sem_Range (_range))) ((sem_Expression (_expression))))
sem_Statement ((Statement_Generator (_range) (_pattern) (_expression))) =
    (sem_Statement_Generator ((sem_Range (_range))) ((sem_Pattern (_pattern))) ((sem_Expression (_expression))))
sem_Statement ((Statement_Let (_range) (_declarations))) =
    (sem_Statement_Let ((sem_Range (_range))) ((sem_Declarations (_declarations))))
sem_Statement_Empty :: (T_Range) ->
                       (T_Statement)
sem_Statement_Empty (_range) =
    let (_self) =
            Statement_Empty _range_self
        ( _range_self) =
            (_range )
    in  (\rest ->
             case rest of
                 Nothing   -> intErr "Statement" "empty statements not supported"
                 Just rest -> rest
        ,_self
        )
sem_Statement_Expression :: (T_Range) ->
                            (T_Expression) ->
                            (T_Statement)
sem_Statement_Expression (_range) (_expression) =
    let (_self) =
            Statement_Expression _range_self _expression_self
        ( _range_self) =
            (_range )
        ( _expression_core,_expression_self) =
            (_expression )
    in  (\rest ->
             case rest of
                 Nothing   -> _expression_core
                 Just rest -> bind _expression_core (Core.Lam dummyId rest)
        ,_self
        )
sem_Statement_Generator :: (T_Range) ->
                           (T_Pattern) ->
                           (T_Expression) ->
                           (T_Statement)
sem_Statement_Generator (_range) (_pattern) (_expression) =
    let (_self) =
            Statement_Generator _range_self _pattern_self _expression_self
        ( _range_self) =
            (_range )
        ( _pattern_self,_pattern_vars) =
            (_pattern )
        ( _expression_core,_expression_self) =
            (_expression )
    in  (\rest -> case rest of
             Nothing   -> intErr "Statement" "generator can't be last in 'do'"
             Just rest ->
                 let_ nextClauseId (patternMatchFail _range_self)
                     (let_
                         okId
                         (Core.Lam parameterId
                             (patternToCore (parameterId, _pattern_self) rest)
                         )
                         (_expression_core `bind` Core.Var okId)
                     )
        ,_self
        )
sem_Statement_Let :: (T_Range) ->
                     (T_Declarations) ->
                     (T_Statement)
sem_Statement_Let (_range) (_declarations) =
    let (_importEnv) =
            intErr "CodeGeneration.ag" "Statement.Let" ""
        (_self) =
            Statement_Let _range_self _declarations_self
        ( _range_self) =
            (_range )
        ( _declarations_decls,_declarations_patBindNr,_declarations_self) =
            (_declarations (_importEnv) (False) (0))
    in  (\rest ->
             case rest of
                 Nothing   -> intErr "Statement" "'let' can't be last in 'do'"
                 Just rest -> letrec_ _declarations_decls rest
        ,_self
        )
-- Statements --------------------------------------------------
-- semantic domain
type T_Statements = (( [Maybe Core.Expr -> Core.Expr] ),(Statements))
-- cata
sem_Statements :: (Statements) ->
                  (T_Statements)
sem_Statements (list) =
    (foldr (sem_Statements_Cons) (sem_Statements_Nil) ((map sem_Statement list)))
sem_Statements_Cons :: (T_Statement) ->
                       (T_Statements) ->
                       (T_Statements)
sem_Statements_Cons (_hd) (_tl) =
    let (_self) =
            _hd_self : _tl_self
        ( _hd_core,_hd_self) =
            (_hd )
        ( _tl_core,_tl_self) =
            (_tl )
    in  (_hd_core  :  _tl_core,_self)
sem_Statements_Nil :: (T_Statements)
sem_Statements_Nil  =
    let (_self) =
            []
    in  ([],_self)
-- Strings -----------------------------------------------------
-- semantic domain
type T_Strings = ((Strings))
-- cata
sem_Strings :: (Strings) ->
               (T_Strings)
sem_Strings (list) =
    (foldr (sem_Strings_Cons) (sem_Strings_Nil) (list))
sem_Strings_Cons :: (String) ->
                    (T_Strings) ->
                    (T_Strings)
sem_Strings_Cons (_hd) (_tl) =
    let (_self) =
            _hd : _tl_self
        ( _tl_self) =
            (_tl )
    in  (_self)
sem_Strings_Nil :: (T_Strings)
sem_Strings_Nil  =
    let (_self) =
            []
    in  (_self)
-- Type --------------------------------------------------------
-- semantic domain
type T_Type = ((Type))
-- cata
sem_Type :: (Type) ->
            (T_Type)
sem_Type ((Type_Application (_range) (_prefix) (_function) (_arguments))) =
    (sem_Type_Application ((sem_Range (_range))) (_prefix) ((sem_Type (_function))) ((sem_Types (_arguments))))
sem_Type ((Type_Constructor (_range) (_name))) =
    (sem_Type_Constructor ((sem_Range (_range))) ((sem_Name (_name))))
sem_Type ((Type_Exists (_range) (_typevariables) (_type))) =
    (sem_Type_Exists ((sem_Range (_range))) ((sem_Names (_typevariables))) ((sem_Type (_type))))
sem_Type ((Type_Forall (_range) (_typevariables) (_type))) =
    (sem_Type_Forall ((sem_Range (_range))) ((sem_Names (_typevariables))) ((sem_Type (_type))))
sem_Type ((Type_Parenthesized (_range) (_type))) =
    (sem_Type_Parenthesized ((sem_Range (_range))) ((sem_Type (_type))))
sem_Type ((Type_Qualified (_range) (_context) (_type))) =
    (sem_Type_Qualified ((sem_Range (_range))) ((sem_ContextItems (_context))) ((sem_Type (_type))))
sem_Type ((Type_Variable (_range) (_name))) =
    (sem_Type_Variable ((sem_Range (_range))) ((sem_Name (_name))))
sem_Type_Application :: (T_Range) ->
                        (Bool) ->
                        (T_Type) ->
                        (T_Types) ->
                        (T_Type)
sem_Type_Application (_range) (_prefix) (_function) (_arguments) =
    let (_self) =
            Type_Application _range_self _prefix _function_self _arguments_self
        ( _range_self) =
            (_range )
        ( _function_self) =
            (_function )
        ( _arguments_self) =
            (_arguments )
    in  (_self)
sem_Type_Constructor :: (T_Range) ->
                        (T_Name) ->
                        (T_Type)
sem_Type_Constructor (_range) (_name) =
    let (_self) =
            Type_Constructor _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
    in  (_self)
sem_Type_Exists :: (T_Range) ->
                   (T_Names) ->
                   (T_Type) ->
                   (T_Type)
sem_Type_Exists (_range) (_typevariables) (_type) =
    let (_self) =
            Type_Exists _range_self _typevariables_self _type_self
        ( _range_self) =
            (_range )
        ( _typevariables_ids,_typevariables_self) =
            (_typevariables )
        ( _type_self) =
            (_type )
    in  (_self)
sem_Type_Forall :: (T_Range) ->
                   (T_Names) ->
                   (T_Type) ->
                   (T_Type)
sem_Type_Forall (_range) (_typevariables) (_type) =
    let (_self) =
            Type_Forall _range_self _typevariables_self _type_self
        ( _range_self) =
            (_range )
        ( _typevariables_ids,_typevariables_self) =
            (_typevariables )
        ( _type_self) =
            (_type )
    in  (_self)
sem_Type_Parenthesized :: (T_Range) ->
                          (T_Type) ->
                          (T_Type)
sem_Type_Parenthesized (_range) (_type) =
    let (_self) =
            Type_Parenthesized _range_self _type_self
        ( _range_self) =
            (_range )
        ( _type_self) =
            (_type )
    in  (_self)
sem_Type_Qualified :: (T_Range) ->
                      (T_ContextItems) ->
                      (T_Type) ->
                      (T_Type)
sem_Type_Qualified (_range) (_context) (_type) =
    let (_self) =
            Type_Qualified _range_self _context_self _type_self
        ( _range_self) =
            (_range )
        ( _context_self) =
            (_context )
        ( _type_self) =
            (_type )
    in  (_self)
sem_Type_Variable :: (T_Range) ->
                     (T_Name) ->
                     (T_Type)
sem_Type_Variable (_range) (_name) =
    let (_self) =
            Type_Variable _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_id,_name_self) =
            (_name )
    in  (_self)
-- Types -------------------------------------------------------
-- semantic domain
type T_Types = ((Types))
-- cata
sem_Types :: (Types) ->
             (T_Types)
sem_Types (list) =
    (foldr (sem_Types_Cons) (sem_Types_Nil) ((map sem_Type list)))
sem_Types_Cons :: (T_Type) ->
                  (T_Types) ->
                  (T_Types)
sem_Types_Cons (_hd) (_tl) =
    let (_self) =
            _hd_self : _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  (_self)
sem_Types_Nil :: (T_Types)
sem_Types_Nil  =
    let (_self) =
            []
    in  (_self)

