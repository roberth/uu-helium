-------------------------------------------------------------------------------
--
--   *** The Helium Compiler : Static Analysis ***
--               ( Bastiaan Heeren )
--
-- MiscErrors.ag : Miscellaneous errors
--
-------------------------------------------------------------------------------

ATTR Expression Expressions MaybeExpression Pattern Patterns Alternative Alternatives
     Statement Statements Declaration Declarations MaybeDeclarations LeftHandSide RightHandSide
     FunctionBinding FunctionBindings Body Qualifier Qualifiers          
     GuardedExpression GuardedExpressions Literal
     [ | miscerrors : {[Error]} | ]

SEM Module
  | Module  body . miscerrors = []
            loc  . miscerrors = @scopeErrors ++ @body.miscerrors
                            
-----------------------------------------
-- Body

SEM Body 
  | Body   lhs . miscerrors = @typeSignatureErrors ++ @declarations.miscerrors
           loc . typeSignatureErrors = checkTypeSignatures @declarations.declVarNames @declarations.typeSignatures

-----------------------------------------
-- Declaration

SEM Declaration
    | FunctionBindings   lhs . miscerrors  = @arityErrors ++ @bindings.miscerrors
                         loc . arityErrors = if all (== head @bindings.arities) @bindings.arities
                                               then []
                                               else [ DefArityMismatch @bindings.name (mode @bindings.arities) @range.self ]
                                               
    | PatternBinding   lhs . miscerrors =  @patternDefinesNoVarsErrors ++ @righthandside.miscerrors
                       loc . patternDefinesNoVarsErrors = if null @pattern.patVarNames
                                                            then [ PatternDefinesNoVars (getPatRange @pattern.self) ]
                                                            else []
    
    | Data   lhs . miscerrors = concat [ makeDuplicated TypeVariable @doubles
                                       , makeUndefined TypeVariable @undef @simpletype.typevariables
                                       , @lhs.miscerrors     
                                       ]
             loc . unused  = filter (`notElem` @constructors.typevariables) @simpletype.typevariables
                 . doubles = filter ((>1) . length) . group . sort $        @simpletype.typevariables
                 . undef   = filter (`notElem` @simpletype.typevariables)   @constructors.typevariables                 

    | Type   lhs . miscerrors = concat [ makeDuplicated TypeVariable @doubles
                                       , makeUndefined TypeVariable @undef @simpletype.typevariables
                                       , @lhs.miscerrors
                                       ] 
             loc . unused  = filter (`notElem` @type.typevariables)       @simpletype.typevariables
                 . doubles = filter ((>1) . length) . group . sort $      @simpletype.typevariables
                 . undef   = filter (`notElem` @simpletype.typevariables) @type.typevariables 
       
SEM MaybeDeclarations
  | Just   lhs . miscerrors = @scopeErrors ++ @typeSignatureErrors ++ @declarations.miscerrors
           loc . (_,doubles) = uniqueAppearance (map fst @declarations.typeSignatures)
           loc . typeSignatureErrors = checkTypeSignatures @declarations.declVarNames @declarations.typeSignatures

{- utility attribute: collecting the arities of the function bindings -}
ATTR FunctionBindings [ | | arities : { [Int] } ]
ATTR FunctionBinding  [ | | arity   :    Int    ]

SEM FunctionBindings
  | Cons lhs.arities = @hd.arity : @tl.arities
  | Nil  lhs.arities = []

SEM FunctionBinding
  | FunctionBinding lhs . arity = @lefthandside.numberOfPatterns

{- utility attribute:  is the last statement an expression? -}  
ATTR Statements Statement [ | lastStatementIsExpr : Bool | ]

SEM Expression
  | Do    statements . lastStatementIsExpr = False

SEM Statement
  | Expression  lhs . lastStatementIsExpr = True
  | Generator   lhs . lastStatementIsExpr = False
  | Let         lhs . lastStatementIsExpr = False
  
{
mode :: Ord a => [a] -> Maybe a -- Just ... IF any of the elements is more common
mode xs = 
    case filter ((== maxFreq) . snd) fs of
        [(x, _)] -> Just x
        _ -> Nothing        
  where
    maxFreq = maximum (map snd fs)
    fs = frequencies xs

frequencies :: Ord a => [a] -> [(a, Int)]
frequencies = map (\ys -> (head ys, length ys)) . group . sort
}
    
-----------------------------------------
-- FunctionBinding

SEM FunctionBinding
  | FunctionBinding   lhs . miscerrors = @scopeErrors ++ @righthandside.miscerrors

-----------------------------------------
-- Expression

SEM Expression
  | Variable     lhs . miscerrors     = @undefinedErrors ++ @lhs.miscerrors 
                 loc . undefinedErrors = if @name.self `elem` @lhs.namesInScope
                                           then []
                                           else [ Undefined Variable @name.self @lhs.namesInScope [] ]
  | Do           lhs . miscerrors = @lastStatementErrors ++ @statements.miscerrors
                 loc . lastStatementErrors = if @statements.lastStatementIsExpr
                                               then []
                                               else let range = getStatementRange (last @statements.self)
                                                    in [ LastStatementNotExpr range ]  
                                                
  | Lambda       lhs . miscerrors = @scopeErrors ++ @expression.miscerrors  
  | Constructor  lhs . miscerrors = @undefinedConstructorErrors ++ @lhs.miscerrors
                 loc . undefinedConstructorErrors = case lookupFM @lhs.valueConstructors @name.self of
                                                       Nothing -> [ undefinedConstructorInExpr @name.self (@lhs.namesInScope ++ @lhs.allValueConstructors) @lhs.allTypeConstructors ]
                                                       Just _  -> []

  | Let          lhs . miscerrors = @scopeErrors ++ @typeSignatureErrors ++ @expression.miscerrors
                 loc . (_,doubles) = uniqueAppearance (map fst @declarations.typeSignatures)
                 loc . typeSignatureErrors = checkTypeSignatures @declarations.declVarNames @declarations.typeSignatures

-----------------------------------------
-- Pattern

SEM Pattern
    | Constructor        lhs . miscerrors = @patConstructorErrors ++ @patterns.miscerrors
                         loc . patConstructorErrors = patternConstructorErrors @maybetp @name.self @lhs.allValueConstructors @patterns.numberOfPatterns @lhs.lhsPattern @lhs.allTypeConstructors
                             . maybetp    = lookupFM @lhs.valueConstructors @name.self

    | InfixConstructor   lhs . miscerrors = @patConstructorErrors ++ @rightPattern.miscerrors
                         loc . patConstructorErrors = patternConstructorErrors @maybetp @constructorOperator.self @lhs.allValueConstructors 2 False @lhs.allTypeConstructors
                             . maybetp    = lookupFM @lhs.valueConstructors @constructorOperator.self


{
patternConstructorErrors :: Maybe TpScheme -> Name -> Names -> Int -> Bool -> Names -> [Error]
patternConstructorErrors maybetparity name env useArity lhsPattern namesTyconEnv =
    case maybetparity of
        Nothing ->
            [ undefinedConstructorInPat lhsPattern name env namesTyconEnv ]
        Just tpScheme ->
            let arity = arityOfTpScheme tpScheme
            in if arity /= useArity
               then [ ArityMismatch Constructor name arity useArity ]
               else []
}

ATTR Patterns Pattern [ lhsPattern : Bool | | ]

SEM Declaration  | PatternBinding pattern      . lhsPattern = simplePattern @pattern.self

SEM Pattern      | Constructor    patterns     . lhsPattern = False
SEM Expression   | Lambda         patterns     . lhsPattern = False
SEM Alternative  | Alternative    pattern      . lhsPattern = False
SEM Statement    | Generator      pattern      . lhsPattern = False
SEM Qualifier    | Generator      pattern      . lhsPattern = False
SEM LeftHandSide | Infix          leftPattern  . lhsPattern = False
                                  rightPattern . lhsPattern = False
                 | Function       patterns     . lhsPattern = False
                 | Parenthesized  patterns     . lhsPattern = False

SEM RecordPatternBinding | RecordPatternBinding   pattern . lhsPattern = False

{
simplePattern :: Pattern -> Bool
simplePattern pattern =
   case pattern of
      Pattern_Constructor _ name _ -> case show name of 
                                         x:_ -> isUpper x
                                         _   -> False
      _                            -> False
}
-----------------------------------------
-- Alternative

SEM Alternative
  | Alternative    lhs . miscerrors = @scopeErrors ++ @righthandside.miscerrors
  
-----------------------------------------
-- Statement  

 SEM Statement
   | Generator  lhs . miscerrors = @scopeErrors ++ @expression.miscerrors
   | Let        lhs . miscerrors = @scopeErrors ++ @typeSignatureErrors ++ @declarations.miscerrors 
                loc . (_,doubles) = uniqueAppearance (map fst @declarations.typeSignatures)
                    . typeSignatureErrors = checkTypeSignatures @declarations.declVarNames @declarations.typeSignatures
                       
-----------------------------------------
-- Qualifier    
       
SEM Qualifier
  | Generator lhs . miscerrors = @scopeErrors ++ @expression.miscerrors
  | Let       lhs . miscerrors = @scopeErrors ++ @typeSignatureErrors ++ @declarations.miscerrors
              loc . (_,doubles) = uniqueAppearance (map fst @declarations.typeSignatures)
                  . typeSignatureErrors = checkTypeSignatures @declarations.declVarNames @declarations.typeSignatures

{
-- Type signature but no function definition
-- Duplicated type signatures
checkTypeSignatures :: Names -> [(Name,TpScheme)] -> Errors
checkTypeSignatures declVarNames xs = 
   let (unique, doubles) = uniqueAppearance (map fst xs)
   in [ Duplicated TypeSignature names 
      | names <- doubles 
      ] 
   ++ [ NoFunDef TypeSignature name declVarNames
      | name <- unique
      , name `notElem` declVarNames
      ]
}

-----------------------------------------
-- Literal

SEM Literal
  | Int loc . intLiteralTooBigErrors = 
                 let val = read @value :: Integer in
                 if length @value > 9 && (val > maxInt || val < minInt)  then 
                    [ IntLiteralTooBig @range @value ]
                 else 
                    []
        lhs . miscerrors = @intLiteralTooBigErrors ++ @lhs.miscerrors
        