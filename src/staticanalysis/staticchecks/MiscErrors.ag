-------------------------------------------------------------------------------
--
--   *** The Helium Compiler : Static Analysis ***
--               ( Bastiaan Heeren )
--
-- MiscErrors.ag : Miscellaneous errors
--
-------------------------------------------------------------------------------

ATTR Expression Expressions MaybeExpression Pattern Patterns Alternative Alternatives
     Statement Statements Declaration Declarations MaybeDeclarations LeftHandSide RightHandSide
     FunctionBinding FunctionBindings Body Qualifier Qualifiers          
     GuardedExpression GuardedExpressions
     [ | miscerrors : {[Error]} | ]

SEM Module
  | Module  body . miscerrors = []
            loc  . miscerrors = @scopeErrors ++ @body.miscerrors
                            
-----------------------------------------
-- Body

SEM Body 
  | Body   lhs . miscerrors = @duplicatedTypeSignature ++ @declarations.miscerrors
           loc . (uniqueTypeSignatures,doubles) = uniqueAppearance (keys @declarations.typeSignatures)
               . duplicatedTypeSignature = [ Duplicated TypeSignature names | names <- @doubles ]

-----------------------------------------
-- Declaration

SEM Declaration
    | FunctionBindings   lhs . miscerrors  = @arityErrors ++ @bindings.miscerrors
                         loc . arityErrors = if all (== head @bindings.arities) @bindings.arities 
                                               then []
                                               else [ DefArityMismatch @bindings.name (mode @bindings.arities) @range.self ]
                                               
    | PatternBinding   lhs . miscerrors =  @patternDefinesNoVarsErrors ++ @righthandside.miscerrors
                       loc . patternDefinesNoVarsErrors = if null @pattern.patVarNames
                                                            then [ PatternDefinesNoVars (getPatRange @pattern.self) ]
                                                            else []
    
    | Data   lhs . miscerrors = concat [ makeDuplicated TypeVariable @doubles
                                       , makeUndefined TypeVariable @undef @simpletype.typevariables
                                       , @lhs.miscerrors     
                                       ]
             loc . unused  = filter (`notElem` @constructors.typevariables) @simpletype.typevariables
                 . doubles = filter ((>1) . length) . group . sort $        @simpletype.typevariables
                 . undef   = filter (`notElem` @simpletype.typevariables)   @constructors.typevariables                 

    | Type   lhs . miscerrors = concat [ makeDuplicated TypeVariable @doubles
                                       , makeUndefined TypeVariable @undef @simpletype.typevariables
                                       , @lhs.miscerrors
                                       ] 
             loc . unused  = filter (`notElem` @type.typevariables)       @simpletype.typevariables
                 . doubles = filter ((>1) . length) . group . sort $      @simpletype.typevariables
                 . undef   = filter (`notElem` @simpletype.typevariables) @type.typevariables 
       
SEM MaybeDeclarations
  | Just   lhs . miscerrors = @scopeErrors ++ @duplicatedTypeSignature ++ @declarations.miscerrors
           loc . (uniqueTypeSignatures,doubles) = uniqueAppearance (keys @declarations.typeSignatures)
               . duplicatedTypeSignature = [ Duplicated TypeSignature names | names <- @doubles ]

{- utility attribute: collecting the arities of the function bindings -}
ATTR FunctionBindings [ | | arities : { [Int] } ]
ATTR FunctionBinding  [ | | arity   :    Int    ]

SEM FunctionBindings
  | Cons lhs.arities = @hd.arity : @tl.arities
  | Nil  lhs.arities = []

SEM FunctionBinding
  | FunctionBinding lhs . arity = @lefthandside.numberOfPatterns

{- utility attribute:  is the last statement an expression? -}  
ATTR Statements Statement [ | lastStatementIsExpr : Bool | ]

SEM Expression
  | Do    statements . lastStatementIsExpr = False
  
SEM Statement
  | Expression  lhs . lastStatementIsExpr = True
  | Generator   lhs . lastStatementIsExpr = False
  | Let         lhs . lastStatementIsExpr = False
  
{
listToAssocList :: Ord a => [a] -> AssocList a ()
listToAssocList list = fromList (zip list (repeat ()))

mode :: Ord a => [a] -> Maybe a -- Just ... IF any of the elements is more common
mode xs = 
    case filter ((== maxFreq) . snd) fs of
        [(x, _)] -> Just x
        _ -> Nothing        
  where
    maxFreq = maximum (map snd fs)
    fs = frequencies xs

frequencies :: Ord a => [a] -> [(a, Int)]
frequencies = map (\ys -> (head ys, length ys)) . group . sort
}
    
-----------------------------------------
-- FunctionBinding

SEM FunctionBinding
  | FunctionBinding   lhs . miscerrors = @scopeErrors ++ @righthandside.miscerrors

-----------------------------------------
-- Expression

SEM Expression
  | Variable     lhs . miscerrors     = @undefinedErrors ++ @lhs.miscerrors 
                 loc . undefinedErrors = if @name.self `elem` @lhs.namesInScope
                                           then []
                                           else [ Undefined Variable @name.self @lhs.namesInScope Nothing ]
  | Do           lhs . miscerrors = @lastStatementErrors ++ @statements.miscerrors
                 loc . lastStatementErrors = if @statements.lastStatementIsExpr
                                               then []
                                               else let range = getStatementRange (last @statements.self)
                                                    in [ LastStatementNotExpr range ]  
                                                
  | Lambda       lhs . miscerrors = @scopeErrors ++ @expression.miscerrors  
  | Constructor  lhs . miscerrors = @undefinedConstructorErrors ++ @lhs.miscerrors
                 loc . undefinedConstructorErrors = case lookupAL @name.self @lhs.constructorenv of 
                                                       Nothing -> [ undefinedConstructor @name.self (@lhs.namesInScope ++ keys @lhs.constructorenv) (keys @lhs.tyconEnv) ]
                                                       Just _  -> []
                                                                          
  | Let          lhs . miscerrors = @scopeErrors ++ @duplicatedTypeSignature ++ @expression.miscerrors
                 loc . (uniqueTypeSignatures,doubles) = uniqueAppearance (keys @declarations.typeSignatures)
                     . duplicatedTypeSignature = [ Duplicated TypeSignature names | names <- @doubles ]
               
-----------------------------------------
-- Pattern

SEM Pattern
    | Constructor        lhs . miscerrors = @patConstructorErrors ++ @patterns.miscerrors
                         loc . patConstructorErrors = patternConstructorErrors @maybetp @name.self (@lhs.namesInScope ++ keys @lhs.constructorenv) @patterns.numberOfPatterns (keys @lhs.tyconEnv) 
                             . maybetp    = lookupAL @name.self @lhs.constructorenv
                         
    | InfixConstructor   lhs . miscerrors = @patConstructorErrors ++ @rightPattern.miscerrors
                         loc . patConstructorErrors = patternConstructorErrors @maybetp @constructorOperator.self (@lhs.namesInScope ++ keys @lhs.constructorenv) 2 (keys @lhs.tyconEnv)                                          
                             . maybetp    = lookupAL @constructorOperator.self @lhs.constructorenv                         

       
{
patternConstructorErrors :: Maybe TpScheme -> Name -> Names -> Int -> Names -> [Error]
patternConstructorErrors maybetparity name env useArity namesTyconEnv =
    case maybetparity of
        Nothing -> 
            [ undefinedConstructor name env namesTyconEnv ]
        Just tpScheme -> 
            let arity = arityOfTpScheme tpScheme
            in if arity /= useArity
               then [ ArityMismatch Constructor name arity useArity ]
               else []
}

-----------------------------------------
-- Alternative
                                           
SEM Alternative
  | Alternative    lhs . miscerrors = @scopeErrors ++ @righthandside.miscerrors
  
-----------------------------------------
-- Statement  

 SEM Statement
   | Generator  lhs . miscerrors = @scopeErrors ++ @expression.miscerrors    
   | Let        lhs . miscerrors = @scopeErrors ++ @duplicatedTypeSignature ++ @declarations.miscerrors 
                loc . (uniqueTypeSignatures,doubles) = uniqueAppearance (keys @declarations.typeSignatures)
                    . duplicatedTypeSignature = [ Duplicated TypeSignature names | names <- @doubles ] 
                       
-----------------------------------------
-- Qualifier    
       
SEM Qualifier
  | Generator lhs . miscerrors = @scopeErrors ++ @expression.miscerrors
  | Let       lhs . miscerrors = @scopeErrors ++ @duplicatedTypeSignature ++ @declarations.miscerrors
              loc . (uniqueTypeSignatures,doubles) = uniqueAppearance (keys @declarations.typeSignatures)
                  . duplicatedTypeSignature = [ Duplicated TypeSignature names | names <- @doubles ]
