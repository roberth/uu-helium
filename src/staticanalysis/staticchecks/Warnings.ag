-------------------------------------------------------------------------------
--
--   *** The Helium Compiler : Static Analysis ***
--               ( Bastiaan Heeren )
--
-- Warnings.ag : The warnings that are collected are the following:
--    1) A variable shadows another variable
--    2) An entity is not used (except top level entities, since these can be exported)
--    3) Suspicious function bindings (two groups of function bindings are next to each 
--               other in the program; the names are similar, but only one has an
--               explicit type signature. Perhaps only one group of function bindings was intended?)
--
-------------------------------------------------------------------------------

ATTR Expression Expressions MaybeExpression Pattern Patterns Alternative Alternatives
     Statement Statements Declaration Declarations MaybeDeclarations LeftHandSide RightHandSide
     FunctionBinding FunctionBindings Body Qualifier Qualifiers          
     GuardedExpression GuardedExpressions
     [ | warnings : {[Warning]} | ]

SEM Module
  | Module    body . warnings = []
              loc  . warnings = @body.warnings
                                 
SEM Body
  | Body   
        lhs . warnings =  @declarations.warnings ++
                          @suspiciousErrors
  
SEM Expression
  | Lambda     lhs . warnings = @scopeWarnings ++
                                @expression.warnings
  | Let        lhs . warnings = @scopeWarnings ++
                                @expression.warnings ++
                                @suspiciousErrors

SEM Alternative
  | Alternative
               lhs . warnings = @scopeWarnings ++
                                @righthandside.warnings                                
                                
SEM Statement
  | Generator  lhs . warnings = @scopeWarnings ++
                                @expression.warnings                                  
  | Let lhs . warnings =  @scopeWarnings ++
                          @declarations.warnings ++
                          @suspiciousErrors
                          
SEM Qualifier
  | Generator  lhs . warnings = @scopeWarnings ++
                                @expression.warnings                                  
  | Let lhs . warnings =  @scopeWarnings ++
                          @declarations.warnings ++
                          @suspiciousErrors
                                                            
SEM FunctionBinding
  | FunctionBinding
                   lhs . warnings = @scopeWarnings ++
                                    @righthandside.warnings                                  
                                    
SEM MaybeDeclarations
  | Just
        lhs . warnings =  @scopeWarnings ++
                          @declarations.warnings ++
                          @suspiciousErrors                                     
                          
SEM Declaration
  | Data
        lhs . warnings = makeUnused TypeVariable @unused False ++ @lhs.warnings
          
  | Type                             
        lhs . warnings = makeUnused TypeVariable @unused False ++ @lhs.warnings       
                                                  
-------------------------------------------
-- Suspicious Function Bindings

ATTR Declarations Declaration [ | previousWasAlsoFB:{Maybe Name} suspiciousFBs : {[(Name,Name)]} | ]

SEM Body 
  | Body   declarations . previousWasAlsoFB = Nothing
                        . suspiciousFBs     = []
                    loc . suspiciousErrors  = findSimilarFunctionBindings @declarations.typeSignatures @declarations.suspiciousFBs
                        
SEM MaybeDeclarations
  | Just   declarations . previousWasAlsoFB = Nothing 
                        . suspiciousFBs     = []     
                    loc . suspiciousErrors  = findSimilarFunctionBindings @declarations.typeSignatures @declarations.suspiciousFBs                                              
  
SEM Expression
  | Let    declarations . previousWasAlsoFB = Nothing
                        . suspiciousFBs     = []  
                    loc . suspiciousErrors  = findSimilarFunctionBindings @declarations.typeSignatures @declarations.suspiciousFBs                            
  
SEM Statement
  | Let    declarations . previousWasAlsoFB = Nothing
                        . suspiciousFBs     = []           
                    loc . suspiciousErrors  = findSimilarFunctionBindings @declarations.typeSignatures @declarations.suspiciousFBs                                         
                          
SEM Qualifier    
  | Let    declarations . previousWasAlsoFB = Nothing  
                        . suspiciousFBs     = []
                    loc . suspiciousErrors  = findSimilarFunctionBindings @declarations.typeSignatures @declarations.suspiciousFBs                            
                        
SEM Declaration                                  
  | Type               lhs . previousWasAlsoFB = Nothing
  | Data               lhs . previousWasAlsoFB = Nothing             
  | Newtype            lhs . previousWasAlsoFB = Nothing
  | Class              lhs . previousWasAlsoFB = Nothing
  | Instance           lhs . previousWasAlsoFB = Nothing
  | Default            lhs . previousWasAlsoFB = Nothing
  | PatternBinding     lhs . previousWasAlsoFB = Nothing
  | TypeSignature      lhs . previousWasAlsoFB = Nothing
  | Fixity             lhs . previousWasAlsoFB = Nothing
  | FunctionBindings   lhs . previousWasAlsoFB = Just @bindings.name
                           . suspiciousFBs     = case @lhs.previousWasAlsoFB of
                                                    Just name | show name `similar` show @bindings.name
                                                       -> (name,@bindings.name) : @lhs.suspiciousFBs
                                                    _  -> @lhs.suspiciousFBs

{
findSimilarFunctionBindings :: [(Name, TpScheme)] -> [(Name,Name)] -> [Warning]
findSimilarFunctionBindings environment candidates = 
   let namesWithTypeDef = map fst environment
   in [ uncurry SimilarFunctionBindings pair
      | (n1,n2) <- candidates
      , let bool1 = n1 `elem` namesWithTypeDef
            bool2 = n2 `elem` namesWithTypeDef
            pair  = if bool1 then (n2,n1) else (n1,n2)
      , bool1 `xor` bool2
      ]

xor :: Bool -> Bool -> Bool
xor b1 b2 = not (b1 == b2)
}
