-------------------------------------------------------------------------------
--
--   *** The Helium Compiler : Static Analysis ***
--               ( Bastiaan Heeren )
--
-- Scope.ag : Here, all variables (of type Name) are determined that are in 
--    scope (for each location in the abstract syntax tree)
-- 
-- Variables can be add to the scope by three ways: 
--
--   1) externally defefined, imported, or primitive
--           Module.Module
--
--   2) introduced in a binding-group (nodes with "Declarations")
--            Body.Body
--            MaybeDeclarations.Just
--            Expression.Let
--            Statement.Let
--            Qualifier.Let
--
--   3) introduced in a pattern that is not part of a binding-group; these
--         variables are automatically monomorphic. (nodes with "Pattern"
--         or "Patterns") 
--            FunctionBinding.FunctionBinding
--            Expression.Lambda
--            Alternative.Alternative
--            Statement.Generator
--            Qualifier.Generator
--
-- The scope simply follows the shape of the abstract syntax tree, except for
-- Statements, Qualifiers en RightHandSide (where).
--
-------------------------------------------------------------------------------

ATTR Expression RightHandSide
     RecordExpressionBinding RecordExpressionBindings
     MaybeExpression GuardedExpression FunctionBinding
     Expressions Declaration Declarations Alternative FunctionBindings
     Alternatives GuardedExpressions RecordPatternBinding
     Patterns Pattern LeftHandSide RecordPatternBindings AnnotatedType
     AnnotatedTypes Constructor Constructors FieldDeclaration FieldDeclarations Body -- too much???
     [ namesInScope : Names | | unboundNames USE {++} {[]} : Names ]

SEM Module
  | Module   loc . initialNames = map fst @derivedFunctions ++
                                  concatMap (keysFM . typeEnvironment) @lhs.importEnvironments
                 . (namesInScope,unboundNames,scopeErrors,_) = changeOfScope (@initialNames ++ @body.declVarNames) Definition @body.unboundNames []
                 
SEM MaybeDeclarations
  | Just   loc . (namesInScope,unboundNames,scopeErrors,scopeWarnings)     = changeOfScope @declarations.declVarNames Definition (@declarations.unboundNames ++ @lhs.unboundNames) @lhs.namesInScope
           lhs . unboundNames = @unboundNames -- not a copy-rule for my ag-compiler!
           
SEM Expression
  | Let    loc . (namesInScope,unboundNames,scopeErrors,scopeWarnings)     = changeOfScope @declarations.declVarNames Definition (@declarations.unboundNames ++ @expression.unboundNames) @lhs.namesInScope
           lhs . unboundNames = @unboundNames -- not a copy-rule for my ag-compiler!
           
SEM Statement
  | Let    loc . (namesInScope,unboundNames,scopeErrors,scopeWarnings)     = changeOfScope @declarations.declVarNames Definition (@declarations.unboundNames ++ @lhs.unboundNames) @lhs.namesInScope
           
SEM Qualifier
  | Let    loc . (namesInScope,unboundNames,scopeErrors,scopeWarnings)     = changeOfScope @declarations.declVarNames Definition (@declarations.unboundNames ++ @lhs.unboundNames) @lhs.namesInScope
           
-- monomorphic binding constructions

SEM FunctionBinding
  | FunctionBinding   loc . (namesInScope,unboundNames,scopeErrors,scopeWarnings) = changeOfScope @lefthandside.patVarNames Variable @righthandside.unboundNames @lhs.namesInScope
                      lhs . unboundNames = @unboundNames -- not a copy-rule for my ag-compiler!
                      
SEM Expression
  | Lambda            loc . (namesInScope,unboundNames,scopeErrors,scopeWarnings) = changeOfScope @patterns.patVarNames Variable @expression.unboundNames @lhs.namesInScope
                      lhs . unboundNames = @unboundNames -- not a copy-rule for my ag-compiler!

SEM Alternative
  | Alternative       loc . (namesInScope,unboundNames,scopeErrors,scopeWarnings) = changeOfScope @pattern.patVarNames Variable @righthandside.unboundNames @lhs.namesInScope
                      lhs . unboundNames = @unboundNames -- not a copy-rule for my ag-compiler!
                      
SEM Statement
  | Generator         loc . (namesInScope,unboundNames,scopeErrors,scopeWarnings) = changeOfScope @pattern.patVarNames Variable (@expression.unboundNames ++ @lhs.unboundNames) @lhs.namesInScope

SEM Qualifier
  | Generator         loc . (namesInScope,unboundNames,scopeErrors,scopeWarnings) = changeOfScope @pattern.patVarNames Variable (@expression.unboundNames  ++ @lhs.unboundNames)  @lhs.namesInScope
                      
-- correcte scope voor RightHandSides (where)

ATTR MaybeDeclarations [ | unboundNames : Names namesInScope : Names | ]

SEM RightHandSide 
  | Expression   lhs                . unboundNames = @where.unboundNames
                 expression         . namesInScope = @where.namesInScope
                 where              . unboundNames = @expression.unboundNames
  | Guarded      lhs                . unboundNames = @where.unboundNames
                 guardedexpressions . namesInScope = @where.namesInScope 
                 where              . unboundNames = @guardedexpressions.unboundNames

-- correcte scope voor Statements/Qualifiers

ATTR Statements Statement Qualifier Qualifiers [ | namesInScope : Names unboundNames : Names | ]

SEM Expression
  | Do  statements . unboundNames = []

SEM Statement
  | Generator   lhs        . namesInScope = @namesInScope
                           . unboundNames = @unboundNames
                expression . namesInScope = @lhs.namesInScope
  | Let         lhs        . unboundNames = @unboundNames                
  | Expression  lhs        . unboundNames = @expression.unboundNames ++ @lhs.unboundNames                 

SEM Statements
  | Cons   lhs . unboundNames = @hd.unboundNames
           tl  . unboundNames = @lhs.unboundNames
           hd  . unboundNames = @tl.unboundNames
  | Nil    lhs . unboundNames = @lhs.unboundNames
  
SEM Expression
  | Comprehension    lhs        . unboundNames = @qualifiers.unboundNames
                     expression . namesInScope = @qualifiers.namesInScope
                     qualifiers . namesInScope = @lhs.namesInScope
                                . unboundNames = @expression.unboundNames

SEM Qualifier
  | Generator   lhs        . namesInScope = @namesInScope
                           . unboundNames = @unboundNames
                expression . namesInScope = @lhs.namesInScope
  | Let         lhs        . unboundNames = @unboundNames                
  | Guard       lhs        . unboundNames = @guard.unboundNames ++ @lhs.unboundNames  

SEM Qualifiers
  | Cons   lhs . unboundNames = @hd.unboundNames
           tl  . unboundNames = @lhs.unboundNames
           hd  . unboundNames = @tl.unboundNames
  | Nil    lhs . unboundNames = @lhs.unboundNames

-- utility function
{                              
changeOfScope :: Names -> Entity -> Names -> Names -> (Names,Names,Errors,Warnings)
changeOfScope names entity unboundNames namesInScope = 
   let (uniqueNames, duplicatedNames)   = uniqueAppearance names
       removedNames = map (nameFromString . show . head) duplicatedNames
       op name (scope,unbound,ws) =   
          let (newScope, ws1)   = case partition (==name) scope of
                                     ([], _)     -> (name : scope, [])
                                     (old, rest) -> (name : rest, [ Shadow x name | x <- old ])
              (newUnbound, ws2) = case partition (==name) unbound of 
                                     ([], _)   -> (unbound, [Unused entity name False]) 
                                     (_, rest) -> (rest, [])
          in (newScope,newUnbound,ws2++ws1++ws)
       (xs,ys,warnings) =  foldr op (namesInScope,unboundNames,[]) uniqueNames                       
       errors = [ Duplicated entity xs | xs <- duplicatedNames ]
   in (removedNames ++ (xs \\ removedNames),ys \\ removedNames,errors,warnings)
      
uniqueAppearance :: Ord a => [a] -> ([a],[[a]])
uniqueAppearance = foldr insert ([],[]) . group . sort
   where insert [x] (as,bs) = (x:as,bs)
         insert xs  (as,bs) = (as,xs:bs)
}

ATTR Pattern Patterns 
     LeftHandSide [ | | patVarNames USE {++} {[]} : Names ]

SEM Pattern 
  | Variable   lhs . patVarNames = [ @name.self ]
  | As         lhs . patVarNames = @name.self : @pattern.patVarNames

SEM Expression 
  | Variable   lhs . unboundNames = [ @name.self ]    
  
ATTR Body Declaration Declarations [ | | declVarNames USE {++} {[]} : Names ]

SEM Declaration 
  | FunctionBindings  lhs . declVarNames = [@bindings.name]
  | PatternBinding    lhs . declVarNames = @pattern.patVarNames
