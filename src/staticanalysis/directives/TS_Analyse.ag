-----------------------------------------------------------------------------
-- |The Helium Compiler : Static Analysis
--
-- Maintainer  :  bastiaan@cs.uu.nl
-- Stability   :  experimental
-- Portability :  unknown
--
-- An analyzer for type inference directives.
--
-- (directives based on "Scripting the Type Inference Process", ICFP 2003)
-----------------------------------------------------------------------------

{
analyseTypingStrategies :: TypingStrategies -> ImportEnvironment -> (TS_Errors, TS_Warnings)
analyseTypingStrategies list ie = 
   let (as, bs) = unzip (map (\ts -> analyseTypingStrategy ts ie) list)
   in (concat as, concat bs)

analyseTypingStrategy :: TypingStrategy -> ImportEnvironment -> (TS_Errors, TS_Warnings)
analyseTypingStrategy ts ie = 
    let (errs, _, wars) = sem_TypingStrategy ts ie in (errs, wars)
}

INCLUDE "../../syntax/UHA_Syntax.ag"
INCLUDE "TS_Syntax.ag"
INCLUDE "TS_Collect.ag"

imports {
import Top.Types
import Top.Types.Schemes(instantiateWithNameMap)
import Top.Solver.Greedy
import Top.Solver
import Top.Constraint.Equality(EqualityConstraint(..))
import UHA_Utils (getNameName)
import TypeConstraints
import ConstraintInfo
import TS_Syntax
import TypeConversion
import List
import Maybe(mapMaybe)
import UHA_Utils (nameFromString)
import UHA_Range (noRange)
import UHA_Source
import Messages
import TypeErrors
import TS_Messages
import ImportEnvironment hiding (setTypeSynonyms)
import ExpressionTypeInferencer (expressionTypeInferencer)
import Char (isAlphaNum)
import Utils (internalError)
import qualified UHA_Pretty as PP
import qualified Data.Map as M

import Debug.Trace(trace)
}

ATTR TypingStrategy  [ importEnvironment : ImportEnvironment
                     |
                     | errors            : TS_Errors
                       warnings          : TS_Warnings  
                     ]

SEM TypingStrategy  
  | Siblings             -- no analysis for siblings (yet)
       lhs . errors       = []
           . warnings     = []
           
  | TypingStrategy  
       loc . name         = show (PP.sem_Expression @typerule.conclusionExpression)
           . nameMap      = zip @uniqueTypevariables (map TVar [0..])
           . errors       = @staticErrors ++ @soundnessErrors 
           . staticErrors = [ InconsistentConstraint @name x | (x, label) <- @solveErrors ] ++
                            [ UndefinedTS @name name entity 
                            | (name, entity) <- @typerule.conclusionAllVariables 
                            , show name `notElem` (@allMetaVariables ++ map show @allImportedVariables)
                            ] ++
                            [ UnusedMetaVariable @name s 
                            | s <- @allMetaVariables
                            , s `notElem` (map (show . fst) @typerule.conclusionAllVariables)
                            ] ++
                            [ DuplicatedMetaVariablesPremise @name x  
                            | x:_ <- findDuplicates @allMetaVariables
                            ] ++
                            [ DuplicatedMetaVariablesConclusion @name x  
                            | let strings = map (show . fst) @typerule.conclusionAllVariables
                            , x:_ <- findDuplicates (filter (`elem` @allMetaVariables) strings)
                            ] ++
                            [ DuplicatedMetaVariableConstraints @name (show x) 
                            | x:_ <- findDuplicates @statements.metaVariableConstraintNames
                            ]
           . warnings     = [] {- case @constraintsNotExplicit of 
                              [] -> []
                              xs -> [ MetaVariableConstraintsNotExplicit @name xs ]  -}

           -- Solve the constraint set.   
           . substitution = substitutionFromResult @solveResult
           . solveErrors  = errorsFromResult @solveResult
           . solveResult = @solve (reverse @statements.userConstraints)

           . solve = 
                let options = solveOptions { uniqueCounter = length @uniqueTypevariables 
                                           , Top.Solver.typeSynonyms = getOrderedTypeSynonyms @lhs.importEnvironment
                                           , classEnvironment = @classEnv
                                           } 
                in \constraints -> fst (solve options constraints greedyConstraintSolver)
                      
           . classEnv = createClassEnvironment @lhs.importEnvironment
          
           --TODO: better reports iff the judgement constraints are unsound 
           . soundnessErrors = 
                if not (null @staticErrors)
                  then []
                  else let constraintsTpScheme = @mkSkeletonTypeScheme @substitution
                           isSameTypeScheme a b = @genInstOf a b && @genInstOf b a
                           substTpVars = substTpVarsInConstr (nameMapToTVarSubst @nameMap)
                           missing = if null @missingConstrs then []
                                     else [MissingConstraints @name $ map substTpVars @missingConstrs]
                           unsound = if null @badConstrs then []
                                     else [UnsoundConstraints @name $ map substTpVars @badConstrs]
                           useless = if null @uselessConstrs then []
                                     else [UselessConstraints @name $ map substTpVars @uselessConstrs]
                           trivialConstr = [TVar 0 .==. TVar 0 $ undefined]
                           jmConstrsAreSound = null $ snd $ @getUnsoundConstrs (undefined,[]) trivialConstr
                       in if not (null @inferredTypeErrors) 
                            then map (TypeErrorTS @name) @inferredTypeErrors
                            else if isSameTypeScheme @inferredTpScheme constraintsTpScheme 
                                   then []
                                   else Soundness @name @inferredTpScheme constraintsTpScheme
                                        : if jmConstrsAreSound then unsound ++ useless ++ missing else []

           . mkSkeletonTypeScheme = generalizeAll . @mkSkeletonType

           . mkSkeletonType =
                let premiseTypes = map snd (reverse @typerule.simpleJudgements)
                    skeletonType = foldr (.->.) @typerule.conclusionType premiseTypes
                in \s -> s |-> (@statements.userPredicates .=>. skeletonType)

           . (inferredTpScheme, _, inferredTypeErrors) = 
                let expr = Expression_Lambda noRange pats @typerule.conclusionExpression
                    pats = map (Pattern_Variable noRange . nameFromString . fst) orderedMetaList
                    orderedMetaList = reverse @typerule.simpleJudgements
                in expressionTypeInferencer @lhs.importEnvironment expr 

           . genInstOf =
                let synonyms = getOrderedTypeSynonyms @lhs.importEnvironment
                in genericInstanceOf synonyms @classEnv
           
           --TODO: implement this with a real substitution in stead of a list of constraints
           . solveSingleConstr = 
                (\(_,cs) c -> let canSolve = (null . errorsFromResult . @solve) (c:cs)
                                  subst = (substitutionFromResult . @solve) (c:cs)
                              in if canSolve then Just (subst, c:cs) else Nothing)

           . getUnsoundConstrs =  
                let check s [] = ([],[])
                    check s (c:cs) =
                      case @solveSingleConstr s c of
                        Just s' | @genInstOf @inferredTpScheme tps -> (c:gcs, bcs)
                          where tps = @mkSkeletonTypeScheme (fst s')
                                (gcs, bcs) = check s' cs
                        otherwise -> (gcs, c:bcs)
                          where (gcs, bcs) = check s cs
                in check

           . (goodConstrs,badConstrs) =
                @getUnsoundConstrs (undefined,[]) (reverse @statements.userConstraints)

           . getUselessConstrs =
                let --isUseless cs' cs = @genInstOf (mkSTS cs') (mkSTS cs)
                    mkSTS = @mkSkeletonTypeScheme .  substitutionFromResult . @solve
                    
                    check :: ([TypeConstraint ConstraintInfo] -> [TypeConstraint ConstraintInfo]) -> [TypeConstraint ConstraintInfo] -> ([TypeConstraint ConstraintInfo],[TypeConstraint ConstraintInfo])
                    check ufcs [] = ([],[])
                    check ufcs ccs@(c:cs) =
                      if @genInstOf (mkSTS $ ufcs cs) (mkSTS $ ufcs ccs)
                        then (c:ul, uf)  
                        else (ul', c:uf')  
                          where (ul,uf) = check ufcs cs
                                (ul',uf') = check (ufcs . (c:)) cs
                in check

           . (uselessConstrs,usefulConstrs) = @getUselessConstrs id @goodConstrs

           --TODO: make sure that newly introduced variables (always of the form v<number>) are unique
           . missingConstrs = 
                let (Right substs) = mgu ucTp inferredTp
                    Qualification (_,ucTp) = mkSelTypeConstrs @usefulConstrs
                    mkSelTypeConstrs = @mkSkeletonType . substitutionFromResult . @solve
                    (_,_,inferredTp) = instantiateWithNameMap unique @inferredTpScheme
                    unique = length @nameMap
                    mkConstr (i,tp) = (TVar i .==. tp) @standardConstraintInfo

                    rawMissing = map mkConstr $ M.toList substs
                    trivToSubst (TC1 (Equality (TVar a) (TVar b) info)) 
                      | a < unique && b >= unique = Just (b,a)
                      | b < unique && a >= unique = Just (a,b)
                    trivToSubst _ = Nothing
                    trivSubstMap = M.fromList $ mapMaybe trivToSubst rawMissing
                    trivSubst i = TVar $ M.findWithDefault i i trivSubstMap
                    substedConstrs = map (substTpVarsInConstr trivSubst) rawMissing
                    (_,usefulMissing) = @getUselessConstrs (++ @goodConstrs) substedConstrs
                in usefulMissing


{
skipList :: [a] -> [[a]]
skipList [] = []
skipList (x:xs) = xs : [ x:sxs | sxs <- skipList xs ]

substTVar :: (Int -> Tp) -> Tp -> Tp
substTVar f (TApp a b) = TApp (substTVar f a) (substTVar f b)
substTVar f (TVar i) = f i
substTVar f tp = tp

substTpVarsInConstr :: (Int -> Tp) -> TypeConstraint ConstraintInfo -> TypeConstraint ConstraintInfo
substTpVarsInConstr f (TC1 (Equality a b info)) = (substTVar f a .==. substTVar f b) info
substTpVarsInConstr f c = c

nameMapToTVarSubst :: [(Name,Tp)] -> Int -> Tp
nameMapToTVarSubst m i = M.findWithDefault (TVar i) i m' 
  where m' = M.fromList (map swap m)
        swap (a,TVar b) = (b, TCon $ getNameName a)


--TODO: move this to ../miscellaneous/TypeConversion.hs
--makeTypeFromTpWithMap :: [(Name,Tp)] -> Tp -> Tp
--makeTypeFromTpWithMap m tp =
--  let nameMap = M.fromList (map swap m)
--      lookupType i = M.findWithDefault ('v' : show i) i nameMap
--      swap (a,TVar b) = (b,getNameName a)
--  in substTVar (TCon . lookupType) tp

--FIXME: a lot of copy/paste from ../miscellaneous/TypeConversion.hs
-- perhaps move it to there?
--makeTypeFromTpWithMap :: [(Name,Tp)] -> Tp -> Type
--makeTypeFromTpWithMap map tp =
--      lookupType i = M.findWithDefault ('v' : show i) i nameMap
--      nameMap = M.fromList (map swap map)
--  let (x,xs) = leftSpine t
--      f (TVar i) = Type_Variable noRange (lookupType i)
--      f (TCon s) = Type_Constructor noRange (nameFromString s)
--      nameMap = M.fromList (map swap map)
--      swap (a,b) = (b,a)
--   in if null xs
--        then f x
--        else Type_Application noRange True (f x) (map makeTypeFromTp xs)
}

                                      
-- cheching the names
ATTR Judgement Expression Expressions MaybeExpression [ | | allVariables USE { ++ } { [] } : {[(Name,Entity)]} ]

SEM Expression 
  | Variable      lhs . allVariables = [(@name.self, Variable)] 
  | Constructor   lhs . allVariables = [(@name.self, Constructor)]

ATTR TypeRule  [ | | conclusionAllVariables : {[(Name,Entity)]} ]
SEM TypeRule | TypeRule lhs . conclusionAllVariables = @conclusion.allVariables

SEM TypingStrategy 
  | TypingStrategy  
       loc.allImportedVariables = 
          M.keys (typeEnvironment   @lhs.importEnvironment) ++
          M.keys (valueConstructors @lhs.importEnvironment)



-- prevent AG-warnings
SEM TypingStrategies | Cons  loc . importEnvironment = 
   internalError "TS_Analyse.ag" "n/a" "TS_Analyse.ag"

{
findDuplicates :: Ord a => [a] -> [[a]]
findDuplicates = filter (not . isSingleton) . group . sort
   where isSingleton [_] = True
         isSingleton _   = False        
}
