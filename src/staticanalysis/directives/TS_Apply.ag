-----------------------------------------------------------------------------
-- |The Helium Compiler : Static Analysis
--
-- Maintainer  :  bastiaan@cs.uu.nl
-- Stability   :  experimental
-- Portability :  unknown
--
-- Apply specialized type rules during the type inference process.
--
-- (directives based on "Scripting the Type Inference Process", ICFP 2003)
-----------------------------------------------------------------------------

INCLUDE "TS_CoreData.ag"

imports {
import UHA_Syntax
import TypeConstraints
import ConstraintInfo
import Top.Types
import List
import UHA_Range (noRange)
import Utils (internalError)
import OneLiner
import Messages
import TypeErrors
import ImportEnvironment
import OperatorTable (OperatorTable)
import Parser (exp_)
import Lexer (strategiesLexer)
import ParseLibrary (runHParser)
import qualified ResolveOperators
import TS_Attributes
import TS_CoreSyntax
import Top.ComposedSolvers.Tree
import UHA_Source
import Data.FiniteMap
import DoublyLinkedTree (root)
}

{
type MetaVariableTable info = [(String, (ConstraintSet, info))]

getTheType :: LocalInfo -> Tp
getTheType = maybe (TCon "???") id . assignedType

applyTypingStrategy :: Core_TypingStrategy -> (ConstraintSet, LocalInfo) -> MetaVariableTable LocalInfo -> Int -> (ConstraintSet, IO (), Int)
applyTypingStrategy = sem_Core_TypingStrategy

matchInformation :: ImportEnvironment -> Core_TypingStrategy -> [(Expression, [String])]
matchInformation importEnvironment typingStrategy = 
   case typingStrategy of 
      TypingStrategy (TypeRule premises conclusion) _ -> 
         let Judgement exprstring _ = conclusion
             expression = expressionParser (operatorTable importEnvironment) exprstring
             metas      = [ s | Judgement s t <- premises ]
         in [(expression, metas)]
      _ -> []
      
expressionParser :: OperatorTable -> String -> Expression
expressionParser operatorTable string = 
    case strategiesLexer "TS_Apply" string of 
        Left lexErr -> intErr
        Right (tokens, _) ->
            case runHParser exp_ "TS_Apply" tokens True {- wait for EOF -} of
                Left parseError  -> intErr
                Right expression -> 
                    ResolveOperators.expression operatorTable expression
  where
    intErr = internalError "TS_Apply.ag" "n/a" ("unparsable expression: "++show string)
}

ATTR Core_TypingStrategy 
     [ infoTuple         : {(ConstraintSet, LocalInfo)}
       metaVariableTable : {MetaVariableTable LocalInfo}  
     | unique            : Int 
     | constraintSet     : ConstraintSet
       debugIO           : {IO ()}
     ] 
          
SEM Core_TypingStrategy 
  | Siblings     
       lhs . constraintSet = emptyTree
           . debugIO       = return ()
  | TypingStrategy     
       lhs . constraintSet = Node @allConstraintTrees
           . unique        = length @normalTV + @lhs.unique
           . debugIO       = putStrLn "applying typing strategy"
       loc . substitution  = listToSubstitution (@standardSubst ++ @specialSubst)
           . allTV         = @typerule.ftv `union` @statements.ftv

{- type variables that occur exactly once in a judgement should not introduce a new constraint -}           
           . specialTV     = concat . exactlyOnce . map ftv . filter isTVar . map snd $ @typerule.judgements
           . normalTV      = @allTV \\ @specialTV
           
           . standardSubst = zip @normalTV (map TVar [@lhs.unique..])
           . specialSubst  = let conclusionVar = case snd (last @typerule.judgements) of
                                                    TVar i -> Just i
                                                    _      -> Nothing
                                 find i | Just i == conclusionVar = [ (i, getTheType (snd @lhs.infoTuple)) ]
                                        | otherwise               = [ (i, getTheType (snd infoTuple))
                                                                    | (s1, TVar j) <- @typerule.judgements
                                                                    , i == j
                                                                    , (s2,infoTuple) <- @lhs.metaVariableTable
                                                                    , s1 == s2
                                                                    ]
                             in concatMap find @specialTV
                             

ATTR Core_TypeRule
     Core_Judgements Core_Judgement
     Core_UserStatements Core_UserStatement 
     [ substitution      : FiniteMapSubstitution 
       infoTuple         : {(ConstraintSet, LocalInfo)}
       metaVariableTable : {MetaVariableTable LocalInfo} 
     | 
     | ftv USE {++} {[]} : {[Int]} 
     ]

SEM Core_UserStatement 
  | Constraint  lhs . ftv = ftv [@leftType, @rightType]

SEM Core_Judgement
  | Judgement   lhs . ftv = ftv @type

ATTR Core_UserStatements Core_UserStatement 
     [ attributeTable     : {[((String, Maybe String), MessageBlock)]}
     | collectConstraints : {Trees (TypeConstraint ConstraintInfo)} 
       currentPhase       : {Maybe Int} 
       currentPosition    : {(Int, Int)}
       metavarConstraints : {[(String,Tree (TypeConstraint ConstraintInfo))]}
     | 
     ]

SEM Core_TypingStrategy 
  | TypingStrategy
       loc        . allConstraintTrees = listTree (reverse @typerule.constraints) :
                                         (map snd @statements.metavarConstraints) ++
                                         (reverse @statements.collectConstraints)
       statements . collectConstraints = []
                  . currentPhase       = Nothing
                  . currentPosition    = (@lhs.unique, 0)
                  . metavarConstraints = [ (s,cs) | (s,(cs,_)) <- @lhs.metaVariableTable ] 
                  . attributeTable     = makeAttributeTable (snd @lhs.infoTuple) @lhs.metaVariableTable @substitution

SEM Core_UserStatement
  | Constraint
       lhs . currentPosition    = (\(x, y) -> (x, y+1)) @lhs.currentPosition 
           . collectConstraints = case @lhs.currentPhase of
                                     Just phase | phase /= 5 
                                                -> Phase phase [ @newConstraint ] : @lhs.collectConstraints
                                     _          -> unitTree @newConstraint : @lhs.collectConstraints
       
  | MetaVariableConstraints        
       lhs . metavarConstraints = filter ((@name /=) . fst) @lhs.metavarConstraints
           . collectConstraints = case lookup @name @lhs.metavarConstraints of
                                      Just tree -> tree : @lhs.collectConstraints
                                      Nothing   -> internalError "TS_Apply.ag" "n/a" "unknown constraint set"
                                      
  | CorePhase 
       lhs . currentPhase = Just @phase                  

SEM Core_UserStatement
  | Constraint  
       loc . newConstraint = 
          let cinfo   = addProperty (WithTypeError (TypeError [] message [] []))
                      . addProperty (uncurry IsUserConstraint @lhs.currentPosition)
                      . inPhase
                      . emptyConstraintInfo
              inPhase = case @lhs.currentPhase of
                           Just phase | phase /= 5
                              -> addProperty (ConstraintPhaseNumber phase)
                           _  -> id 
              message = let f = MessageOneLiner . MessageCompose . substituteAttributes (makeMessageAlgebra @lhs.attributeTable)
                        in map f (lines @message)                
          in (@lhs.substitution |-> @leftType .==. @lhs.substitution |-> @rightType) cinfo

{
emptyConstraintInfo :: (Tp, Tp) -> ConstraintInfo
emptyConstraintInfo tppair =
   CInfo { location   = "Typing Strategy"
         , sources    = (UHA_Decls [], Nothing)
         , typepair   = tppair
         , localInfo  = root (LocalInfo (UHA_Decls []) Nothing []) []
         , properties = []
         }
}

ATTR Core_TypeRule [ | | constraints : {TypeConstraints ConstraintInfo} ]

SEM Core_TypeRule             
  | TypeRule        
       lhs .  constraints = let conclusionSource = self       (snd @lhs.infoTuple)
                                conclusionType   = getTheType (snd @lhs.infoTuple)
                            in [ (@lhs.substitution |-> tp1 .==. conclusionType) 
                                    (addProperty FolkloreConstraint . defaultConstraintInfo (conclusionSource, Nothing))
                               | (_, tp1) <- @conclusion.judgements
                               ]
                               ++
                               [ (getTheType mvinfo .==. @lhs.substitution |-> tp1) 
                                    (defaultConstraintInfo (conclusionSource, Just (self mvinfo)))
                               | (s1, tp1)         <- @premises.judgements 
                               , (s2, (_, mvinfo)) <- @lhs.metaVariableTable
                               , s1 == s2
                               ]

{
defaultConstraintInfo :: (UHA_Source, Maybe UHA_Source) -> (Tp, Tp) -> ConstraintInfo
defaultConstraintInfo sourceTuple@(s1, s2) tppair =
   CInfo { location   = descriptionOfSource theSource -- not very precise: expression, pattern, etc.
         , sources    = sourceTuple
         , localInfo  = root myLocal []
         , typepair   = tppair
         , properties = []
         }
 where myLocal   = LocalInfo {self = theSource, assignedType = Nothing, monos = []}
       theSource = maybe s1 id s2
       
exactlyOnce :: Eq a => [a] -> [a]
exactlyOnce []     = []
exactlyOnce (x:xs) | x `elem` xs = exactlyOnce . filter (/= x) $ xs
                   | otherwise   = x : exactlyOnce xs

makeMessageAlgebra :: AttributeTable MessageBlock -> AttributeAlgebra MessageBlock
makeMessageAlgebra table = 
   (MessageString, table, \a -> internalError "TS_Apply" "makeMessageAlgebra" ("unknown attribute " ++ showAttribute a))

makeAttributeTable :: LocalInfo -> MetaVariableTable LocalInfo -> FiniteMapSubstitution -> [((String, Maybe String), MessageBlock)]
makeAttributeTable local table substitution = 
   let 
       metaVariables :: [(String, LocalInfo)]
       metaVariables = ("expr", local) : [ (s, li) | (s, (_, li)) <- table ]
       
       attributes :: [(String, LocalInfo -> MessageBlock)]
       attributes = 
          [ ("type" , MessageType . toTpScheme . getTheType)
          , ("pp"   , MessageOneLineTree . oneLinerSource . self)
          , ("range", MessageRange . rangeOfSource . self)
          ]
   in 
      [ ((mv, Just attr), f li) | (mv, li) <- metaVariables, (attr, f) <- attributes ]
   ++ [ ((show i, Nothing), MessageType (toTpScheme (substitution |-> TVar i))) | i <- dom substitution ]  
}

ATTR Core_Judgements Core_Judgement Core_TypeRule [ | | judgements USE {++} {[]} : {[(String, Tp)]} ]

SEM Core_Judgement
  | Judgement
       lhs . judgements = [(@expression, @type)]     
