-------------------------------------------------------------------------------
--
--   *** The Helium Compiler : Static Analysis ***
--               ( Bastiaan Heeren )
--
-- TypeInferencing.ag : A type inferencer for Helium.
--
-------------------------------------------------------------------------------

INCLUDE "inferencers/TypeInferencingInfo.ag"
INCLUDE "staticchecks/HeliumPartialSyntax.ag"
INCLUDE "staticchecks/Collect.ag"

imports {

-- standard
import Monad                   ( when )
import List                    ( intersperse, partition, nub, zipWith4, union )
-- types
import Types
import TypeConversion
-- constraints
import Constraints
import LiftedConstraints
import ConstraintTree
import Strategy
-- messages
import Messages
-- solvers
import SolveConstraints 
import SolveEquivalenceGroups  ( solveEquivalenceGroups )
import SolveGreedy             ( solveGreedy )
import ConstraintInfo
import TypeGraphConstraintInfo
import EquivalenceGroupsImplementation ( ) -- only import instance declaration
import HeliumConstraintInfo
-- common
import EnvironmentSynonyms
import SortedAssocList
-- other
import TopSort                 ( topSort )
import Utils                   ( internalError )
import UHA_Utils               ( noRange, getNameRange, getExprRange )
import DerivingShow            ( typeOfShowFunction, nameOfShowFunction ) 

}

----------------------------------------------------------------------------------------
-- Type Inferencing : Module

SEM Module

  | Module
      body . betaUnique  = 0
      loc  . debugIO     = do putStrLn "--- Debug Info ---"
                              putStrLn $ unlines $ map show @constraints
                              putStrLn $ "type variables in constraint set: "++show @body.betaUnique
                              putStrLn $ "type variables used while solving: "++show @betaUniqueAtTheEnd
                              putStrLn $ "constraints in set: "++show (length @constraints)
                              when @filteredBool (putStrLn ("WARNING: Filtered type errors"))
                              @solveDebug
                                
      loc  . constraints = zipWith setPosition [0..] (ctRoot @body.constraints @lhs.strategy)
           . (betaUniqueAtTheEnd,substitution,solveErrors,solveDebug) 
                  = -- choose your algorithm to solve the type constraints
                    (if @lhs.useTypeGraph then solveEquivalenceGroups else solveGreedy) 
                       @body.betaUnique [ SolveWithTypeSynonyms @orderedTypeSynonyms 
                                        , SolveWithTypeSignatures . map (\(n,ts) -> (show n,ts)) $
                                             (  toList @lhs.importTypeEnv 
                                             ++ toList @lhs.importConstructorEnv
                                             ++ toList @body.derivedFunctions
                                             )
                                        ]
                                        @constraints

           . inferredgamma = mapElt ( generalizeAll . (@substitution |->) ) @body.environment

           . (typeErrors,filteredBool)    
                  = let notGeneralEnoughErrors = 
                           let f ((m,t),s2,info) = let m' = @substitution |-> m
                                                       t' = @substitution |-> t
                                                       s1 = generalize (ftv m') t'
                                                   in NotGeneralEnough s1 s2 info
                                                   
                               p (NotGeneralEnough s1 s2 info) = 
                                     not (genericInstanceOf @orderedTypeSynonyms s2 s1) 
                                  && unifiableTypeSchemes   @orderedTypeSynonyms s1 s2
                                  
                           in filter p (map f @body.typeAnnotations)
                        
                        op typeError (list,bool) = -- extra check: are the reported types still not unifiable? 
                                                   case checkTypeError @orderedTypeSynonyms typeError of
                                                      Just t  -> (t:list,bool) 
                                                      Nothing -> (list,True)
                        
                    in foldr op (notGeneralEnoughErrors,False) (map makeTypeError @solveErrors)
            
           . toplevelTypes = @body.typeSignatures `combine` @inferredgamma

---------------------------------------------------------------------------------------
-- Type Inferencing : Body

ATTR Body
    [ importTypeEnv         : TypeEnvironment
    | betaUnique            : Int
    | assumptions           : Assumptions
      constraints           : ConstraintSet
      environment           : PatternAssumptions
    ]

SEM Body
  | Body
      lhs          . constraints    = ctNode [ @csetBinds .<<. @cset ]
                   . assumptions    = @aset'
                   . environment    = @env
      declarations . bindingGroups  = []
                   . monos          = []
                   
      loc . (env,aset,cset,monoTable,tiErrors,tiWarnings,tiNoTypeDefinition,anns) = 
               performAndCheckBindingGroup True [] @declarations.typeSignatures emptyBindingGroup @declarations.bindingGroups
               
          . (csetBinds,aset') = (combine @declarations.derivedFunctions @lhs.importTypeEnv .:::. @aset) @cinfo

---------------------------------------------------------------------------------------
-- Type Inferencing : Declaration, Declarations, MaybeDeclarations

ATTR Declaration Declarations MaybeDeclarations
    [ monos         : Tps
    | betaUnique    : Int
    |
    ]
ATTR Declaration Declarations
    [ monoTable     : MonoTable
    | bindingGroups : BindingGroups
    |
    ]
ATTR MaybeDeclarations
    [
    | assumptions   : Assumptions
      constraints   : ConstraintSet
    |
    ]

SEM Declaration

  | FunctionBindings
      lhs      . bindingGroups = @mybdggrp : @lhs.bindingGroups
      bindings . betaUnique    = @lhs.betaUnique + 2 + @bindings.numberOfPatterns
               . monos         = findMono @beta @lhs.monoTable ++ @lhs.monos
      loc      . beta          = TVar @lhs.betaUnique
               . betaRight     = TVar (@lhs.betaUnique + 1)
               . betasLeft     = take @bindings.numberOfPatterns (map TVar [@lhs.betaUnique + 2..])
               . newcon        = [ (@beta .==. foldr (.->.) @betaRight @betasLeft) @cinfo ]
               . mybdggrp      = ( single @bindings.name @beta
                                 , @bindings.assumptions
                                 , [ @newcon !<!
                                     ctNode [ ctVariable @lhs.betaUnique
                                            , ctNode @bindings.constraintslist
                                            ]
                                   ]
                                 )

  | PatternBinding
      lhs           . bindingGroups = @mybdggrp : @lhs.bindingGroups
      righthandside . monos         = findMono (head (elts @pattern.environment)) @lhs.monoTable ++ @lhs.monos
      loc           . newcon        = [ (@righthandside.beta .==. @pattern.beta) @cinfo ]
                    . mybdggrp      = ( @pattern.environment
                                      , @righthandside.assumptions
                                      , [ @newcon .>.
                                          ctNode [ @pattern.constraints
                                                 , @righthandside.constraints
                                                 ]
                                        ]
                                      )

SEM MaybeDeclarations
  | Just
      lhs          . assumptions    = @aset
                   . constraints    = @cset
      declarations . bindingGroups  = []
                   . typeSignatures = empty
                   
      loc          . (env,aset,cset,monoTable,tiErrors,tiWarnings,tiNoTypeDefinition,anns) = 
                        performAndCheckBindingGroup False @lhs.monos @declarations.typeSignatures @mybdggroup @declarations.bindingGroups
                        
                   . mybdggroup     = (empty,@lhs.assumptions,[@lhs.constraints])

---------------------------------------------------------------------------------------
-- Type Inferencing : FunctionBinding, FunctionBindings

ATTR FunctionBinding FunctionBindings [ betasLeft:Tps betaRight:Tp monos:Tps | betaUnique:Int | assumptions:Assumptions numberOfPatterns:Int name:Name ]
ATTR FunctionBinding                  [ | | constraints:ConstraintSet]
ATTR                 FunctionBindings [ | | constraintslist:ConstraintSets]

SEM FunctionBinding

  | FunctionBinding
      lhs           . assumptions = @assumptions'
                    . constraints = @csetBinds .>>.
                                    ctNode [ @conLeft  .<. @lefthandside.constraints
                                           , @conRight .<. @righthandside.constraints
                                           ]
      righthandside . monos       = elts @lefthandside.environment ++ @lhs.monos
      loc           . (csetBinds,assumptions',duplicated,unused) = (@lefthandside.environment !===! @righthandside.assumptions) @cinfoBind
                    . conLeft     = zipWith4 (\t1 t2 txt nr -> (t1 .==. t2) (@cinfoLeft nr txt)) @lefthandside.betas @lhs.betasLeft @lefthandside.patternTrees [0..]
                    . conRight    = [ (@righthandside.beta .==. @lhs.betaRight) @cinfoRight ]

SEM FunctionBindings

  | Cons
      lhs . assumptions      = @hd.assumptions `combine` @tl.assumptions
          . numberOfPatterns = @hd.numberOfPatterns
          . name             = @hd.name
          . constraintslist  = @hd.constraints : @tl.constraintslist
  | Nil
      lhs . assumptions      = empty
          . numberOfPatterns = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(1)"
          . name             = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(2)"
          . constraintslist  = []

---------------------------------------------------------------------------------------
-- Type Inferencing : LeftHandSide, RightHandSide

ATTR LeftHandSide RightHandSide [ | betaUnique:Int | constraints:ConstraintSet ]
ATTR LeftHandSide               [ | | betas:Tps environment:PatternAssumptions numberOfPatterns:Int name:Name ]
ATTR              RightHandSide [ monos:Tps | | assumptions:Assumptions beta:Tp ]

SEM LeftHandSide

  | Function
      lhs . constraints      = ctNode @patterns.constraintslist
          . name             = @name.self

  | Infix
      lhs . numberOfPatterns = 2
          . environment      = @leftPattern.environment `combine` @rightPattern.environment
          . betas            = [@leftPattern.beta,@rightPattern.beta]
          . constraints      = ctNode [ @leftPattern.constraints
                                      , @rightPattern.constraints
                                      ]
          . name             = @operator.self

  | Parenthesized 
      lhs . numberOfPatterns = @lefthandside.numberOfPatterns + @patterns.numberOfPatterns
          . environment      = @lefthandside.environment `combine` @patterns.environment
          . betas            = @lefthandside.betas ++ @patterns.betas
          . constraints      = ctNode ( @lefthandside.constraints : @patterns.constraintslist )

SEM RightHandSide

  | Expression
     lhs   . assumptions = @where.assumptions
           . constraints = @where.constraints
     where . assumptions = @expression.assumptions
           . constraints = @expression.constraints

  | Guarded
     lhs                . assumptions = @where.assumptions
                        . constraints = @where.constraints
     guardedexpressions . betaUnique  = @lhs.betaUnique + 1
                        . rightBeta   = @beta
     where              . assumptions = @guardedexpressions.assumptions
                        . constraints = ctNode @guardedexpressions.constraintslist
     loc                . beta        = TVar @lhs.betaUnique

---------------------------------------------------------------------------------------
-- Type Inferencing : Expression, Expressions, MaybeExpression, GuardedExpression, GuardedExpressions

ATTR Expression Expressions MaybeExpression GuardedExpression GuardedExpressions [ monos:Tps | betaUnique:Int | assumptions:Assumptions ]
ATTR Expression                             GuardedExpression                    [ | | beta:Tp constraints:ConstraintSet ]
ATTR            Expressions                                   GuardedExpressions [ | | betas:Tps constraintslist:ConstraintSets ]
ATTR                        MaybeExpression                                      [ | | beta:Tp constraints:ConstraintSet section:Bool ]
ATTR                                        GuardedExpression GuardedExpressions [ rightBeta:Tp | | ]

SEM Expression

  | Literal
      lhs . betaUnique  = @lhs.betaUnique + 1
          . assumptions = empty
          . constraints = ctSingle [ (@literal.literalType .==. @beta) @cinfo ]
      loc . beta        = TVar @lhs.betaUnique

  | Constructor
      lhs . betaUnique   = @lhs.betaUnique + 1
          . assumptions  = empty
          . constraints  = ctSingle @newcon
      loc . beta         = TVar @lhs.betaUnique
          . maybetp      = lookupAL @name.self @lhs.constructorenv
          . newcon       = case @maybetp of
                              Nothing  -> []
                              Just ctp -> [ (@beta .::. ctp) @cinfo ]

  | Variable
      lhs . betaUnique  = @lhs.betaUnique + 1
          . assumptions = @name.self `single` @beta
          . constraints = ctNode [ ctVariable @lhs.betaUnique ]
      loc . beta        = TVar @lhs.betaUnique

  | NormalApplication
      lhs      . assumptions = @function.assumptions `combine` @arguments.assumptions
               . constraints = @newcon .>.
                               ctNode [ @function.constraints
                                      , ctNode @arguments.constraintslist
                                      ]
      function . betaUnique  = @lhs.betaUnique + 1
      loc      . beta        = TVar @lhs.betaUnique
               . newcon      = [ (@function.beta .==. foldr (.->.) @beta @arguments.betas) @cinfo ]

  | InfixApplication
      lhs            . assumptions = @leftExpression.assumptions `combine` @operator.assumptions `combine` @rightExpression.assumptions
                     . constraints = @conResult .>. @conOperator .>.
                                     ctNode [ @operator.constraints
                                            , @leftExpression.constraints
                                            , @rightExpression.constraints
                                            ]
      leftExpression . betaUnique  = @lhs.betaUnique + 2
      loc            . beta        = TVar @lhs.betaUnique
                     . betaResOp   = TVar (@lhs.betaUnique + 1)
                     . conOperator = [ (@operator.beta .==. @leftExpression.beta .->. @rightExpression.beta .->. @betaResOp) @cinfoOperator ]
                     . conResult   = case (@leftExpression.section,@rightExpression.section) of
                                            (False,False) -> [ (@betaResOp     .==. @beta) @cinfoComplete  ]
                                            (True ,True ) -> [ (@operator.beta .==. @beta) @cinfoEmpty ]
                                            _             -> internalError "TypeInferencing.ag" "n/a" "sections are not supported by the type-checker"


  | If
      lhs             . assumptions = @guardExpression.assumptions `combine` @thenExpression.assumptions `combine` @elseExpression.assumptions
                      . constraints = ctNode [ @conGuard .<. @guardExpression.constraints
                                             , @conThen  .<. @thenExpression.constraints
                                             , @conElse  .<. @elseExpression.constraints
                                             ]
      guardExpression . betaUnique  = @lhs.betaUnique + 1
      loc             . beta        = TVar @lhs.betaUnique
                      . conGuard    = [ (@guardExpression.beta .==. boolType) @cinfoGuard ]
                      . conThen     = [ (@thenExpression.beta  .==. @beta   ) @cinfoThen  ]
                      . conElse     = [ (@elseExpression.beta  .==. @beta   ) @cinfoElse  ]

  | Lambda
      lhs        . assumptions = @assumptions'
                 . constraints = @newcon .>. @csetBinds .>>.
                                 ctNode [ ctNode @patterns.constraintslist
                                        , @expression.constraints
                                        ]
      patterns   . betaUnique  = @lhs.betaUnique + 1
      expression . monos       = elts @patterns.environment ++ @lhs.monos
      loc        . beta        = TVar @lhs.betaUnique
                 . (csetBinds,assumptions',duplicated,unused) = (@patterns.environment !===! @expression.assumptions) @cinfoBind
                 . newcon      = [ (foldr (.->.) @expression.beta @patterns.betas .==. @beta) @cinfoType ]

  | Case
      lhs          . assumptions = @expression.assumptions `combine` @alternatives.assumptions
                   . constraints = ctNode [ @newcon .<. @expression.constraints
                                          , ctNode @alternatives.constraintslist
                                          ]
      expression   . betaUnique  = @lhs.betaUnique + 2
      alternatives . betaLeft    = @beta'
                   . betaRight   = @beta
      loc          . beta        = TVar @lhs.betaUnique
                   . beta'       = TVar (@lhs.betaUnique + 1)
                   . newcon      = [ (@expression.beta .==. @beta') @cinfo ]

  | Let
      lhs          . assumptions    = @aset
                   . constraints    = [ (@expression.beta .==. @beta) @cinfoType ] .>. @cset
      declarations . betaUnique     = @lhs.betaUnique + 1
                   . bindingGroups  = []
      loc          . beta           = TVar @lhs.betaUnique
                   . mybdggroup     = (empty,@expression.assumptions,[@expression.constraints])
                   
                   . (env,aset,cset,monoTable,tiErrors,tiWarnings,tiNoTypeDefinition,anns) = 
                        performAndCheckBindingGroup False @lhs.monos @declarations.typeSignatures @mybdggroup @declarations.bindingGroups

  | Do
      lhs        . constraints   = ctNode [ @newcon .<. @statements.constraints ]
      statements . betaUnique    = @lhs.betaUnique + 1
                 . generatorBeta = Nothing
                 . assumptions   = empty
                 . constraints   = ctEmpty
      loc        . beta          = TVar @lhs.betaUnique
                 . newcon        = case @statements.generatorBeta of
                                      Nothing -> []
                                      Just b  -> [ (b .==. @beta) @cinfo ]

  | List
      lhs         . constraints = @newcon .>.
                                  ctNode (zipWith3 @zipf @expressions.betas @expressions.oneLineTree @expressions.constraintslist)
      expressions . betaUnique  = @lhs.betaUnique + 2
      loc         . beta        = TVar @lhs.betaUnique
                  . beta'       = TVar (@lhs.betaUnique + 1)
                  . newcon      = [ (listType @beta' .==. @beta) @cinfoResult ]
                  . zipf        = \tp txt ctree -> [ (tp .==. @beta') (@cinfoElem txt) ] .<. ctree

  | Tuple
      lhs         . constraints = @newcon .>. ctNode @expressions.constraintslist
      expressions . betaUnique  = @lhs.betaUnique + 1
      loc         . beta        = TVar @lhs.betaUnique
                  . newcon      = [ (tupleType @expressions.betas .==. @beta) @cinfo ]

  | Typed
      lhs        . constraints = @conResult .>.
                                 ctNode [ @conExpr .<. @expression.constraints ]
      expression . betaUnique  = @lhs.betaUnique + 1
      loc        . beta        = TVar @lhs.betaUnique
                 . typeScheme  = makeTpSchemeFromType @type.self 
                 . conResult   = [ (@beta            .::. @typeScheme) @cinfoResult ]
                 . conExpr     = [ (@expression.beta .::. @typeScheme) @cinfoExpr   ]

  | Comprehension
      lhs        . assumptions = @qualifiers.assumptions
                 . constraints = @newcon .>. ctNode [ @qualifiers.constraints ]
      expression . betaUnique  = @lhs.betaUnique + 1
                 . monos       = @qualifiers.monos
      qualifiers . assumptions = @expression.assumptions
                 . constraints = @expression.constraints
                 . monos       = @lhs.monos
      loc        . beta        = TVar @lhs.betaUnique
                 . newcon      = [ (listType @expression.beta .==. @beta) @cinfo ]

  | Enum
       lhs  . constraints = [ (listType intType .==. @beta) @cinfoResult ] .>.
                            ctNode [ @conFrom .<. @from.constraints
                                   , @conThen .<. @then.constraints
                                   , @conTo   .<. @to.constraints
                                   ]
            . assumptions = @from.assumptions `combine` @then.assumptions `combine` @to.assumptions
       from . betaUnique  = @lhs.betaUnique + 1
       loc  . beta        = TVar @lhs.betaUnique
            . conFrom     = [ (@from.beta .==. intType) @cinfoFrom ]
            . conThen     = [ (@then.beta .==. intType) @cinfoThen ]
            . conTo       = [ (@to.beta   .==. intType) @cinfoTo   ]

  | Negate
       lhs        . constraints = @conResult .>. ctNode [ @conExpr .<. @expression.constraints ]
       expression . betaUnique  = @lhs.betaUnique + 1
       loc        . beta        = TVar @lhs.betaUnique
                  . conResult   = [ (intType .==. @beta) @cinfoResult ]
                  . conExpr     = [ (@expression.beta .==. intType) @cinfoExpr]

  | NegateFloat
       lhs        . constraints = @conResult .>. ctNode [ @conExpr .<. @expression.constraints ]
       expression . betaUnique  = @lhs.betaUnique + 1
       loc        . beta        = TVar @lhs.betaUnique
                  . conResult   = [ (floatType .==. @beta) @cinfoResult ]
                  . conExpr     = [ (@expression.beta .==. floatType) @cinfoExpr]

SEM Expressions

  | Cons
      lhs . betas           = @hd.beta : @tl.betas
          . assumptions     = @hd.assumptions `combine` @tl.assumptions
          . constraintslist = @hd.constraints : @tl.constraintslist

  | Nil
      lhs . betas           = []
          . assumptions     = empty
          . constraintslist = []

SEM MaybeExpression

  | Just
      lhs . section = False

  | Nothing
      lhs . section     = True
          . betaUnique  = @lhs.betaUnique + 1
          . assumptions = empty
          . constraints = ctEmpty
      loc . beta        = TVar @lhs.betaUnique

SEM GuardedExpression

  | GuardedExpression
      lhs . beta        = @expression.beta
          . constraints = ctNode [ @newconGuard .<. @guard.constraints
                                 , @newconExpr  .<. @expression.constraints
                                 ]
          . assumptions = @guard.assumptions `combine` @expression.assumptions
      loc . newconGuard = [ (@guard.beta .==. boolType) @cinfoGuard ]
          . newconExpr  = [ (@expression.beta .==. @lhs.rightBeta) @cinfoExpr ]

SEM GuardedExpressions

  | Cons
      lhs . betas           = @hd.beta : @tl.betas
          . assumptions     = @hd.assumptions `combine` @tl.assumptions
          . constraintslist = @hd.constraints : @tl.constraintslist

  | Nil
      lhs . betas           = []
          . assumptions     = empty
          . constraintslist = []


---------------------------------------------------------------------------------------
-- Type Inferencing : Pattern

ATTR Pattern Patterns [ | betaUnique:Int | environment:PatternAssumptions ]
ATTR Pattern          [ | | beta:Tp constraints:ConstraintSet ]
ATTR         Patterns [ | | betas:Tps constraintslist:ConstraintSets numberOfPatterns:Int ]

SEM Pattern

  | Literal
      lhs . betaUnique  = @lhs.betaUnique + 1
          . environment = empty
          . constraints = ctSingle [ (@literal.literalType .==. @beta) @cinfo ]
      loc . beta        = TVar @lhs.betaUnique

  | Variable
      lhs . betaUnique  = @lhs.betaUnique + 1
          . environment = single @name.self @beta
          . constraints = ctVariable @lhs.betaUnique
      loc . beta        = TVar @lhs.betaUnique

  | InfixConstructor
      lhs         . constraints    = @conApply .>.
                                     ctNode [ ctSingle @conConstructor
                                            , @leftPattern.constraints
                                            , @rightPattern.constraints
                                            ]
                  . environment    = @leftPattern.environment `combine` @rightPattern.environment
      leftPattern . betaUnique     = @lhs.betaUnique + 2
      loc         . beta           = TVar @lhs.betaUnique
                  . betaCon        = TVar (@lhs.betaUnique + 1)
                  . maybetp        = lookupAL @constructorOperator.self @lhs.constructorenv
                  . conApply       = [ (@betaCon .==. @leftPattern.beta .->. @rightPattern.beta .->. @beta) @cinfoApply ]
                  . conConstructor = case @maybetp of
                                        Nothing  -> []
                                        Just ctp -> [ (@betaCon .::. ctp) @cinfoConstructor ]

  | Constructor
      lhs      . constraints    = @conApply .>.
                                  ctNode [ ctSingle @conConstructor
                                         , ctNode @patterns.constraintslist
                                         ]
      patterns . betaUnique     = @lhs.betaUnique + 2
      loc      . beta           = TVar (@lhs.betaUnique)
               . betaCon        = TVar (@lhs.betaUnique + 1)
               . maybetp        = lookupAL @name.self @lhs.constructorenv
               . conApply       = [ (@betaCon .==. foldr (.->.) @beta @patterns.betas) @cinfoApply ]
               . conConstructor = case @maybetp of
                                     Nothing  -> []
                                     Just ctp -> [ (@betaCon .::. ctp) @cinfoConstructor ]

  | As
      lhs     . environment = add @name.self @beta @pattern.environment
              . constraints = @newcon .>.
                              ctNode [ ctVariable @lhs.betaUnique
                                     , @pattern.constraints
                                     ]
      pattern . betaUnique  = @lhs.betaUnique + 1
      loc     . beta        = TVar @lhs.betaUnique
              . newcon      = [ (@beta .==. @pattern.beta) @cinfo ]

  | Wildcard
      lhs . betaUnique  = @lhs.betaUnique + 1
          . environment = empty
          . constraints = ctEmpty
      loc . beta        = TVar @lhs.betaUnique

  | List
      lhs      . constraints = @newcon .>.
                               ctNode (zipWith3 @zipf @patterns.betas @patterns.oneLineTree @patterns.constraintslist)
      patterns . betaUnique  = @lhs.betaUnique + 2
      loc      . beta        = TVar @lhs.betaUnique
               . beta'       = TVar (@lhs.betaUnique + 1)
               . newcon      = [ (listType @beta' .==. @beta) @cinfoResult ]
               . zipf        = \tp txt ctree -> [ (tp .==. @beta') (@cinfoElem txt) ] .<. ctree

  | Tuple
      lhs      . constraints = @newcon .>. ctNode @patterns.constraintslist
      patterns . betaUnique  = @lhs.betaUnique + 1
      loc      . beta        = TVar @lhs.betaUnique
               . newcon      = [ (tupleType @patterns.betas .==. @beta) @cinfo ]

  | Negate
      lhs . constraints = @conResult .>. ctNode [ ctSingle @conPat ]
          . betaUnique  = @lhs.betaUnique + 1
          . environment = empty
      loc . beta        = TVar @lhs.betaUnique
          . conResult   = [ (intType .==. @beta) @cinfoResult ]
          . conPat      = [ (@literal.literalType .==. intType) @cinfoPat ]

  | NegateFloat
      lhs . constraints = @conResult .>. ctNode [ ctSingle @conPat ]
          . betaUnique  = @lhs.betaUnique + 1
          . environment = empty
      loc . beta        = TVar @lhs.betaUnique
          . conResult   = [ (floatType .==. @beta) @cinfoResult ]
          . conPat      = [ (@literal.literalType .==. floatType) @cinfoPat ]

SEM Patterns

  | Cons
      lhs . betas            = @hd.beta : @tl.betas
          . environment      = @hd.environment `combine` @tl.environment
          . numberOfPatterns = 1 + @tl.numberOfPatterns
          . constraintslist  = @hd.constraints : @tl.constraintslist

  | Nil
      lhs . betas            = []
          . environment      = empty
          . numberOfPatterns = 0
          . constraintslist  = []

---------------------------------------------------------------------------------------
-- Type Inferencing : Alternative, Alternatives

ATTR Alternative Alternatives [ betaLeft:Tp betaRight:Tp monos:Tps | betaUnique:Int | assumptions:Assumptions ]
ATTR Alternative              [ | | constraints:ConstraintSet ]
ATTR             Alternatives [ | | constraintslist:ConstraintSets ]

SEM Alternative

  | Alternative
      lhs           . constraints = @csetBinds .>>.
                                    ctNode [ @conLeft  .<. @pattern.constraints
                                           , @conRight .<. @righthandside.constraints
                                           ]
                    . assumptions = @assumptions'
      righthandside . monos       = elts @pattern.environment ++ @lhs.monos
      loc           . (csetBinds,assumptions',duplicated,unused) = (@pattern.environment !===! @righthandside.assumptions) @cinfoBind
                    . conLeft     = [ (@pattern.beta .==. @lhs.betaLeft) @cinfoLeft ]
                    . conRight    = [ (@righthandside.beta .==. @lhs.betaRight) @cinfoRight ]

  | Empty
      lhs . assumptions = empty
          . constraints = ctEmpty

SEM Alternatives

  | Cons
      lhs . assumptions     = @hd.assumptions `combine` @tl.assumptions
          . constraintslist = @hd.constraints : @tl.constraintslist

  | Nil
      lhs . assumptions     = empty
          . constraintslist = []

---------------------------------------------------------------------------------------
-- Type Inferencing : Statement, Statements, Qualifier, Qualifiers

ATTR Statement Statements Qualifier Qualifiers [ | assumptions:Assumptions betaUnique:Int constraints:ConstraintSet | ]
ATTR Statement Statements                      [ | generatorBeta:{Maybe Tp} | ]
ATTR Statement            Qualifier Qualifiers [ | monos:Tps | ]
ATTR           Statements                      [ monos:Tps | | ]

SEM Statement

  | Expression
      lhs        . generatorBeta = Just @expression.beta
                 . constraints   = ctNode [ @newcon .<. @expression.constraints
                                          , @lhs.constraints
                                          ]
                 . assumptions   = @lhs.assumptions `combine` @expression.assumptions
      expression . betaUnique    = @lhs.betaUnique + 1
      loc        . beta          = TVar @lhs.betaUnique
                 . newcon        = [ (@expression.beta .==. ioType @beta) @cinfo ]

  | Let
      lhs          . generatorBeta  = Nothing
                   . assumptions    = @aset
                   . constraints    = @cset    
      declarations . bindingGroups  = []
      
      loc          . (env,aset,cset,monoTable,tiErrors,tiWarnings,tiNoTypeDefinition,anns) = 
                        performAndCheckBindingGroup False @lhs.monos @declarations.typeSignatures @mybdggroup @declarations.bindingGroups
                        
                   . mybdggroup     = (empty,@lhs.assumptions,[@lhs.constraints])

  | Generator
      lhs . generatorBeta = Nothing
          . constraints   = @newcon .>. @csetBinds .>>.
                            ctNode [ @pattern.constraints
                                   , @expression.constraints
                                   , @lhs.constraints
                                   ]
          . assumptions   = @assumptions' `combine` @expression.assumptions
          . monos         = elts @pattern.environment ++ @lhs.monos
      loc . (csetBinds,assumptions',duplicated,unused) = (@pattern.environment !===! @lhs.assumptions) @cinfoBind
          . newcon        = [ (@expression.beta .==. ioType @pattern.beta) @cinfoResult ]

SEM Statements

  | Cons
      lhs . assumptions = @hd.assumptions
          . constraints = @hd.constraints
      hd  . assumptions = @tl.assumptions
          . constraints = @tl.constraints
      tl  . assumptions = @lhs.assumptions
          . constraints = @lhs.constraints

SEM Qualifier

  | Guard
      lhs . assumptions = @lhs.assumptions `combine` @guard.assumptions
          . constraints = ctNode [ @newcon .<. @guard.constraints
                                 , @lhs.constraints
                                 ]
      loc . newcon      = [ (@guard.beta .==. boolType) @cinfo ]

  | Let   lhs          . assumptions    = @aset
                       . constraints    = @cset
          declarations . bindingGroups  = []
          
          loc          . (env,aset,cset,monoTable,tiErrors,tiWarnings,tiNoTypeDefinition,anns) = 
                            performAndCheckBindingGroup False @lhs.monos @declarations.typeSignatures @mybdggroup @declarations.bindingGroups
                            
                       . mybdggroup     = (empty,@lhs.assumptions,[@lhs.constraints])

  | Generator
      lhs . assumptions = @assumptions' `combine` @expression.assumptions
          . constraints = @newcon .>. @csetBinds .>>.
                          ctNode [ @pattern.constraints
                                 , @expression.constraints
                                 , @lhs.constraints
                                 ]
          . monos       = elts @pattern.environment ++ @lhs.monos
      loc . (csetBinds,assumptions',duplicated,unused) = (@pattern.environment !===! @lhs.assumptions) @cinfoBind
          . newcon      = [ (@expression.beta .==. listType @pattern.beta) @cinfoResult ]

SEM Qualifiers

  | Cons
      lhs . assumptions = @hd.assumptions
          . constraints = @hd.constraints
      hd  . assumptions = @tl.assumptions
          . constraints = @tl.constraints
      tl  . assumptions = @lhs.assumptions
          . constraints = @lhs.constraints

---------------------------------------------------------------------------------------
-- Type Inferencing : Literal

ATTR Literal [ | | literalType:Tp ]

SEM Literal
  | Int     lhs . literalType = intType
  | Char    lhs . literalType = charType
  | String  lhs . literalType = stringType
  | Float   lhs . literalType = floatType

-------------------------------------------
-- Collecting Type Signatures

ATTR Declaration Declarations [ | typeSignatures:TypeEnvironment | ]
ATTR Body                     [ | | typeSignatures:TypeEnvironment ]

SEM Body       | Body    declarations . typeSignatures = empty
SEM Expression | Let     declarations . typeSignatures = empty
SEM Statement  | Let     declarations . typeSignatures = empty
SEM Qualifier  | Let     declarations . typeSignatures = empty

SEM Declaration
  | TypeSignature
      lhs . typeSignatures = foldr (uncurry add) @lhs.typeSignatures [ (n,@typeScheme) | n <- @names.self ]
      loc . typeScheme     = makeTpSchemeFromType @type.self

-------------------------------------------
-- Collecting all Type Annotations (or: explicit type signatures)

ATTR Declarations Expression MaybeDeclarations RightHandSide Statement Statements
     RecordExpressionBindings RecordExpressionBinding Qualifier Qualifiers MaybeExpression
     GuardedExpression FunctionBinding FunctionBindings GuardedExpressions
     Expressions Declaration Alternative Alternatives Body
     [ | typeAnnotations:{[((Tps,Tp),TpScheme,(Tree,Range))]} | ]

SEM Module
  | Module   body . typeAnnotations = []

SEM Expression
  | Typed  lhs . typeAnnotations = ((@lhs.monos,@expression.beta),@typeScheme,(@expression.oneLineTree,@range.self)) : @expression.typeAnnotations
  | Let    lhs . typeAnnotations = @anns ++ @expression.typeAnnotations

SEM MaybeDeclarations
  | Just   lhs . typeAnnotations = @anns ++ @declarations.typeAnnotations

SEM Body
  | Body   lhs . typeAnnotations = @anns ++ @declarations.typeAnnotations

SEM Statement
  | Let    lhs . typeAnnotations = @anns ++ @declarations.typeAnnotations

SEM Qualifier
  | Let    lhs . typeAnnotations = @anns ++ @declarations.typeAnnotations

---------------------------------------------------------------------------------------
-- Utility functions to perform the binding-group analysis

{
type BindingGroups = [BindingGroup]
type BindingGroup  = (PatternAssumptions,Assumptions,ConstraintSets)
type MonoTable = [(PatternAssumptions,Tps)]

emptyBindingGroup :: BindingGroup
emptyBindingGroup = (empty,empty,[])

combineBindingGroup :: BindingGroup -> BindingGroup -> BindingGroup
combineBindingGroup (e1,a1,c1) (e2,a2,c2) = (e1 `combine` e2,a1 `combine` a2,c1++c2)

concatBindingGroups :: BindingGroups -> BindingGroup
concatBindingGroups = foldr combineBindingGroup emptyBindingGroup

checkForErrors :: Bool -> Tps -> TypeEnvironment -> BindingGroups -> (BindingGroups,[Error],[Warning],[(Name,Tps,Tp,Bool)],[((Tps,Tp),TpScheme,(Tree,Range))])
checkForErrors toplevel monos typeSignatures bdg = 
                    let
                        (completeEnvironment,completeAssumptions,_) = concatBindingGroups bdg
                        (typeSignaturesUnique,doubles) = onlyUniqueKeys typeSignatures
                        (unused,binds,rest) = typeSignaturesUnique ./\. completeEnvironment
          -- ERR : unused=type signatures that do not have a declaration
          -- ERR : doubles = type signatures that appear twice
          -- WAR : rest = declarations without a type signature
                        (completeEnvironmentUnique,doubles') = onlyUniqueKeys completeEnvironment 
                        (unused',_,_) = completeEnvironmentUnique ./\. completeAssumptions
          -- WAR : unused'=declaration is not used
          -- ERR : doubles'=multiple declarations
                        doubleNames = map head (doubles++doubles')
                        namesToBeRemoved = [n | (e,_,_) <-bdg, let ns = keys e, any (`elem` doubleNames) ns,n<-ns]
                        f (e,a,c) = (removes namesToBeRemoved e,removes namesToBeRemoved a,c)
                        warnings = makeUnused Definition (keys unused') toplevel
                        errors = makeNoFunDef TypeSignature (keys unused) (keys rest) ++                                             
                                 makeDuplicated TypeSignature doubles ++
                                 (if toplevel then [] else makeDuplicated Definition doubles')
                        typeAnnotations = [ ((monos,tp),ts,(Text (show n),getNameRange n')) | (as,bs) <- binds, (n',ts) <- as, (n,tp) <- bs ]
                        notypedef = [ (n,monos,t,toplevel) 
                                    | (n,t) <- filter ((`notElem` namesToBeRemoved) . fst) (toList rest)
                                    ]
                    in (map f bdg,errors,warnings,notypedef,typeAnnotations)

performAndCheckBindingGroup :: Bool -> Tps -> TypeEnvironment -> BindingGroup -> BindingGroups -> (PatternAssumptions,Assumptions,ConstraintSet,MonoTable,[Error],[Warning],[(Name,Tps,Tp,Bool)],[((Tps,Tp),TpScheme,(Tree,Range))])
performAndCheckBindingGroup toplevel monos typeSignatures context xs =
   let bdg = reverse (context : xs)
       (bdgs',errs,wars,notypedef,anns) = checkForErrors toplevel monos typeSignatures bdg
       (env,aset,cset,mt) = performBindingGroup monos typeSignatures (reverse (context : xs))
   in (env,aset,cset,mt,errs,wars,notypedef,anns)
                    
performBindingGroup :: Tps -> TypeEnvironment -> BindingGroups -> (PatternAssumptions,Assumptions,ConstraintSet,MonoTable)
performBindingGroup monos typeSignatures bdgs =
   variableDependencies (bindingGroupAnalysis bdgs)

   where
        bindingGroupAnalysis :: BindingGroups -> BindingGroups
        bindingGroupAnalysis cs
                        = let explicits = map fst (toList typeSignatures)
                              indexMap = concat (zipWith f cs [0..])
                              f (env,_,_) i = [(n,i) | (n,_)<-toList env, n `notElem` explicits]
                              edges    = concat (zipWith f' cs [0..])
                              f' (_,ass,_) i = [(i,j)|(n,_)<-toList ass,(n',j)<-indexMap,n==n']
                              list = topSort (length cs-1) edges
                          in map (concatBindingGroups . map (cs !!)) list

        variableDependencies :: BindingGroups -> (PatternAssumptions,Assumptions,ConstraintSet,MonoTable)
        variableDependencies = foldr op (empty,empty,ctEmpty,[]) where
            op (e,a,c) (env,aset,cset,mt) =
               let (cset1,e'     ) = (typeSignatures .:::. e) cinfoBindingGroupExplicitTypedBinding
                   (cset5,aset'  ) = (.<==.) monos e' aset    cinfoBindingGroupImplicit
                   (cset2,a'     ) = (typeSignatures .:::. a) cinfoBindingGroupExplicit
                   (cset3,a'',_,_) = (e' !===! a')            cinfoSameBindingGroup
               in ( e' `combine` env
                  , a'' `combine` aset'
                  , cset2 .>>. cset3 .>>. cset5 .>>. 
                    ctStrictOrder [ cset1 .<<. ctNode (reverse c)
                                  , cset
                                  ] 
                  , (e,elts e'):mt
                  )

findMono :: Tp -> MonoTable -> Tps
findMono i = let p = elem i . map snd . toList . fst
             in snd . head . filter p
}
