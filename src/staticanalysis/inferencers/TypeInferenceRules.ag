----------------------------------------------------------------------------------------
-- Type Inferencing : Module

SEM Module

  | Module  
      loc  -- choose your algorithm to solve the type constraints                                                   
           -- the default solver is SolverChunks
           . selectedSolver =                 
                let select
                       | SolverSimple      `elem` @lhs.options = solveSimple      @orderedTypeSynonyms
                       | SolverGreedy      `elem` @lhs.options = solveGreedy      @orderedTypeSynonyms
                       | SolverCombination `elem` @lhs.options = solveCombination (@orderedTypeSynonyms, @siblings)                                    
                       | SolverTypeGraph   `elem` @lhs.options = solveTypeGraph   (@orderedTypeSynonyms, @siblings)                          
                       | otherwise = \unique _ ->  
                                        let options = (@flattening, @orderedTypeSynonyms, @siblings)
                                            chunkConstraints = chunkTree dependencyTypeConstraint @body.constraints
                                        in solveChunkConstraints options unique chunkConstraints                       
                in select

           -- choose your treewalk to flatten the constraint tree
           -- the default treewalk is TreeWalkInorderTopLastPost (similar to 'W')
           . selectedTreeWalk = 
                let select
                       | TreeWalkTopDown             `elem` @lhs.options = topDownTreeWalk
                       | TreeWalkBottomUp            `elem` @lhs.options = bottomUpTreeWalk
                       | TreeWalkInorderTopFirstPre  `elem` @lhs.options = inorderTopFirstPreTreeWalk
                       | TreeWalkInorderTopLastPre   `elem` @lhs.options = inorderTopLastPreTreeWalk
                       | TreeWalkInorderTopFirstPost `elem` @lhs.options = inorderTopFirstPostTreeWalk
                       | otherwise                                       = inorderTopLastPostTreeWalk   
                    reverseOrNot
                       | RightToLeft `elem` @lhs.options = reverseTreeWalk
                       | otherwise                       = id
                in reverseOrNot select

           -- spread type constraints or not (i.e., map some type constraints to a 
           -- corresponding node in the constraint tree)
           -- spreading is enabled by default 
           . spreadingOrNot = 
                if NoSpreading `elem` @lhs.options 
                  then id
                  else spreadTree variableInConstraint

           . flattening = zipWith setPosition [0..] . flattenTree @selectedTreeWalk . phaseTree . @spreadingOrNot                                       
           . constraints = @flattening @body.constraints
           . orderedTypeSynonyms = getOrderedTypeSynonyms @lhs.importEnvironment
           
           . (betaUniqueAtTheEnd, substitution, predicates, solveErrors, debugIO) 
                  = @selectedSolver @body.betaUnique @constraints
           
           . siblings = let f s = [ (s, ts) | ts <- findTpScheme (nameFromString s) ]
                            findTpScheme n = catMaybes 
                                                [ lookupFM (valueConstructors @lhs.importEnvironment) n
                                                , lookupFM (typeEnvironment   @lhs.importEnvironment) n
                                                ]
                        in map (concatMap f) (getSiblings @lhs.importEnvironment)
                                       
           . monomorphics  = ftv (  (eltsFM $ valueConstructors @lhs.importEnvironment) 
                                 ++ (eltsFM $ typeEnvironment @lhs.importEnvironment)
                                 )
           . monos              = map TVar @monomorphics
           . checkedSolveErrors = catMaybes (map (checkTypeError @orderedTypeSynonyms . (@substitution |->) . makeTypeError) @solveErrors)
           . typeErrors         = if null @checkedSolveErrors then @body.collectErrors else @checkedSolveErrors
           . warnings           = @body.collectWarnings
           . initialScope       = keysFM (typeEnvironment @lhs.importEnvironment)
      body . betaUnique         = maximum (0 : @monomorphics) + 1 
                                 
---------------------------------------------------------------------------------------
-- Type Inferencing : Body

ATTR Body
    [ 
      monos                 : Tps
    | betaUnique            : Int
    | assumptions           : Assumptions
      constraints           : ConstraintSet
    ]

SEM Body
  | Body
      lhs          . assumptions         = @aset'
      declarations . bindingGroups       = []
                   
      loc . (aset,cset,inheritedBDG,chunkNr) = 
               performBindingGroup @lhs.currentChunk @declarations.uniqueChunk @lhs.chunkNumberMap [] @declarations.typeSignatures Nothing @declarations.bindingGroups  
          . (csetBinds,aset') = (typeEnvironment @lhs.importEnvironment .:::. @aset) @cinfo
          . constraints       = Chunk @lhs.currentChunk @cset [] (dependencyBinds @lhs.chunkNumberMap @csetBinds) emptyTree

---------------------------------------------------------------------------------------
-- Type Inferencing : Declaration, Declarations, MaybeDeclarations

ATTR Declaration Declarations MaybeDeclarations [ monos:Tps | betaUnique:Int | ]
ATTR Declaration Declarations                   [ inheritedBDG:InheritedBDG | bindingGroups:BindingGroups | ]
ATTR                          MaybeDeclarations [ | assumptions:Assumptions constraints:ConstraintSet | ]

SEM Declaration

  | FunctionBindings
      lhs      . bindingGroups = @mybdggrp : @lhs.bindingGroups
      bindings . betaUnique    = @lhs.betaUnique + 2 + @bindings.numberOfPatterns
               . monos         = findMono @bindings.name @lhs.inheritedBDG ++ @lhs.monos               
      loc      . beta          = TVar @lhs.betaUnique
               . betaRight     = TVar (@lhs.betaUnique + 1)
               . betasLeft     = take @bindings.numberOfPatterns (map TVar [@lhs.betaUnique + 2..])
               . newcon        = (@beta .==. foldr (.->.) @betaRight @betasLeft) @cinfo
               . mybdggrp      = ( unitFM @bindings.name @beta
                                 , @bindings.assumptions
                                 , [ Node [ Phase (-1) [@newcon] 
                                          , Receive @lhs.betaUnique
                                          , Node @bindings.constraintslist
                                          ]
                                   ]
                                 )

  | PatternBinding
      lhs           . bindingGroups = @mybdggrp : @lhs.bindingGroups
      righthandside . monos         = findMono (head (keysFM @pattern.environment)) @lhs.inheritedBDG ++ @lhs.monos    
      loc           . newcon        = [ (@righthandside.beta .==. @pattern.beta) @cinfo ]
                    . mybdggrp      = ( @pattern.environment
                                      , @righthandside.assumptions
                                      , [ @newcon .>.
                                          Node [ @pattern.constraints
                                               , @righthandside.constraints
                                               ]
                                        ]
                                      )

SEM MaybeDeclarations
  | Just
      lhs          . assumptions    = @aset
                   . constraints    = @cset
      declarations . bindingGroups  = []
                   
      loc          . (aset,cset,inheritedBDG,chunkNr) = 
                        performBindingGroup @lhs.currentChunk @declarations.uniqueChunk @lhs.chunkNumberMap @lhs.monos @declarations.typeSignatures @mybdggroup @declarations.bindingGroups
                                                
                   . mybdggroup     = Just (@lhs.assumptions, [@lhs.constraints])

---------------------------------------------------------------------------------------
-- Type Inferencing : FunctionBinding, FunctionBindings

ATTR FunctionBinding FunctionBindings [ betasLeft:Tps betaRight:Tp monos:Tps | betaUnique:Int | assumptions:Assumptions numberOfPatterns:Int name:Name ]
ATTR FunctionBinding                  [ | | constraints:ConstraintSet]
ATTR                 FunctionBindings [ | | constraintslist:ConstraintSets]

SEM FunctionBinding

  | FunctionBinding
      lhs           . assumptions = @assumptions'
      righthandside . monos       = eltsFM @lefthandside.environment ++ getMonos @csetBinds ++ @lhs.monos
      loc           . constraints = @csetBinds .>>.
                                    Node [ @conLeft  .<. @lefthandside.constraints
                                         , @conRight .<. @righthandside.constraints
                                         ]
                    . (csetBinds,assumptions') = (@lefthandside.environment .===. @righthandside.assumptions) @cinfoBind
                    . conLeft     = zipWith3 (\t1 t2 nr -> (t1 .==. t2) (@cinfoLeft nr)) @lefthandside.betas @lhs.betasLeft [0..]
                    . conRight    = [ (@righthandside.beta .==. @lhs.betaRight) @cinfoRight ]

SEM FunctionBindings

  | Cons
      lhs . assumptions      = @hd.assumptions `combine` @tl.assumptions
          . numberOfPatterns = @hd.numberOfPatterns
          . name             = @hd.name
          . constraintslist  = @hd.constraints : @tl.constraintslist
  | Nil
      lhs . assumptions      = noAssumptions
          . numberOfPatterns = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(1)"
          . name             = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(2)"
          . constraintslist  = []

---------------------------------------------------------------------------------------
-- Type Inferencing : LeftHandSide, RightHandSide

ATTR LeftHandSide RightHandSide [ | betaUnique:Int | constraints:ConstraintSet ]
ATTR LeftHandSide               [ | | betas:Tps environment:PatternAssumptions numberOfPatterns:Int name:Name ]
ATTR              RightHandSide [ monos:Tps | | assumptions:Assumptions beta:Tp ]

SEM LeftHandSide

  | Function
      lhs . name             = @name.self
      loc . constraints      = Node @patterns.constraintslist
          

  | Infix
      lhs . numberOfPatterns = 2
          . environment      = @leftPattern.environment `plusFM` @rightPattern.environment
          . betas            = [@leftPattern.beta,@rightPattern.beta]
          . name             = @operator.self
      loc . constraints      = Node [ @leftPattern.constraints
                                    , @rightPattern.constraints
                                    ]
          

  | Parenthesized
      lhs . numberOfPatterns = @lefthandside.numberOfPatterns + @patterns.numberOfPatterns
          . environment      = @lefthandside.environment `plusFM` @patterns.environment
          . betas            = @lefthandside.betas ++ @patterns.betas
      loc . constraints      = Node ( @lefthandside.constraints : @patterns.constraintslist )

SEM RightHandSide

  | Expression
     lhs   . assumptions = @where.assumptions           
     where . assumptions = @expression.assumptions
           . constraints = @expression.constraints
     loc   . constraints = @where.constraints

  | Guarded
     lhs                . assumptions    = @where.assumptions
                        . constraints    = @where.constraints
     guardedexpressions . betaUnique     = @lhs.betaUnique + 1
                        . rightBeta      = @beta
                        . numberOfGuards = length @guardedexpressions.constraintslist
     where              . assumptions    = @guardedexpressions.assumptions
     loc                . constraints    = Node @guardedexpressions.constraintslist
                        . beta           = TVar @lhs.betaUnique

---------------------------------------------------------------------------------------
-- Type Inferencing : Expression, Expressions, MaybeExpression, GuardedExpression, GuardedExpressions

ATTR Expression Expressions MaybeExpression GuardedExpression GuardedExpressions [ monos:Tps | betaUnique:Int | assumptions:Assumptions ]
ATTR Expression                             GuardedExpression                    [ | | beta:Tp constraints:ConstraintSet ]
ATTR            Expressions                                   GuardedExpressions [ | | betas:Tps constraintslist:ConstraintSets ]
ATTR                        MaybeExpression                                      [ | | beta:Tp constraints:ConstraintSet section:Bool ]
ATTR                                        GuardedExpression GuardedExpressions [ rightBeta:Tp | | ]
ATTR GuardedExpressions GuardedExpression [ numberOfGuards:Int | | ]

SEM Expression

  | Literal
      lhs . betaUnique  = @lhs.betaUnique + 1
          . assumptions = noAssumptions
      loc . constraints = unitTree ((@literal.literalType .==. @beta) @cinfo)
          . beta        = TVar @lhs.betaUnique

  | Constructor
      lhs . betaUnique   = @lhs.betaUnique + 1
          . assumptions  = noAssumptions
      loc . constraints  = listTree @newcon
          . beta         = TVar @lhs.betaUnique
          . newcon       = case lookupFM (valueConstructors @lhs.importEnvironment) @name.self of
                              Nothing  -> []
                              Just ctp -> [ (@beta .::. ctp) @cinfo ]

  | Variable
      lhs . betaUnique  = @lhs.betaUnique + 1
          . assumptions = @name.self `single` @beta
      loc . constraints = Node [ Receive @lhs.betaUnique ]
          . beta        = TVar @lhs.betaUnique

  | NormalApplication
      lhs      . assumptions = @function.assumptions `combine` @arguments.assumptions
      function . betaUnique  = @lhs.betaUnique + 1
      loc      . constraints = @newcon .>.
                               Node [ @function.constraints
                                    , Node @arguments.constraintslist
                                    ]      
               . beta        = TVar @lhs.betaUnique
               . newcon      = [ (@function.beta .==. foldr (.->.) @beta @arguments.betas) @cinfo ]

  | InfixApplication
      lhs            . assumptions = @leftExpression.assumptions `combine` @operator.assumptions `combine` @rightExpression.assumptions
      leftExpression . betaUnique  = @lhs.betaUnique + 2
      loc            . constraints = @conTotal .>.
                                     Node [ @operator.constraints
                                          , @leftExpression.constraints
                                          , @rightExpression.constraints
                                          ]
                     . beta        = TVar @lhs.betaUnique
                     . betaResOp   = TVar (@lhs.betaUnique + 1)
                     . conOperator = (@operator.beta .==. @leftExpression.beta .->. @rightExpression.beta .->. @betaResOp) @cinfoOperator
                     . conTotal    = case (@leftExpression.section,@rightExpression.section) of
                                            (False,False) -> [ @conOperator, (@betaResOp     .==. @beta)                        @cinfoComplete     ]
                                            (True ,True ) -> [               (@operator.beta .==. @beta)                        @cinfoEmpty        ]
                                            (False,True ) -> [ @conOperator, (@rightExpression.beta .->. @betaResOp .==. @beta) @cinfoRightSection ]
                                            (True ,False) -> [ @conOperator, (@leftExpression.beta  .->. @betaResOp .==. @beta) @cinfoLeftSection  ]

  | If
      lhs             . assumptions = @guardExpression.assumptions `combine` @thenExpression.assumptions `combine` @elseExpression.assumptions
      guardExpression . betaUnique  = @lhs.betaUnique + 1
      loc             . constraints = Node [ @conGuard .<. @guardExpression.constraints
                                           , @conThen  .<. @thenExpression.constraints
                                           , @conElse  .<. @elseExpression.constraints
                                           ]
                      . beta        = TVar @lhs.betaUnique
                      . conGuard    = [ (@guardExpression.beta .==. boolType) @cinfoGuard ]
                      . conThen     = [ (@thenExpression.beta  .==. @beta   ) @cinfoThen  ]
                      . conElse     = [ (@elseExpression.beta  .==. @beta   ) @cinfoElse  ]

  | Lambda
      lhs        . assumptions = @assumptions'
      patterns   . betaUnique  = @lhs.betaUnique + 1
      expression . monos       = eltsFM @patterns.environment ++ getMonos @csetBinds ++ @lhs.monos
      loc        . constraints = @newcon .>. @csetBinds .>>.
                                 Node [ Node @patterns.constraintslist
                                      , @expression.constraints
                                      ]
                 . beta        = TVar @lhs.betaUnique
                 . (csetBinds,assumptions') = (@patterns.environment .===. @expression.assumptions) @cinfoBind
                 . newcon      = [ (foldr (.->.) @expression.beta @patterns.betas .==. @beta) @cinfoType ]

  | Case
      lhs          . assumptions = @expression.assumptions `combine` @alternatives.assumptions
      expression   . betaUnique  = @lhs.betaUnique + 2
      alternatives . betaLeft    = @beta'
                   . betaRight   = @beta
                   . nrOfAlternatives = length @alternatives.constraintslist
      loc          . constraints = Node [ @newcon .<. @expression.constraints
                                        , Node @alternatives.constraintslist
                                        ]                   
                   . beta        = TVar @lhs.betaUnique
                   . beta'       = TVar (@lhs.betaUnique + 1)
                   . newcon      = [ (@expression.beta .==. @beta') @cinfo ]

  | Let
      lhs          . assumptions    = @aset
      declarations . betaUnique     = @lhs.betaUnique + 1
                   . bindingGroups  = []
      loc          . constraints    = [ (@expression.beta .==. @beta) @cinfoType ] .>. @cset                   
                   . beta           = TVar @lhs.betaUnique
                   . mybdggroup     = Just (@expression.assumptions, [@expression.constraints])
                   
                   . (aset,cset,inheritedBDG,chunkNr) = 
                        performBindingGroup @lhs.currentChunk @expression.uniqueChunk @lhs.chunkNumberMap @lhs.monos @declarations.typeSignatures @mybdggroup @declarations.bindingGroups

  | Do
      lhs        . constraints   = Node [ @newcon .<. @statements.constraints ]
      statements . betaUnique    = @lhs.betaUnique + 1
                 . generatorBeta = Nothing
                 . assumptions   = noAssumptions
      loc        . constraints   = emptyTree
                 . beta          = TVar @lhs.betaUnique
                 . newcon        = case @statements.generatorBeta of
                                      Nothing -> []
                                      Just b  -> [ (ioType b .==. @beta) @cinfo ]

  | List
      expressions . betaUnique   = @lhs.betaUnique + 2
      loc         . constraints  = @newcon .>.
                                    Node (zipWith3 @zipf @expressions.betas [0..] @expressions.constraintslist)
                  . beta         = TVar @lhs.betaUnique
                  . beta'        = TVar (@lhs.betaUnique + 1)
                  . newcon       = [ (listType @beta' .==. @beta) @cinfoResult ]
                  . zipf         = \tp childNr ctree -> [ (tp .==. @beta') (@cinfoElem childNr) ] .<. ctree

  | Tuple
      expressions . betaUnique  = @lhs.betaUnique + 1
      loc         . constraints = @newcon .>. Node @expressions.constraintslist
                  . beta        = TVar @lhs.betaUnique
                  . newcon      = [ (tupleType @expressions.betas .==. @beta) @cinfo ]

  | Typed     
      expression . betaUnique  = @lhs.betaUnique + 1
      loc        . constraints = @conResult .>.
                                 Node [ @conExpr .<. @expression.constraints ]
                 . beta        = TVar @lhs.betaUnique
                 . typeScheme  = makeTpSchemeFromType @type.self 
                 . conResult   = [ (@beta            .::. @typeScheme) @cinfoResult ]
                 . conExpr     = [ (@expression.beta .::. @typeScheme) @cinfoExpr   ]

  | Comprehension
      lhs        . assumptions = @qualifiers.assumptions                 
      expression . betaUnique  = @lhs.betaUnique + 1
                 . monos       = @qualifiers.monos
      qualifiers . assumptions = @expression.assumptions
                 . constraints = @expression.constraints
                 . monos       = @lhs.monos
      loc        . constraints = @newcon .>. Node [ @qualifiers.constraints ]
                 . beta        = TVar @lhs.betaUnique
                 . newcon      = [ (listType @expression.beta .==. @beta) @cinfo ]

  | Enum
       lhs  . assumptions = @from.assumptions `combine` @then.assumptions `combine` @to.assumptions
       from . betaUnique  = @lhs.betaUnique + 1
       loc  . constraints = [ (listType intType .==. @beta) @cinfoResult ] .>.
                            Node [ @conFrom .<. @from.constraints
                                 , @conThen .<. @then.constraints
                                 , @conTo   .<. @to.constraints
                                 ]
            . beta        = TVar @lhs.betaUnique
            . conFrom     = [ (@from.beta .==. intType) @cinfoFrom ]
            . conThen     = [ (@then.beta .==. intType) @cinfoThen ]
            . conTo       = [ (@to.beta   .==. intType) @cinfoTo   ]

  | Negate
       expression . betaUnique  = @lhs.betaUnique + 1
       loc        . constraints = @newcon .>. Node [ @expression.constraints ]
                  . beta        = TVar @lhs.betaUnique
                  . newcon      = -- search for the type of 'negate' in the import envionment: otherwise use the default type.
                                  let standard = generalize [] [Predicate "Num" (TVar 0)] (TVar 0 .->. TVar 0)
                                      tpscheme = lookupWithDefaultFM (typeEnvironment @lhs.importEnvironment) standard (nameFromString "negate")
                                  in [ (@expression.beta .->. @beta .::. tpscheme) @cinfo]

{- only if type inferencing without overloading -}
  | NegateFloat
       expression . betaUnique  = @lhs.betaUnique + 1
       loc        . constraints = @newcon .>. Node [ @expression.constraints ]
                  . beta        = TVar @lhs.betaUnique
                  . newcon      = [ (floatType .->. floatType .==. @expression.beta .->. @beta) @cinfo]

SEM Expressions

  | Cons
      lhs . betas           = @hd.beta : @tl.betas
          . assumptions     = @hd.assumptions `combine` @tl.assumptions
          . constraintslist = @hd.constraints : @tl.constraintslist

  | Nil
      lhs . betas           = []
          . assumptions     = noAssumptions
          . constraintslist = []

SEM MaybeExpression

  | Just
      lhs . section = False

  | Nothing
      lhs . section     = True
          . betaUnique  = @lhs.betaUnique + 1
          . assumptions = noAssumptions
          . constraints = emptyTree
      loc . beta        = TVar @lhs.betaUnique

SEM GuardedExpression

  | GuardedExpression
      lhs . beta        = @expression.beta
          . constraints = Node [ @newconGuard .<. @guard.constraints
                               , @newconExpr  .<. @expression.constraints
                               ]
          . assumptions = @guard.assumptions `combine` @expression.assumptions
      loc . newconGuard = [ (@guard.beta .==. boolType) @cinfoGuard ]
          . newconExpr  = [ (@expression.beta .==. @lhs.rightBeta) @cinfoExpr ]

SEM GuardedExpressions

  | Cons
      lhs . betas           = @hd.beta : @tl.betas
          . assumptions     = @hd.assumptions `combine` @tl.assumptions
          . constraintslist = @hd.constraints : @tl.constraintslist

  | Nil
      lhs . betas           = []
          . assumptions     = noAssumptions
          . constraintslist = []


---------------------------------------------------------------------------------------
-- Type Inferencing : Pattern

ATTR Pattern Patterns [ | betaUnique:Int | environment:PatternAssumptions ]
ATTR Pattern          [ | | beta:Tp constraints:ConstraintSet ]
ATTR         Patterns [ | | betas:Tps constraintslist:ConstraintSets numberOfPatterns:Int ]

SEM Pattern

  | Literal
      lhs . betaUnique  = @lhs.betaUnique + 1
          . environment = noAssumptions
      loc . constraints = unitTree ((@literal.literalType .==. @beta) @cinfo)
          . beta        = TVar @lhs.betaUnique

  | Variable
      lhs . betaUnique  = @lhs.betaUnique + 1
          . environment = unitFM @name.self @beta
      loc . constraints = Receive @lhs.betaUnique
          . beta        = TVar @lhs.betaUnique

  | InfixConstructor
      lhs         . environment    = @leftPattern.environment `plusFM` @rightPattern.environment
      leftPattern . betaUnique     = @lhs.betaUnique + 2
      loc         . constraints    = @conApply .>.
                                     Node [ listTree @conConstructor
                                          , @leftPattern.constraints
                                          , @rightPattern.constraints
                                          ]
                  . beta           = TVar @lhs.betaUnique
                  . betaCon        = TVar (@lhs.betaUnique + 1)
                  . conApply       = [ (@betaCon .==. @leftPattern.beta .->. @rightPattern.beta .->. @beta) @cinfoApply ]
                  . conConstructor = case lookupFM (valueConstructors @lhs.importEnvironment) @constructorOperator.self  of
                                        Nothing  -> []
                                        Just ctp -> [ (@betaCon .::. ctp) @cinfoConstructor ]

  | Constructor
      patterns . betaUnique     = @lhs.betaUnique + 2
      loc      . constraints    = @conApply .>.
                                  Node [ listTree @conConstructor
                                       , Node @patterns.constraintslist
                                       ]
               . beta           = TVar (@lhs.betaUnique)
               . betaCon        = TVar (@lhs.betaUnique + 1)
               . conApply       = [ (@betaCon .==. foldr (.->.) @beta @patterns.betas) 
                                    (if @patterns.numberOfPatterns == 0  then @cinfoEmpty else @cinfoApply) ]             
               . conConstructor = case lookupFM (valueConstructors @lhs.importEnvironment) @name.self of
                                     Nothing  -> []
                                     Just ctp -> [ (@betaCon .::. ctp) @cinfoConstructor ]

  | As
      lhs     . environment = addToFM @pattern.environment @name.self @beta              
      pattern . betaUnique  = @lhs.betaUnique + 1
      loc     . constraints = @newcon .>.
                              Node [ Receive @lhs.betaUnique
                                   , @pattern.constraints
                                   ]
              . beta        = TVar @lhs.betaUnique
              . newcon      = [ (@beta .==. @pattern.beta) @cinfo ]

  | Wildcard
      lhs . betaUnique  = @lhs.betaUnique + 1
          . environment = noAssumptions
      loc . constraints = emptyTree
          . beta        = TVar @lhs.betaUnique

  | List
      patterns . betaUnique   = @lhs.betaUnique + 2
      loc      . constraints  = @newcon .>.
                                Node (zipWith3 @zipf @patterns.betas [0..] @patterns.constraintslist)
               . beta         = TVar @lhs.betaUnique
               . beta'        = TVar (@lhs.betaUnique + 1)
               . newcon       = [ (listType @beta' .==. @beta) @cinfoResult ]
               . zipf         = \tp elemNr ctree -> [ (tp .==. @beta') (@cinfoElem elemNr) ] .<. ctree

  | Tuple    
      patterns . betaUnique  = @lhs.betaUnique + 1
      loc      . constraints = @newcon .>. Node @patterns.constraintslist
               . beta        = TVar @lhs.betaUnique
               . newcon      = [ (tupleType @patterns.betas .==. @beta) @cinfo ]

  | Negate
      lhs . betaUnique  = @lhs.betaUnique + 1
          . environment = noAssumptions
      loc . constraints = listTree @newcon
          . beta        = TVar @lhs.betaUnique
          . newcon      = -- The parser only accepts a literal after '-' in a Pattern
                          -- search for the type of 'negate' in the import envionment: otherwise use the default type.
                          let standard = generalize [] [Predicate "Num" (TVar 0)] (TVar 0 .->. TVar 0)
                              tpscheme = lookupWithDefaultFM (typeEnvironment @lhs.importEnvironment) standard (nameFromString "negate")
                          in [ (@literal.literalType .->. @beta .::. tpscheme) @cinfo]
          
{- only if type inferencing without overloading -}
  | NegateFloat
      lhs . betaUnique  = @lhs.betaUnique + 1
          . environment = noAssumptions
      loc . constraints = listTree @newcon
          . beta        = TVar @lhs.betaUnique
          . newcon      = -- The parser only accepts a literal after '-.' in a Pattern
                          [ (floatType .==. @beta) @cinfo ]

SEM Patterns

  | Cons
      lhs . betas            = @hd.beta : @tl.betas
          . environment      = @hd.environment `plusFM` @tl.environment
          . numberOfPatterns = 1 + @tl.numberOfPatterns
          . constraintslist  = @hd.constraints : @tl.constraintslist

  | Nil
      lhs . betas            = []
          . environment      = noAssumptions
          . numberOfPatterns = 0
          . constraintslist  = []

---------------------------------------------------------------------------------------
-- Type Inferencing : Alternative, Alternatives

ATTR Alternative Alternatives [ betaLeft:Tp betaRight:Tp monos:Tps | betaUnique:Int | assumptions:Assumptions ]
ATTR Alternative              [ | | constraints:ConstraintSet ]
ATTR             Alternatives [ | | constraintslist:ConstraintSets ]
ATTR Alternative Alternatives [ nrOfAlternatives:Int | | ]

SEM Alternative

  | Alternative
      lhs           . assumptions = @assumptions'
      righthandside . monos       = eltsFM @pattern.environment ++ getMonos @csetBinds ++ @lhs.monos
      loc           . constraints = @csetBinds .>>.
                                    Node [ @conLeft  .<. @pattern.constraints
                                         , @conRight .<. @righthandside.constraints
                                         ] 
                    . (csetBinds,assumptions') = (@pattern.environment .===. @righthandside.assumptions) @cinfoBind
                    . conLeft     = [ (@pattern.beta .==. @lhs.betaLeft) @cinfoLeft ]
                    . conRight    = [ (@righthandside.beta .==. @lhs.betaRight) @cinfoRight ]

  | Empty
      lhs . assumptions = noAssumptions
      loc . constraints = emptyTree

SEM Alternatives

  | Cons
      lhs . assumptions     = @hd.assumptions `combine` @tl.assumptions
          . constraintslist = @hd.constraints : @tl.constraintslist

  | Nil
      lhs . assumptions     = noAssumptions
          . constraintslist = []

---------------------------------------------------------------------------------------
-- Type Inferencing : Statement, Statements, Qualifier, Qualifiers

ATTR Statement Statements Qualifier Qualifiers [ | assumptions:Assumptions betaUnique:Int constraints:ConstraintSet | ]
ATTR Statement Statements                      [ | generatorBeta:{Maybe Tp} | ]
ATTR Statement            Qualifier Qualifiers [ | monos:Tps | ]
ATTR           Statements                      [ monos:Tps | | ]

SEM Statement

  | Expression
      lhs        . generatorBeta  = Just @beta
                 . assumptions    = @lhs.assumptions `combine` @expression.assumptions
                 . constraints    = @locConstraints
      expression . betaUnique     = @lhs.betaUnique + 1
      loc        . locConstraints = Node [ @newcon .<. @expression.constraints
                                         , @lhs.constraints
                                         ]
                 . beta           = TVar @lhs.betaUnique
                 . newcon         = [ (@expression.beta .==. ioType @beta) @cinfo ]

  | Let
      lhs          . generatorBeta  = Nothing
                   . assumptions    = @aset
                   . constraints    = @locConstraints  
      declarations . bindingGroups  = []
      
      loc          . (aset,locConstraints,inheritedBDG,chunkNr) = 
                        performBindingGroup @lhs.currentChunk @declarations.uniqueChunk @lhs.chunkNumberMap @lhs.monos @declarations.typeSignatures @mybdggroup @declarations.bindingGroups
                        
                   . mybdggroup     = Just (@lhs.assumptions, [@lhs.constraints])

  | Generator
      lhs . generatorBeta = Nothing
          . constraints   = @locConstraints
          . assumptions   = @assumptions' `combine` @expression.assumptions
          . monos         = eltsFM @pattern.environment ++ getMonos @csetBinds ++ @lhs.monos
      loc . locConstraints = @newcon .>. @csetBinds .>>.
                                Node [ @pattern.constraints
                                     , @expression.constraints
                                     , @lhs.constraints
                                     ]
          . (csetBinds,assumptions') = (@pattern.environment .===. @lhs.assumptions) @cinfoBind
          . newcon        = [ (@expression.beta .==. ioType @pattern.beta) @cinfoResult ]

SEM Statements

  | Cons
      lhs . assumptions = @hd.assumptions
          . constraints = @hd.constraints
      hd  . assumptions = @tl.assumptions
          . constraints = @tl.constraints
      tl  . assumptions = @lhs.assumptions
          . constraints = @lhs.constraints

SEM Qualifier

  | Guard
      lhs . assumptions = @lhs.assumptions `combine` @guard.assumptions
          . constraints = @locConstraints
      loc . locConstraints = Node [ @newcon .<. @guard.constraints
                                  , @lhs.constraints
                                  ]
          . newcon      = [ (@guard.beta .==. boolType) @cinfo ]

  | Let   lhs          . assumptions    = @aset
                       . constraints    = @locConstraints
          declarations . bindingGroups  = []
          
          loc          . (aset,locConstraints,inheritedBDG,chunkNr) = 
                            performBindingGroup @lhs.currentChunk @declarations.uniqueChunk @lhs.chunkNumberMap @lhs.monos @declarations.typeSignatures @mybdggroup @declarations.bindingGroups
                            
                       . mybdggroup     = Just (@lhs.assumptions, [@lhs.constraints])

  | Generator
      lhs . assumptions = @assumptions' `combine` @expression.assumptions
          . constraints = @locConstraints
          . monos       = eltsFM @pattern.environment ++ getMonos @csetBinds ++ @lhs.monos
      loc . locConstraints = @newcon .>. @csetBinds .>>.
                                Node [ @pattern.constraints
                                     , @expression.constraints
                                     , @lhs.constraints
                                     ]
          . (csetBinds,assumptions') = (@pattern.environment .===. @lhs.assumptions) @cinfoBind
          . newcon      = [ (@expression.beta .==. listType @pattern.beta) @cinfoResult ]

SEM Qualifiers

  | Cons
      lhs . assumptions = @hd.assumptions
          . constraints = @hd.constraints
      hd  . assumptions = @tl.assumptions
          . constraints = @tl.constraints
      tl  . assumptions = @lhs.assumptions
          . constraints = @lhs.constraints

---------------------------------------------------------------------------------------
-- Type Inferencing : Literal

ATTR Literal [ | | literalType:Tp ]

SEM Literal
  | Int     lhs . literalType = intType
  | Char    lhs . literalType = charType
  | String  lhs . literalType = stringType
  | Float   lhs . literalType = floatType

---------------------------------------------------------------------------------------
-- Utility functions to perform the binding-group analysis

{
type Assumptions        = FiniteMap Name [(Name,Tp)]
type PatternAssumptions = FiniteMap Name Tp

noAssumptions :: FiniteMap Name a
noAssumptions = emptyFM

combine :: Assumptions -> Assumptions -> Assumptions
combine = plusFM_C (++)

single :: Name -> Tp -> Assumptions
single n t = unitFM n [(n,t)]

getMonos :: TypeConstraints info -> Tps
getMonos = map TVar . mapMaybe variableInConstraint

type BindingGroups = [BindingGroup]
type BindingGroup  = (PatternAssumptions,Assumptions,ConstraintSets)
type InheritedBDG  = [(Names,(Tps, Int))]

emptyBindingGroup :: BindingGroup
emptyBindingGroup = (noAssumptions, noAssumptions, [])

combineBindingGroup :: BindingGroup -> BindingGroup -> BindingGroup
combineBindingGroup (e1,a1,c1) (e2,a2,c2) = (e1 `plusFM` e2,a1 `combine` a2,c1++c2)

concatBindingGroups :: BindingGroups -> BindingGroup
concatBindingGroups = foldr combineBindingGroup emptyBindingGroup
                    
performBindingGroup :: Int -> Int -> ChunkNumberMap -> Tps -> FiniteMap Name TpScheme -> Maybe (Assumptions, ConstraintSets) -> BindingGroups -> (Assumptions,ConstraintSet,InheritedBDG,Int)
performBindingGroup currentChunk uniqueChunk chunkNumberMap monos typeSignatures context groups = 
   variableDependencies 

   where   
        bindingGroupAnalysis :: BindingGroups -> BindingGroups

        bindingGroupAnalysis cs
                        = let explicits = keysFM typeSignatures
                              indexMap = concat (zipWith f cs [0..])
                              f (env,_,_) i = [ (n,i) | n <- keysFM env, n `notElem` explicits ]
                              edges    = concat (zipWith f' cs [0..])
                              f' (_,ass,_) i = [ (i,j)| n <- keysFM ass, (n',j) <- indexMap, n==n' ]
                              list = topSort (length cs-1) edges
                          in map (concatBindingGroups . map (cs !!)) list

        chunkedBindingGroups  :: [(Int, BindingGroup)]
        chunkedBindingGroups = zip [uniqueChunk..] (bindingGroupAnalysis groups) ++ 
                               case context of 
                                  Nothing     -> []
                                  Just (a, c) -> [(currentChunk, (emptyFM, a, c))]
        
        monomorphicNames :: [Name]
        monomorphicNames = 
           let initial = let f (e, a, _) = if any (`elem` ftv monos) (ftv $ map snd $ concat $ eltsFM a)
                                             then keysFM e
                                             else []
                         in concatMap f groups
               expand [] _       = []
               expand (n:ns) gps = let (xs, ys)  = partition p gps
                                       p (_,a,_) = n `elem` keysFM a
                                       f (e,_,_) = keysFM e
                                   in n : expand (concatMap f xs ++ ns) ys
           in expand initial groups
                          
        variableDependencies :: (Assumptions,ConstraintSet,InheritedBDG,Int)
        variableDependencies = 
           let (aset, cset, mt) = foldr op initial chunkedBindingGroups
           in (aset, cset, mt, uniqueChunk + length groups)

          where        
            initial = (noAssumptions, emptyTree, [])
          
            op (cnr,(e,a,c)) (aset,cset,mt) =
               let (cset1,e'   )  = (typeSignatures !:::! e) cinfoBindingGroupExplicitTypedBinding                   
                   (cset2,a'   )  = (typeSignatures .:::. a) cinfoBindingGroupExplicit
                   (cset3,a''  )  = (e' .===. a')            cinfoSameBindingGroup
                   (cset4,aset')  = (.<==.) monos e' aset    cinfoBindingGroupImplicit
                   
                   monomorphic    = any (`elem` monomorphicNames) (keysFM e) || cnr == currentChunk

                   constraintTree 
                    | monomorphic = StrictOrder 
                                       ( (cset1 ++ cset2 ++ cset3) .>>. Node (reverse c) )
                                       ( cset4 .>>. cset )
                    | otherwise   = Chunk cnr
                                          (cset3 .>>. Node (reverse c))
                                          (dependencyBinds chunkNumberMap cset4)
                                          ([(cnr, c) | c <- cset1] ++ dependencyBinds chunkNumberMap cset2)
                                          cset
               in  
                  ( a'' `combine` aset'
                  , constraintTree
                  , (keysFM e,(eltsFM e', if monomorphic then currentChunk else cnr)) : mt                   
                  )

findMono :: Name -> InheritedBDG -> Tps
findMono n = let p = elem n . fst
             in fst . snd . head . filter p                  

findCurrentChunk :: Name -> InheritedBDG -> Int
findCurrentChunk n = let p = elem n . fst
                     in snd . snd . head . filter p  
}
