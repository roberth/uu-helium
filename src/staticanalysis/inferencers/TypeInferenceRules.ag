-------------------------------------------------------------------------------
--
--   *** The Helium Compiler : Static Analysis ***
--               ( Bastiaan Heeren )
--
-- TypeInferenceRules.ag : The type inference rules for Helium.
--
-------------------------------------------------------------------------------

ATTR Body Statement Qualifier Statements Qualifiers Expression RightHandSide MaybeExpression
     Expressions GuardedExpression GuardedExpressions FunctionBinding FunctionBindings
     Declaration Declarations MaybeDeclarations Alternative Alternatives Patterns Pattern
     LeftHandSide [ importEnvironment : ImportEnvironment | | ]

----------------------------------------------------------------------------------------
-- Type Inferencing : Module

SEM Module

  | Module
      body . betaUnique  = maximum (0 : @monomorphics) + 1
      loc  . debugIO     = do putStrLn "--- Debug Info ---"
                              putStrLn $ unlines $ map show @constraints
                              putStrLn $ "type variables in constraint set: "++show @body.betaUnique
                              putStrLn $ "type variables used while solving: "++show @betaUniqueAtTheEnd
                              putStrLn $ "constraints in set: "++show (length @constraints)
                              when @filteredBool (putStrLn ("WARNING: Filtered type errors"))
                              @solveDebug
                                
      loc  . constraints = zipWith setPosition [0..] (ctRoot @body.constraints @lhs.strategy)
           . orderedTypeSynonyms = getOrderedTypeSynonyms @lhs.importEnvironment
           . (betaUniqueAtTheEnd,substitution,finalPredicates,solveErrors,solveDebug) 
                  = -- choose your algorithm to solve the type constraints
                    (if @lhs.useTypeGraph then solveEquivalenceGroups else solveGreedy) 
                       @body.betaUnique ([ SolveWithTypeSynonyms @orderedTypeSynonyms 
                                         , SolveWithTypeSignatures . map (\(n,ts) -> (show n,ts)) $
                                              (  fmToList (valueConstructors @lhs.importEnvironment)
                                              ++ fmToList (typeEnvironment @lhs.importEnvironment)
                                              )
                                         ] ++
                                         [ SolveWithSiblings xs | Siblings xs <- typingStrategies @lhs.importEnvironment ]
                                        )
                                        @constraints
           . monomorphics  = ftv (  (eltsFM $ valueConstructors @lhs.importEnvironment) 
                                 ++ (eltsFM $ typeEnvironment @lhs.importEnvironment)
                                 )
           . monos = map TVar @monomorphics
           . inferredgamma = map (\(name,tp) -> (name,generalize (ftv (@substitution |-> @monos)) [] (@substitution |-> tp))) @body.namesWithoutTypeDef
           . (typeErrors,filteredBool)    
                  = let notGeneralEnoughErrors = 
                           let f ((m,t),s2,(tree,range)) = 
                                  let m' = @substitution |-> m
                                      t' = @substitution |-> t
                                      s1 = generalize (ftv m') [] t'
                                 in if not (genericInstanceOf @orderedTypeSynonyms standardClasses s2 s1) &&  
                                       unifiableTypeSchemes   @orderedTypeSynonyms s1 s2
                                    then [makeNotGeneralEnoughTypeError range tree s1 s2]
                                    else []                                                                  
                           in concatMap f @body.typeAnnotations
                        
                        op typeError (list,bool) = -- extra check: are the reported types still not unifiable? 
                                                   case checkTypeError @orderedTypeSynonyms typeError of
                                                      Just t  -> (t:list,bool) 
                                                      Nothing -> (list,True)
                                                                              
                    in if null @solveErrors 
                         then (notGeneralEnoughErrors,False)
                         else foldr op ([], False) (map ((@substitution |->) . makeTypeError) @solveErrors)
            
           . toplevelTypes = addListToFM @body.typeSignatures @inferredgamma
           
---------------------------------------------------------------------------------------
-- Type Inferencing : Body

ATTR Body
    [ 
      monos                 : Tps
    | betaUnique            : Int
    | assumptions           : Assumptions
      constraints           : ConstraintSet
      namesWithoutTypeDef   : {[(Name,Tp)]}
    ]

SEM Body
  | Body
      lhs          . constraints         = ctNode [ @csetBinds .<<. @cset ]
                   . assumptions         = @aset'
                   . namesWithoutTypeDef = [ (n,tp) | (n,_,tp,_) <- @notypedefs ]
      declarations . bindingGroups       = []
                   
      loc . (aset,cset,monoTable) = 
               performBindingGroup [] @declarations.typeSignatures @declarations.bindingGroups
               
          . (csetBinds,aset') = (typeEnvironment @lhs.importEnvironment .:::. @aset) @cinfo

---------------------------------------------------------------------------------------
-- Type Inferencing : Declaration, Declarations, MaybeDeclarations

ATTR Declaration Declarations MaybeDeclarations [ monos:Tps | betaUnique:Int | ]
ATTR Declaration Declarations                   [ monoTable:MonoTable | bindingGroups:BindingGroups | ]
ATTR                          MaybeDeclarations [ | assumptions:Assumptions constraints:ConstraintSet | ]

SEM Declaration

  | FunctionBindings
      lhs      . bindingGroups = @mybdggrp : @lhs.bindingGroups
      bindings . betaUnique    = @lhs.betaUnique + 2 + @bindings.numberOfPatterns
               . monos         = findMono @bindings.name @lhs.monoTable ++ @lhs.monos
      loc      . beta          = TVar @lhs.betaUnique
               . betaRight     = TVar (@lhs.betaUnique + 1)
               . betasLeft     = take @bindings.numberOfPatterns (map TVar [@lhs.betaUnique + 2..])
               . newcon        = [ (@beta .==. foldr (.->.) @betaRight @betasLeft) @cinfo ]
               . mybdggrp      = ( unitFM @bindings.name @beta
                                 , @bindings.assumptions
                                 , [ @newcon !<!
                                     ctNode [ ctVariable @lhs.betaUnique
                                            , ctNode @bindings.constraintslist
                                            ]
                                   ]
                                 )

  | PatternBinding
      lhs           . bindingGroups = @mybdggrp : @lhs.bindingGroups
      righthandside . monos         = findMono (head (keysFM @pattern.environment)) @lhs.monoTable ++ @lhs.monos
      loc           . newcon        = [ (@righthandside.beta .==. @pattern.beta) @cinfo ]
                    . mybdggrp      = ( @pattern.environment
                                      , @righthandside.assumptions
                                      , [ @newcon .>.
                                          ctNode [ @pattern.constraints
                                                 , @righthandside.constraints
                                                 ]
                                        ]
                                      )

SEM MaybeDeclarations
  | Just
      lhs          . assumptions    = @aset
                   . constraints    = @cset
      declarations . bindingGroups  = []
                   
      loc          . (aset,cset,monoTable) = 
                        performBindingGroup @lhs.monos @declarations.typeSignatures (@mybdggroup : @declarations.bindingGroups)
                                                
                   . mybdggroup     = (emptyFM,@lhs.assumptions,[@lhs.constraints])

---------------------------------------------------------------------------------------
-- Type Inferencing : FunctionBinding, FunctionBindings

ATTR FunctionBinding FunctionBindings [ betasLeft:Tps betaRight:Tp monos:Tps | betaUnique:Int | assumptions:Assumptions numberOfPatterns:Int name:Name ]
ATTR FunctionBinding                  [ | | constraints:ConstraintSet]
ATTR                 FunctionBindings [ | | constraintslist:ConstraintSets]

SEM FunctionBinding

  | FunctionBinding
      lhs           . assumptions = @assumptions'
                    . constraints = @csetBinds .>>.
                                    ctNode [ @conLeft  .<. @lefthandside.constraints
                                           , @conRight .<. @righthandside.constraints
                                           ]
      righthandside . monos       = eltsFM @lefthandside.environment ++ @lhs.monos
      loc           . (csetBinds,assumptions') = (@lefthandside.environment .===. @righthandside.assumptions) @cinfoBind
                    . conLeft     = zipWith4 (\t1 t2 txt nr -> (t1 .==. t2) (@cinfoLeft nr txt)) @lefthandside.betas @lhs.betasLeft @lefthandside.patternTrees [0..]
                    . conRight    = [ (@righthandside.beta .==. @lhs.betaRight) @cinfoRight ]

SEM FunctionBindings

  | Cons
      lhs . assumptions      = @hd.assumptions `combine` @tl.assumptions
          . numberOfPatterns = @hd.numberOfPatterns
          . name             = @hd.name
          . constraintslist  = @hd.constraints : @tl.constraintslist
  | Nil
      lhs . assumptions      = noAssumptions
          . numberOfPatterns = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(1)"
          . name             = internalError "TypeInferencing.ag" "n/a" "FunctionBindings(2)"
          . constraintslist  = []

---------------------------------------------------------------------------------------
-- Type Inferencing : LeftHandSide, RightHandSide

ATTR LeftHandSide RightHandSide [ | betaUnique:Int | constraints:ConstraintSet ]
ATTR LeftHandSide               [ | | betas:Tps environment:PatternAssumptions numberOfPatterns:Int name:Name ]
ATTR              RightHandSide [ monos:Tps | | assumptions:Assumptions beta:Tp ]

SEM LeftHandSide

  | Function
      lhs . constraints      = ctNode @patterns.constraintslist
          . name             = @name.self

  | Infix
      lhs . numberOfPatterns = 2
          . environment      = @leftPattern.environment `plusFM` @rightPattern.environment
          . betas            = [@leftPattern.beta,@rightPattern.beta]
          . constraints      = ctNode [ @leftPattern.constraints
                                      , @rightPattern.constraints
                                      ]
          . name             = @operator.self

  | Parenthesized
      lhs . numberOfPatterns = @lefthandside.numberOfPatterns + @patterns.numberOfPatterns
          . environment      = @lefthandside.environment `plusFM` @patterns.environment
          . betas            = @lefthandside.betas ++ @patterns.betas
          . constraints      = ctNode ( @lefthandside.constraints : @patterns.constraintslist )

SEM RightHandSide

  | Expression
     lhs   . assumptions = @where.assumptions
           . constraints = @where.constraints
     where . assumptions = @expression.assumptions
           . constraints = @expression.constraints

  | Guarded
     lhs                . assumptions    = @where.assumptions
                        . constraints    = @where.constraints
     guardedexpressions . betaUnique     = @lhs.betaUnique + 1
                        . rightBeta      = @beta
                        . numberOfGuards = length @guardedexpressions.constraintslist
     where              . assumptions    = @guardedexpressions.assumptions
                        . constraints    = ctNode @guardedexpressions.constraintslist
     loc                . beta           = TVar @lhs.betaUnique

---------------------------------------------------------------------------------------
-- Type Inferencing : Expression, Expressions, MaybeExpression, GuardedExpression, GuardedExpressions

ATTR Expression Expressions MaybeExpression GuardedExpression GuardedExpressions [ monos:Tps | betaUnique:Int | assumptions:Assumptions ]
ATTR Expression                             GuardedExpression                    [ | | beta:Tp constraints:ConstraintSet ]
ATTR            Expressions                                   GuardedExpressions [ | | betas:Tps constraintslist:ConstraintSets ]
ATTR                        MaybeExpression                                      [ | | beta:Tp constraints:ConstraintSet section:Bool ]
ATTR                                        GuardedExpression GuardedExpressions [ rightBeta:Tp | | ]
ATTR GuardedExpressions GuardedExpression [ numberOfGuards:Int | | ]

SEM Expression

  | Literal
      lhs . betaUnique  = @lhs.betaUnique + 1
          . assumptions = noAssumptions
      loc . constraints = ctSingle [ (@literal.literalType .==. @beta) @cinfo ]
          . beta        = TVar @lhs.betaUnique

  | Constructor
      lhs . betaUnique   = @lhs.betaUnique + 1
          . assumptions  = noAssumptions
      loc . constraints  = ctSingle @newcon
          . beta         = TVar @lhs.betaUnique
          . newcon       = case lookupFM (valueConstructors @lhs.importEnvironment) @name.self of
                              Nothing  -> []
                              Just ctp -> [ (@beta .::. ctp) @cinfo ]

  | Variable
      lhs . betaUnique  = @lhs.betaUnique + 1
          . assumptions = @name.self `single` @beta
      loc . constraints = ctNode [ ctVariable @lhs.betaUnique ]
          . beta        = TVar @lhs.betaUnique

  | NormalApplication
      lhs      . assumptions = @function.assumptions `combine` @arguments.assumptions
      function . betaUnique  = @lhs.betaUnique + 1
      loc      . constraints = @newcon .>.
                               ctNode [ @function.constraints
                                      , ctNode @arguments.constraintslist
                                      ]      
               . beta        = TVar @lhs.betaUnique
               . newcon      = [ (@function.beta .==. foldr (.->.) @beta @arguments.betas) @cinfo ]

  | InfixApplication
      lhs            . assumptions = @leftExpression.assumptions `combine` @operator.assumptions `combine` @rightExpression.assumptions
      leftExpression . betaUnique  = @lhs.betaUnique + 2
      loc            . constraints = @conTotal .>.
                                     ctNode [ @operator.constraints
                                            , @leftExpression.constraints
                                            , @rightExpression.constraints
                                            ]
                     . beta        = TVar @lhs.betaUnique
                     . betaResOp   = TVar (@lhs.betaUnique + 1)
                     . conOperator = (@operator.beta .==. @leftExpression.beta .->. @rightExpression.beta .->. @betaResOp) @cinfoOperator
                     . conTotal    = case (@leftExpression.section,@rightExpression.section) of
                                            (False,False) -> [ @conOperator, (@betaResOp     .==. @beta)                        @cinfoComplete     ]
                                            (True ,True ) -> [               (@operator.beta .==. @beta)                        @cinfoEmpty        ]
                                            (False,True ) -> [ @conOperator, (@rightExpression.beta .->. @betaResOp .==. @beta) @cinfoRightSection ]
                                            (True ,False) -> [ @conOperator, (@leftExpression.beta  .->. @betaResOp .==. @beta) @cinfoLeftSection  ]

  | If
      lhs             . assumptions = @guardExpression.assumptions `combine` @thenExpression.assumptions `combine` @elseExpression.assumptions
      guardExpression . betaUnique  = @lhs.betaUnique + 1
      loc             . constraints = ctNode [ @conGuard .<. @guardExpression.constraints
                                             , @conThen  .<. @thenExpression.constraints
                                             , @conElse  .<. @elseExpression.constraints
                                             ]
                      . beta        = TVar @lhs.betaUnique
                      . conGuard    = [ (@guardExpression.beta .==. boolType) @cinfoGuard ]
                      . conThen     = [ (@thenExpression.beta  .==. @beta   ) @cinfoThen  ]
                      . conElse     = [ (@elseExpression.beta  .==. @beta   ) @cinfoElse  ]

  | Lambda
      lhs        . assumptions = @assumptions'
      patterns   . betaUnique  = @lhs.betaUnique + 1
      expression . monos       = eltsFM @patterns.environment ++ @lhs.monos
      loc        . constraints = @newcon .>. @csetBinds .>>.
                                 ctNode [ ctNode @patterns.constraintslist
                                        , @expression.constraints
                                        ]
                 . beta        = TVar @lhs.betaUnique
                 . (csetBinds,assumptions') = (@patterns.environment .===. @expression.assumptions) @cinfoBind
                 . newcon      = [ (foldr (.->.) @expression.beta @patterns.betas .==. @beta) @cinfoType ]

  | Case
      lhs          . assumptions = @expression.assumptions `combine` @alternatives.assumptions
      expression   . betaUnique  = @lhs.betaUnique + 2
      alternatives . betaLeft    = @beta'
                   . betaRight   = @beta
                   . nrOfAlternatives = length @alternatives.constraintslist
      loc          . constraints = ctNode [ @newcon .<. @expression.constraints
                                          , ctNode @alternatives.constraintslist
                                          ]                   
                   . beta        = TVar @lhs.betaUnique
                   . beta'       = TVar (@lhs.betaUnique + 1)
                   . newcon      = [ (@expression.beta .==. @beta') @cinfo ]

  | Let
      lhs          . assumptions    = @aset
      declarations . betaUnique     = @lhs.betaUnique + 1
                   . bindingGroups  = []
      loc          . constraints    = [ (@expression.beta .==. @beta) @cinfoType ] .>. @cset                   
                   . beta           = TVar @lhs.betaUnique
                   . mybdggroup     = (noAssumptions,@expression.assumptions,[@expression.constraints])
                   
                   . (aset,cset,monoTable) = 
                        performBindingGroup @lhs.monos @declarations.typeSignatures (@mybdggroup : @declarations.bindingGroups)

  | Do
      lhs        . constraints   = ctNode [ @newcon .<. @statements.constraints ]
      statements . betaUnique    = @lhs.betaUnique + 1
                 . generatorBeta = Nothing
                 . assumptions   = noAssumptions
      loc        . constraints   = ctEmpty
                 . beta          = TVar @lhs.betaUnique
                 . newcon        = case @statements.generatorBeta of
                                      Nothing -> []
                                      Just b  -> [ (ioType b .==. @beta) @cinfo ]

  | List
      expressions . betaUnique   = @lhs.betaUnique + 2
      loc         . constraints  = @newcon .>.
                                    ctNode (zipWith3 @zipf @expressions.betas @childrenInfo @expressions.constraintslist)
                  . beta         = TVar @lhs.betaUnique
                  . beta'        = TVar (@lhs.betaUnique + 1)
                  . newcon       = [ (listType @beta' .==. @beta) @cinfoResult ]
                  . childrenInfo = zip @expressions.oneLineTree (map getExprRange @expressions.self)
                  . zipf         = \tp pair ctree -> [ (tp .==. @beta') (@cinfoElem pair) ] .<. ctree

  | Tuple
      expressions . betaUnique  = @lhs.betaUnique + 1
      loc         . constraints = @newcon .>. ctNode @expressions.constraintslist
                  . beta        = TVar @lhs.betaUnique
                  . newcon      = [ (tupleType @expressions.betas .==. @beta) @cinfo ]

  | Typed     
      expression . betaUnique  = @lhs.betaUnique + 1
      loc        . constraints = @conResult .>.
                                 ctNode [ @conExpr .<. @expression.constraints ]
                 . beta        = TVar @lhs.betaUnique
                 . typeScheme  = makeTpSchemeFromType @type.self 
                 . conResult   = [ (@beta            .::. @typeScheme) @cinfoResult ]
                 . conExpr     = [ (@expression.beta .::. @typeScheme) @cinfoExpr   ]

  | Comprehension
      lhs        . assumptions = @qualifiers.assumptions                 
      expression . betaUnique  = @lhs.betaUnique + 1
                 . monos       = @qualifiers.monos
      qualifiers . assumptions = @expression.assumptions
                 . constraints = @expression.constraints
                 . monos       = @lhs.monos
      loc        . constraints = @newcon .>. ctNode [ @qualifiers.constraints ]
                 . beta        = TVar @lhs.betaUnique
                 . newcon      = [ (listType @expression.beta .==. @beta) @cinfo ]

  | Enum
       lhs  . assumptions = @from.assumptions `combine` @then.assumptions `combine` @to.assumptions
       from . betaUnique  = @lhs.betaUnique + 1
       loc  . constraints = [ (listType intType .==. @beta) @cinfoResult ] .>.
                            ctNode [ @conFrom .<. @from.constraints
                                   , @conThen .<. @then.constraints
                                   , @conTo   .<. @to.constraints
                                   ]
            . beta        = TVar @lhs.betaUnique
            . conFrom     = [ (@from.beta .==. intType) @cinfoFrom ]
            . conThen     = [ (@then.beta .==. intType) @cinfoThen ]
            . conTo       = [ (@to.beta   .==. intType) @cinfoTo   ]

  | Negate
       expression . betaUnique  = @lhs.betaUnique + 1
       loc        . constraints = @newcon .>. ctNode [ @expression.constraints ]
                  . beta        = TVar @lhs.betaUnique
                  . newcon      = [ (intType .->. intType .==. @expression.beta .->. @beta) @cinfo]
--                  . conResult   = [ (intType .==. @beta) @cinfoResult ]
--                  . conExpr     = [ (@expression.beta .==. intType) @cinfoExpr]

  | NegateFloat
       expression . betaUnique  = @lhs.betaUnique + 1
       loc        . constraints = @newcon .>. ctNode [ @expression.constraints ]
                  . beta        = TVar @lhs.betaUnique
                  . newcon      = [ (floatType .->. floatType .==. @expression.beta .->. @beta) @cinfo]
--                  . conResult   = [ (floatType .==. @beta) @cinfoResult ]
--                  . conExpr     = [ (@expression.beta .==. floatType) @cinfoExpr]

SEM Expressions

  | Cons
      lhs . betas           = @hd.beta : @tl.betas
          . assumptions     = @hd.assumptions `combine` @tl.assumptions
          . constraintslist = @hd.constraints : @tl.constraintslist

  | Nil
      lhs . betas           = []
          . assumptions     = noAssumptions
          . constraintslist = []

SEM MaybeExpression

  | Just
      lhs . section = False

  | Nothing
      lhs . section     = True
          . betaUnique  = @lhs.betaUnique + 1
          . assumptions = noAssumptions
          . constraints = ctEmpty
      loc . beta        = TVar @lhs.betaUnique

SEM GuardedExpression

  | GuardedExpression
      lhs . beta        = @expression.beta
          . constraints = ctNode [ @newconGuard .<. @guard.constraints
                                 , @newconExpr  .<. @expression.constraints
                                 ]
          . assumptions = @guard.assumptions `combine` @expression.assumptions
      loc . newconGuard = [ (@guard.beta .==. boolType) @cinfoGuard ]
          . newconExpr  = [ (@expression.beta .==. @lhs.rightBeta) @cinfoExpr ]

SEM GuardedExpressions

  | Cons
      lhs . betas           = @hd.beta : @tl.betas
          . assumptions     = @hd.assumptions `combine` @tl.assumptions
          . constraintslist = @hd.constraints : @tl.constraintslist

  | Nil
      lhs . betas           = []
          . assumptions     = noAssumptions
          . constraintslist = []


---------------------------------------------------------------------------------------
-- Type Inferencing : Pattern

ATTR Pattern Patterns [ | betaUnique:Int | environment:PatternAssumptions ]
ATTR Pattern          [ | | beta:Tp constraints:ConstraintSet ]
ATTR         Patterns [ | | betas:Tps constraintslist:ConstraintSets numberOfPatterns:Int ]

SEM Pattern

  | Literal
      lhs . betaUnique  = @lhs.betaUnique + 1
          . environment = noAssumptions
          . constraints = ctSingle [ (@literal.literalType .==. @beta) @cinfo ]
      loc . beta        = TVar @lhs.betaUnique

  | Variable
      lhs . betaUnique  = @lhs.betaUnique + 1
          . environment = unitFM @name.self @beta
          . constraints = ctVariable @lhs.betaUnique
      loc . beta        = TVar @lhs.betaUnique

  | InfixConstructor
      lhs         . constraints    = @conApply .>.
                                     ctNode [ ctSingle @conConstructor
                                            , @leftPattern.constraints
                                            , @rightPattern.constraints
                                            ]
                  . environment    = @leftPattern.environment `plusFM` @rightPattern.environment
      leftPattern . betaUnique     = @lhs.betaUnique + 2
      loc         . beta           = TVar @lhs.betaUnique
                  . betaCon        = TVar (@lhs.betaUnique + 1)
                  . conApply       = [ (@betaCon .==. @leftPattern.beta .->. @rightPattern.beta .->. @beta) @cinfoApply ]
                  . conConstructor = case lookupFM (valueConstructors @lhs.importEnvironment) @constructorOperator.self  of
                                        Nothing  -> []
                                        Just ctp -> [ (@betaCon .::. ctp) @cinfoConstructor ]

  | Constructor
      lhs      . constraints    = @conApply .>.
                                  ctNode [ ctSingle @conConstructor
                                         , ctNode @patterns.constraintslist
                                         ]
      patterns . betaUnique     = @lhs.betaUnique + 2
      loc      . beta           = TVar (@lhs.betaUnique)
               . betaCon        = TVar (@lhs.betaUnique + 1)
               . conApply       = [ (@betaCon .==. foldr (.->.) @beta @patterns.betas) @cinfoApply ]             
               . conConstructor = case lookupFM (valueConstructors @lhs.importEnvironment) @name.self of
                                     Nothing  -> []
                                     Just ctp -> [ (@betaCon .::. ctp) @cinfoConstructor ]

  | As
      lhs     . environment = addToFM @pattern.environment @name.self @beta
              . constraints = @newcon .>.
                              ctNode [ ctVariable @lhs.betaUnique
                                     , @pattern.constraints
                                     ]
      pattern . betaUnique  = @lhs.betaUnique + 1
      loc     . beta        = TVar @lhs.betaUnique
              . newcon      = [ (@beta .==. @pattern.beta) @cinfo ]

  | Wildcard
      lhs . betaUnique  = @lhs.betaUnique + 1
          . environment = noAssumptions
          . constraints = ctEmpty
      loc . beta        = TVar @lhs.betaUnique

  | List
      lhs      . constraints  = @newcon .>.
                                ctNode (zipWith3 @zipf @patterns.betas @childrenInfo @patterns.constraintslist)
      patterns . betaUnique   = @lhs.betaUnique + 2
      loc      . beta         = TVar @lhs.betaUnique
               . beta'        = TVar (@lhs.betaUnique + 1)
               . newcon       = [ (listType @beta' .==. @beta) @cinfoResult ]
               . childrenInfo = zip @patterns.oneLineTree (map getPatRange @patterns.self)
               . zipf         = \tp pair ctree -> [ (tp .==. @beta') (@cinfoElem pair) ] .<. ctree

  | Tuple
      lhs      . constraints = @newcon .>. ctNode @patterns.constraintslist
      patterns . betaUnique  = @lhs.betaUnique + 1
      loc      . beta        = TVar @lhs.betaUnique
               . newcon      = [ (tupleType @patterns.betas .==. @beta) @cinfo ]

  | Negate
      lhs . constraints = ctSingle @newcon
          . betaUnique  = @lhs.betaUnique + 1
          . environment = noAssumptions
      loc . beta        = TVar @lhs.betaUnique
          . newcon      = [ (intType .==. @beta) @cinfo ]
          -- The parser only accepts an int literal after '-' in a Pattern
          -- . conPat      = [ (@literal.literalType .==. intType) @cinfoPat ]

  | NegateFloat
      lhs . constraints = ctSingle @newcon
          . betaUnique  = @lhs.betaUnique + 1
          . environment = noAssumptions
      loc . beta        = TVar @lhs.betaUnique
          . newcon      = [ (floatType .==. @beta) @cinfo ]
          -- The parser only accepts a float literal after '-.' in a Pattern
          -- . conPat      = [ (@literal.literalType .==. floatType) @cinfoPat ]

SEM Patterns

  | Cons
      lhs . betas            = @hd.beta : @tl.betas
          . environment      = @hd.environment `plusFM` @tl.environment
          . numberOfPatterns = 1 + @tl.numberOfPatterns
          . constraintslist  = @hd.constraints : @tl.constraintslist

  | Nil
      lhs . betas            = []
          . environment      = noAssumptions
          . numberOfPatterns = 0
          . constraintslist  = []

---------------------------------------------------------------------------------------
-- Type Inferencing : Alternative, Alternatives

ATTR Alternative Alternatives [ betaLeft:Tp betaRight:Tp monos:Tps | betaUnique:Int | assumptions:Assumptions ]
ATTR Alternative              [ | | constraints:ConstraintSet ]
ATTR             Alternatives [ | | constraintslist:ConstraintSets ]
ATTR Alternative Alternatives [ nrOfAlternatives:Int | | ]

SEM Alternative

  | Alternative
      lhs           . constraints = @csetBinds .>>.
                                    ctNode [ @conLeft  .<. @pattern.constraints
                                           , @conRight .<. @righthandside.constraints
                                           ]
                    . assumptions = @assumptions'
      righthandside . monos       = eltsFM @pattern.environment ++ @lhs.monos
      loc           . (csetBinds,assumptions') = (@pattern.environment .===. @righthandside.assumptions) @cinfoBind
                    . conLeft     = [ (@pattern.beta .==. @lhs.betaLeft) @cinfoLeft ]
                    . conRight    = [ (@righthandside.beta .==. @lhs.betaRight) @cinfoRight ]

  | Empty
      lhs . assumptions = noAssumptions
          . constraints = ctEmpty

SEM Alternatives

  | Cons
      lhs . assumptions     = @hd.assumptions `combine` @tl.assumptions
          . constraintslist = @hd.constraints : @tl.constraintslist

  | Nil
      lhs . assumptions     = noAssumptions
          . constraintslist = []

---------------------------------------------------------------------------------------
-- Type Inferencing : Statement, Statements, Qualifier, Qualifiers

ATTR Statement Statements Qualifier Qualifiers [ | assumptions:Assumptions betaUnique:Int constraints:ConstraintSet | ]
ATTR Statement Statements                      [ | generatorBeta:{Maybe Tp} | ]
ATTR Statement            Qualifier Qualifiers [ | monos:Tps | ]
ATTR           Statements                      [ monos:Tps | | ]

SEM Statement

  | Expression
      lhs        . generatorBeta = Just @beta
                 . constraints   = ctNode [ @newcon .<. @expression.constraints
                                          , @lhs.constraints
                                          ]
                 . assumptions   = @lhs.assumptions `combine` @expression.assumptions
      expression . betaUnique    = @lhs.betaUnique + 1
      loc        . beta          = TVar @lhs.betaUnique
                 . newcon        = [ (@expression.beta .==. ioType @beta) @cinfo ]

  | Let
      lhs          . generatorBeta  = Nothing
                   . assumptions    = @aset
                   . constraints    = @cset    
      declarations . bindingGroups  = []
      
      loc          . (aset,cset,monoTable) = 
                        performBindingGroup @lhs.monos @declarations.typeSignatures (@mybdggroup : @declarations.bindingGroups)
                        
                   . mybdggroup     = (noAssumptions ,@lhs.assumptions,[@lhs.constraints])

  | Generator
      lhs . generatorBeta = Nothing
          . constraints   = @newcon .>. @csetBinds .>>.
                            ctNode [ @pattern.constraints
                                   , @expression.constraints
                                   , @lhs.constraints
                                   ]
          . assumptions   = @assumptions' `combine` @expression.assumptions
          . monos         = eltsFM @pattern.environment ++ @lhs.monos
      loc . (csetBinds,assumptions') = (@pattern.environment .===. @lhs.assumptions) @cinfoBind
          . newcon        = [ (@expression.beta .==. ioType @pattern.beta) @cinfoResult ]

SEM Statements

  | Cons
      lhs . assumptions = @hd.assumptions
          . constraints = @hd.constraints
      hd  . assumptions = @tl.assumptions
          . constraints = @tl.constraints
      tl  . assumptions = @lhs.assumptions
          . constraints = @lhs.constraints

SEM Qualifier

  | Guard
      lhs . assumptions = @lhs.assumptions `combine` @guard.assumptions
          . constraints = ctNode [ @newcon .<. @guard.constraints
                                 , @lhs.constraints
                                 ]
      loc . newcon      = [ (@guard.beta .==. boolType) @cinfo ]

  | Let   lhs          . assumptions    = @aset
                       . constraints    = @cset
          declarations . bindingGroups  = []
          
          loc          . (aset,cset,monoTable) = 
                            performBindingGroup @lhs.monos @declarations.typeSignatures (@mybdggroup : @declarations.bindingGroups)
                            
                       . mybdggroup     = (noAssumptions,@lhs.assumptions,[@lhs.constraints])

  | Generator
      lhs . assumptions = @assumptions' `combine` @expression.assumptions
          . constraints = @newcon .>. @csetBinds .>>.
                          ctNode [ @pattern.constraints
                                 , @expression.constraints
                                 , @lhs.constraints
                                 ]
          . monos       = eltsFM @pattern.environment ++ @lhs.monos
      loc . (csetBinds,assumptions') = (@pattern.environment .===. @lhs.assumptions) @cinfoBind
          . newcon      = [ (@expression.beta .==. listType @pattern.beta) @cinfoResult ]

SEM Qualifiers

  | Cons
      lhs . assumptions = @hd.assumptions
          . constraints = @hd.constraints
      hd  . assumptions = @tl.assumptions
          . constraints = @tl.constraints
      tl  . assumptions = @lhs.assumptions
          . constraints = @lhs.constraints

---------------------------------------------------------------------------------------
-- Type Inferencing : Literal

ATTR Literal [ | | literalType:Tp ]

SEM Literal
  | Int     lhs . literalType = intType
  | Char    lhs . literalType = charType
  | String  lhs . literalType = stringType
  | Float   lhs . literalType = floatType

-------------------------------------------
-- Collecting Type Signatures

ATTR Declaration Declarations [ | typeSignatures:{FiniteMap Name TpScheme} | ]
ATTR Body                     [ | | typeSignatures:{FiniteMap Name TpScheme} ]

SEM Body              | Body    declarations . typeSignatures = emptyFM
SEM Expression        | Let     declarations . typeSignatures = emptyFM
SEM Statement         | Let     declarations . typeSignatures = emptyFM
SEM Qualifier         | Let     declarations . typeSignatures = emptyFM
SEM MaybeDeclarations | Just    declarations . typeSignatures = emptyFM

SEM Declaration
  | TypeSignature
      lhs . typeSignatures = addListToFM @lhs.typeSignatures [ (name, @typeScheme) | name <- @names.self ]
      loc . typeScheme     = makeTpSchemeFromType @type.self

-------------------------------------------
-- Collecting all Type Annotations (or: explicit type signatures)
-- These collected type annotations are checked afterwards.

ATTR Declarations Expression MaybeDeclarations RightHandSide Statement Statements
     RecordExpressionBindings RecordExpressionBinding Qualifier Qualifiers MaybeExpression
     GuardedExpression FunctionBinding FunctionBindings GuardedExpressions
     Expressions Declaration Alternative Alternatives Body
     [ | typeAnnotations : TypeAnnotations | ]

SEM Module
  | Module   body . typeAnnotations = []

SEM Expression
  | Typed  lhs . typeAnnotations = ((@lhs.monos,@expression.beta),@typeScheme,(@expression.oneLineTree,@range.self)) : @expression.typeAnnotations
  | Let    lhs . typeAnnotations = @anns ++ @expression.typeAnnotations

SEM MaybeDeclarations
  | Just   lhs . typeAnnotations = @anns ++ @declarations.typeAnnotations

SEM Body
  | Body   lhs . typeAnnotations = @anns ++ @declarations.typeAnnotations

SEM Statement
  | Let    lhs . typeAnnotations = @anns ++ @declarations.typeAnnotations

SEM Qualifier
  | Let    lhs . typeAnnotations = @anns ++ @declarations.typeAnnotations

---------------------------------------------------------------------------------------
-- Utility functions to perform the binding-group analysis

{
type Assumptions        = FiniteMap Name [(Name,Tp)]
type PatternAssumptions = FiniteMap Name Tp

noAssumptions :: FiniteMap Name a
noAssumptions = emptyFM

combine :: Assumptions -> Assumptions -> Assumptions
combine = plusFM_C (++)

single :: Name -> Tp -> Assumptions
single n t = unitFM n [(n,t)]


type BindingGroups = [BindingGroup]
type BindingGroup  = (PatternAssumptions,Assumptions,ConstraintSets)
type MonoTable    = [(Names,Tps)]

emptyBindingGroup :: BindingGroup
emptyBindingGroup = (noAssumptions, noAssumptions, [])

combineBindingGroup :: BindingGroup -> BindingGroup -> BindingGroup
combineBindingGroup (e1,a1,c1) (e2,a2,c2) = (e1 `plusFM` e2,a1 `combine` a2,c1++c2)

concatBindingGroups :: BindingGroups -> BindingGroup
concatBindingGroups = foldr combineBindingGroup emptyBindingGroup

type TypeAnnotations = [((Tps,Tp),TpScheme,(Tree,Range))]
type NoTypeDefs      = [(Name,Tps,Tp,Bool)]

findTypeAnnotations :: Bool -> Tps -> FiniteMap Name TpScheme -> BindingGroups -> (TypeAnnotations,NoTypeDefs)
findTypeAnnotations toplevel monos typeSignatures bdgs =
   let (environment,_,_) = concatBindingGroups bdgs
       typeAnnotations   = [ ((monos,tp),ts,(Text (show n),getNameRange n))
                           | (n,(tp,ts)) <- fmToList (intersectFM_C (,) environment typeSignatures)
                           ]
       noTypeDefs        = [ (n,monos,tp,toplevel)
                           | (n,tp) <- fmToList (delListFromFM environment (keysFM typeSignatures))
                           ]
   in (typeAnnotations,noTypeDefs)
                    
performBindingGroup :: Tps -> FiniteMap Name TpScheme -> BindingGroups -> (Assumptions,ConstraintSet,MonoTable)
performBindingGroup monos typeSignatures = variableDependencies . bindingGroupAnalysis

   where
        bindingGroupAnalysis :: BindingGroups -> BindingGroups
        bindingGroupAnalysis cs
                        = let explicits = keysFM typeSignatures
                              indexMap = concat (zipWith f cs [0..])
                              f (env,_,_) i = [ (n,i) | n <- keysFM env, n `notElem` explicits ]
                              edges    = concat (zipWith f' cs [0..])
                              f' (_,ass,_) i = [ (i,j)| n <- keysFM ass, (n',j) <- indexMap, n==n' ]
                              list = topSort (length cs-1) edges
                          in map (concatBindingGroups . map (cs !!)) list

        variableDependencies :: BindingGroups -> (Assumptions,ConstraintSet,MonoTable)
        variableDependencies = foldr op (noAssumptions,ctEmpty,[]) where
            op (e,a,c) (aset,cset,mt) =
               let (cset1,e'   ) = (typeSignatures !:::! e) cinfoBindingGroupExplicitTypedBinding
                   (cset5,aset') = (.<==.) monos e' aset    cinfoBindingGroupImplicit
                   (cset2,a'   ) = (typeSignatures .:::. a) cinfoBindingGroupExplicit
                   (cset3,a''  ) = (e' .===. a')            cinfoSameBindingGroup
               in ( a'' `combine` aset'
                  , cset2 .>>. cset3 .>>. cset5 .>>. 
                    ctStrictOrder [ cset1 .<<. ctNode (reverse c)
                                  , cset
                                  ] 
                  , (keysFM e,eltsFM e'):mt
                  )

findMono :: Name -> MonoTable -> Tps
findMono n = let p = elem n . fst
             in snd . head . filter p
}

SEM Body
  | Body   loc . (anns,notypedefs) = findTypeAnnotations True [] @declarations.typeSignatures @declarations.bindingGroups
SEM MaybeDeclarations
  | Just   loc . (anns,notypedefs) = findTypeAnnotations False @lhs.monos @declarations.typeSignatures (@mybdggroup : @declarations.bindingGroups)
SEM Expression                    
  | Let    loc . (anns,notypedefs) = findTypeAnnotations False @lhs.monos @declarations.typeSignatures (@mybdggroup : @declarations.bindingGroups)
SEM Statement                    
  | Let    loc . (anns,notypedefs) = findTypeAnnotations False @lhs.monos @declarations.typeSignatures (@mybdggroup : @declarations.bindingGroups)
SEM Qualifier                    
  | Let    loc . (anns,notypedefs) = findTypeAnnotations False @lhs.monos @declarations.typeSignatures (@mybdggroup : @declarations.bindingGroups)                 

-------------------------------------------
-- Collecting NoTypeDefs

ATTR Declarations Expression MaybeDeclarations RightHandSide Statement Statements
     RecordExpressionBindings RecordExpressionBinding Qualifier Qualifiers MaybeExpression
     GuardedExpression FunctionBinding FunctionBindings GuardedExpressions
     Expressions Declaration Alternative Alternatives Body
     [ | collectednotypedef : {[(Name,Tps,Tp,Bool)]} | ]

SEM Module
  | Module  body . collectednotypedef = [] 

SEM Body
  | Body  lhs . collectednotypedef = @notypedefs ++ @declarations.collectednotypedef

SEM MaybeDeclarations
  | Just  lhs . collectednotypedef = @notypedefs ++ @declarations.collectednotypedef

SEM Expression 
  | Let   lhs . collectednotypedef = @notypedefs ++ @declarations.collectednotypedef

SEM Statement
  | Let   lhs . collectednotypedef = @notypedefs ++ @declarations.collectednotypedef

SEM Qualifier  
  | Let   lhs . collectednotypedef = @notypedefs ++ @declarations.collectednotypedef
  
SEM Module 
  | Module loc . warnings  = 
        -- only a warning for top-level type definitions without 
        -- monomorphic type variables 
        let f (n,ms,t,isToplevel) = 
                           let ms'    = @substitution |-> ms
                               t'     = @substitution |-> t
                               scheme = generalize (ftv ms') [] t'
                           in if null (ftv scheme) && isToplevel
                                then [NoTypeDef n scheme isToplevel] 
                                else []
        in concatMap f @body.collectednotypedef
