-- do not edit; automatically generated by UU.AG
module TypeInferencing where


-- standard
import Monad                   ( when )
import List                    ( intersperse, partition, nub, zipWith4, union )
import Maybe (catMaybes, mapMaybe)
-- types
import Types
import TypeConversion
-- constraints
import TypeConstraints
import LiftedConstraints
import ConstraintTree
import TreeWalk
import Tree
-- messages
import Messages
import TypeErrors
import Warnings
-- solvers
import SolveTypeGraph
import TypeGraphInstance
import SolveGreedy           
import ConstraintInfo
import TypeGraphConstraintInfo
import HeliumConstraintInfo
import Constraints
import TypeConstraintSemantics
import SolveState
import IsSolver
import SimilarFunctionTable    ( similarFunctionTable )
-- other
import TopSort                 ( topSort )
import Utils                   ( internalError )
import DerivingShow            ( typeOfShowFunction, nameOfShowFunction ) 
import UHA_Range               ( noRange, getNameRange, getExprRange, getPatRange, getLitRange )
import UHA_Syntax
import UHA_Utils               ( showNameAsOperator )
import ImportEnvironment
import FiniteMap

import UHA_Utils

import OneLiner
import Char
import UHA_Utils (showNameAsOperator)
{-
import List (intersperse)
import SATypes (isTupleConstructor)
-}

import List
import Matchers
import TS_Apply (applyTypingStrategy, matchInformation, MetaVariableTable, MetaVariableInfo)
import TS_CoreSyntax

type Assumptions        = FiniteMap Name [(Name,Tp)]
type PatternAssumptions = FiniteMap Name Tp

noAssumptions :: FiniteMap Name a
noAssumptions = emptyFM

combine :: Assumptions -> Assumptions -> Assumptions
combine = plusFM_C (++)

single :: Name -> Tp -> Assumptions
single n t = unitFM n [(n,t)]

getMonos :: TypeConstraints info -> Tps
getMonos = map TVar . mapMaybe variableInConstraint

type BindingGroups = [BindingGroup]
type BindingGroup  = (PatternAssumptions,Assumptions,ConstraintSets)
type MonoTable     = [(Names,Tps)]

emptyBindingGroup :: BindingGroup
emptyBindingGroup = (noAssumptions, noAssumptions, [])

combineBindingGroup :: BindingGroup -> BindingGroup -> BindingGroup
combineBindingGroup (e1,a1,c1) (e2,a2,c2) = (e1 `plusFM` e2,a1 `combine` a2,c1++c2)

concatBindingGroups :: BindingGroups -> BindingGroup
concatBindingGroups = foldr combineBindingGroup emptyBindingGroup

type TypeAnnotations = [((Tps,Tp),TpScheme,(OneLineTree,Range))]
type NoTypeDefs      = [(Name,Tps,Tp,Bool)]

findTypeAnnotations :: Bool -> Tps -> FiniteMap Name TpScheme -> BindingGroups -> (TypeAnnotations,NoTypeDefs)
findTypeAnnotations toplevel monos typeSignatures bdgs =
   let (environment,_,_) = concatBindingGroups bdgs
       typeAnnotations   = [ ((monos,tp),ts,(OneLineText (show n),getNameRange n))
                           | (n,(tp,ts)) <- fmToList (intersectFM_C (,) environment typeSignatures)
                           ]
       noTypeDefs        = [ (n,monos,tp,toplevel)
                           | (n,tp) <- fmToList (delListFromFM environment (keysFM typeSignatures))
                           ]
   in (typeAnnotations,noTypeDefs)
                    
performBindingGroup :: Tps -> FiniteMap Name TpScheme -> BindingGroups -> (Assumptions,ConstraintSet,MonoTable)
performBindingGroup monos typeSignatures = variableDependencies . bindingGroupAnalysis

   where
        bindingGroupAnalysis :: BindingGroups -> BindingGroups
        bindingGroupAnalysis cs
                        = let explicits = keysFM typeSignatures
                              indexMap = concat (zipWith f cs [0..])
                              f (env,_,_) i = [ (n,i) | n <- keysFM env, n `notElem` explicits ]
                              edges    = concat (zipWith f' cs [0..])
                              f' (_,ass,_) i = [ (i,j)| n <- keysFM ass, (n',j) <- indexMap, n==n' ]
                              list = topSort (length cs-1) edges
                          in map (concatBindingGroups . map (cs !!)) list

        variableDependencies :: BindingGroups -> (Assumptions,ConstraintSet,MonoTable)
        variableDependencies = foldr op (noAssumptions,emptyTree,[]) where
            op (e,a,c) (aset,cset,mt) =
               let (cset1,e'   ) = (typeSignatures !:::! e) cinfoBindingGroupExplicitTypedBinding
                   (cset5,aset') = (.<==.) monos e' aset    cinfoBindingGroupImplicit
                   (cset2,a'   ) = (typeSignatures .:::. a) cinfoBindingGroupExplicit
                   (cset3,a''  ) = (e' .===. a')            cinfoSameBindingGroup
               in ( a'' `combine` aset'
                  , cset2 .>>. cset3 .>>. cset5 .>>. 
                      (StrictOrder (cset1 .<<. Node (reverse c)) cset)
                  , (keysFM e,eltsFM e'):mt
                  )

findMono :: Name -> MonoTable -> Tps
findMono n = let p = elem n . fst
             in snd . head . filter p

type LocalTypes          = FiniteMap NameWithRange TpScheme
type OverloadedVariables = FiniteMap NameWithRange (NameWithRange, QType)

convertTop :: WrappedSubstitution -> Predicates -> [(Name,Tps,Tp,Bool)] -> TypeEnvironment
convertTop sub predicates = listToFM . map f 
   where f (name,monos,tp,_) = 
            let monos' = ftv (sub |-> monos)
                tp'    = sub |-> tp 
            in (name, generalize monos' predicates tp')
 
convertLocal :: WrappedSubstitution -> Predicates -> [(Name,Tps,Tp,Bool)] -> LocalTypes
convertLocal sub predicates = listToFM . map f 
   where f (name,monos,tp,_) = 
            let monos' = ftv (sub |-> monos)
                tp'    = sub |-> tp 
            in (NameWithRange name, generalize monos' predicates tp')
            
equalNames :: Name -> Name -> Bool
equalNames n1 n2 = n1 == n2 && (getNameRange n1) `cmp` (getNameRange n2)            
   where cmp (Range_Range p1 p2) (Range_Range p3 p4) = p1 `cmp'` p3 && p2 `cmp'` p4
         cmp' Position_Unknown Position_Unknown = True
         cmp' p1 p2 = p1 == p2

cinfoBindingGroupExplicitTypedBinding :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoBindingGroupExplicitTypedBinding =
  \name tppair ->
  CInfo { info       = (NTBindingGroup,AltBindingGroup,3, "explicit typed binding, "++show name)
        , location   = "explicitly typed binding"
        , errorrange = getNameRange name
        , sources    = [ sourceTerm (OneLineText (show name))]
        , typepair   = tppair
        , properties = [ {- FolkloreConstraint -}
                         ExplicitTypedBinding
                       , HighlyTrusted 
                       ]
        }

variableBindingCInfo :: (InfoNT, InfoAlt, Int) -> Name -> (Tp,Tp) -> HeliumConstraintInfo
variableBindingCInfo (infoNT,infoAlt,i) var tppair =
  CInfo { info       = (infoNT,infoAlt,i,show var) 
        , location   = "variable"
        , errorrange = getNameRange var
        , sources    = [ sourceExpression (OneLineText (show var)) ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint ]  
        }

cinfoSameBindingGroup :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoSameBindingGroup var = variableBindingCInfo (NTBindingGroup,AltBindingGroup,0) var

cinfoBindingGroupImplicit :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoBindingGroupImplicit =
  \var tppair ->   
  CInfo { info       = (NTBindingGroup,AltBindingGroup,1,"implicit, "++show var)
        , location   = "variable"
        , errorrange = getNameRange var
        , sources    = [ sourceExpression (OneLineText (show var)) ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted ]
        }

cinfoBindingGroupExplicit :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoBindingGroupExplicit =
  \var tppair ->
  CInfo { info       = (NTBindingGroup,AltBindingGroup,2, "explicit, "++show var)
        , location   = "variable"
        , errorrange = getNameRange var
        , sources    = [ sourceExpression (OneLineText (show var)) ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint ]  
        }

convertMaybeOneLineTree :: Maybe OneLineTree -> OneLineTree
convertMaybeOneLineTree = maybe (OneLineText "") id
    
getRHSRange :: RightHandSide -> Range
getRHSRange (RightHandSide_Expression r _ _) = r
getRHSRange (RightHandSide_Guarded r _ _) = r

getMaybeExprRange :: MaybeExpression -> Range
getMaybeExprRange (MaybeExpression_Just expr) = getExprRange expr
getMaybeExprRange (MaybeExpression_Nothing)   = noRange

tpToInt :: Tp -> Int
tpToInt tp = case ftv tp of
               [i] -> i
               _   -> (-1)

sourceTerm, sourceExpression, sourcePattern, sourceOperator :: OneLineTree -> (String, OneLineTree)
sourceTerm        = (,) "term"
sourceExpression  = (,) "expression"
sourcePattern     = (,) "pattern"
sourceOperator    = (,) "operator"
sourceConstructor = (,) "constructor"

pmError = internalError "PatternMatchWarnings"

expandTypeFromImportEnvironment :: ImportEnvironment -> Tp -> Tp
expandTypeFromImportEnvironment env = expandType (snd $ getOrderedTypeSynonyms env)

patternMatchWarnings :: Substitution substitution
                     => ImportEnvironment          -- the importenvironment
                     -> substitution               -- substitution that contains the real types
                     -> Tp                         -- type of the patterns, unsubstituted
                     -> (Tp -> Tps)                -- how should the type be interpreted?
                     -> [([PatternElement], Bool)] -- the patterns to be processed
                     -> Range                      -- range for the missing-warnings
                     -> Maybe Name                 -- maybe the name of the function
                     -> Bool                       -- should there be parentheses around the patterns?
                     -> [Warning]                  -- list of overlap-warnings for all of the patterns  
                     -> String                     -- description of the place where the patterns are
                     -> String                     -- symbol after the patterns
                     -> [Warning]                  -- returns: list of warnings
patternMatchWarnings impenv sub tp strip elementss rng name parens unrwars place sym
  = unreachablewarnings ++ missingwarnings
    where
      env                 = importEnvironmentToEnv impenv
      exprtype            = expandTypeFromImportEnvironment impenv $ sub |-> tp
      types               = strip exprtype
      unreachables        = unreachable impenv types $ map (\((a, b), c) -> (a, c)) $ filter (not.snd.fst) $ zip elementss [0..]
      missing             = complement  impenv types $ map fst elementss
      unreachablewarnings = map (unrwars !!) unreachables
      missingwarnings
        | null $ unMissing missing = []
        | otherwise                = [MissingPatterns rng name exprtype (map (nicePattern parens env) $ missingList missing) place sym]


----------
-- misc --
----------

-- lifted or
(|^|) :: (a -> Bool) -> (a -> Bool) -> a -> Bool
(|^|) f g x = f x || g x

----------------------------------------------
--- environments and substitution of types ---
----------------------------------------------

-- environment of constructors [(type, (constructorname, arguments))]
type Env = [(Tp, (Name, [Tp]))]
importEnvironmentToEnv = map rearrange . fmToList . valueConstructors

-- return the number of arguments of a constructor
-- tuples ar not in the Env so they require special treatment
nrOfArguments :: Env -> String -> Int
nrOfArguments env con | isTupleConstructor con = length con - 1
                      | otherwise = case lookup (nameFromString con) $ map snd env
                                    of Just args -> length args
                                       Nothing   -> 0

-- convert constructor to fit in an Env
rearrange :: (Name, TpScheme) -> (Tp, (Name, [Tp]))
rearrange (name, tpscheme) = let (args, res) = functionSpine $ unqualify $ getQualifiedType tpscheme
                             in (res, (name, args))
  where
    unqualify :: QType -> Tp
    unqualify (_ :=> tp) = tp

-- get the constructors of a given type out of an Env
-- tuples ar not in the Env so they require special treatment
constructors :: ImportEnvironment -> Tp -> [(Name, [Tp])]
constructors _ (TVar _) = []
constructors impenv tp | isTupleConstructor name = [tupleconstructor]
                       | otherwise               = map expand $ concatMap (substitute tp) $ importEnvironmentToEnv impenv
  where
    name :: String
    name = unTCon $ fst $ leftSpine tp
    tupleconstructor :: (Name, [Tp])
    tupleconstructor = (nameFromString name, snd $ leftSpine tp)
    unTCon :: Tp -> String
    unTCon (TCon c) = c
    unTCon tp = pmError "unTCon" $ "type " ++ show tp ++ " is not a TCon"
    expand :: (Name, [Tp]) -> (Name, [Tp])
    expand (n, ts) = (n, map (expandTypeFromImportEnvironment impenv) ts)

-- check of an entry in an Env is a constructor for the given type
-- if so, return this constructor, but with variables substituted for whatever is in the given type
-- the list returns zero or one elements
-- for example: substitute (Maybe Int) (Maybe a, (Just, [a])) will return [(Just, [Int])]
substitute :: Tp -> (Tp, (Name, [Tp])) -> [(Name, [Tp])]
substitute t1 (t2, (con, args)) = let (c1, ts1) = leftSpine t1
                                      (c2, ts2) = leftSpine t2
                                      sub = listToSubstitution $ zip (map unTVar ts2) ts1
                                  in if c1 == c2
                                     then [(con, map (sub |->) args)]
                                     else []
  where
    unTVar :: Tp -> Int
    unTVar (TVar v) = v
    unTVar _ = pmError "unTVar" "type is not a TVar"

---------------------------------------------------------------
--- datastructures and functions for the solution structure ---
---------------------------------------------------------------

-- a pattern is a list of patternelements
data PatternElement = WildcardElement | InfiniteElement String | FiniteElement String deriving Eq
isInfiniteElement :: PatternElement -> Bool
isInfiniteElement (InfiniteElement _) = True
isInfiniteElement _                   = False
elementString :: PatternElement -> String
elementString (InfiniteElement s) = s
elementString (  FiniteElement s) = s
elementString _                   = []

-- needed for Pattern_List and Literal_String occurences
listPat :: [[PatternElement]] -> [PatternElement]
listPat [] = [FiniteElement "[]"]
listPat (ps:pss) = FiniteElement ":" : ps ++ listPat pss

stringPat :: String -> [PatternElement]
stringPat [] = [FiniteElement "[]"]
stringPat (c:cs) = FiniteElement ":" : InfiniteElement [c] : stringPat cs

-- tree of missing patterns
data PatternsMissing = PatternsMissing [(PatternElement, PatternsMissing)]
unMissing :: PatternsMissing -> [(PatternElement, PatternsMissing)]
unMissing (PatternsMissing l) = l

-- create a branch consisting of only wildcards
wildMissing :: Int -> PatternsMissing
wildMissing 0 = PatternsMissing []
wildMissing n = PatternsMissing [(WildcardElement, wildMissing $ n - 1)]

-- convert a missing patterns tree to a list of seperated missing patterns
missingList :: PatternsMissing -> [[PatternElement]]
missingList (PatternsMissing []) = [[]]
missingList (PatternsMissing [(d,t)]) = map (d:) $ missingList t
missingList (PatternsMissing (d:ds)) = (missingList $ PatternsMissing [d]) ++ (missingList $ PatternsMissing ds)

-------------------------------------------------------------------
--- functions to create a UHA_Pattern out of a [PatternElement] ---
-------------------------------------------------------------------

-- nice creates the actual pattern without parentheses
-- [Just, True, True, (,), Just, Nothing, False] -> [Just True, True, (Just Nothing, False)]
nicePattern :: Bool -> Env -> [PatternElement] -> [Pattern]
nicePattern b env = map (parensPattern b) . nice
  where
    nice :: [PatternElement] -> [Pattern]
    nice []             = []
    nice (WildcardElement    :ps) = Pattern_Wildcard noRange : nice ps
    nice (InfiniteElement _  :ps) = pmError "nicePattern" "InfiniteElement in pattern!"
    nice (FiniteElement con:ps) =
      let rest = nice ps
          name = nameFromString con
          n    = nrOfArguments env con
      in case name 
         of Name_Identifier _ _ _                          -> Pattern_Constructor noRange name (take n rest) : drop n rest
            Name_Operator   _ _ _ | con == ":"             -> case head $ tail rest
                                                              of Pattern_List _ ps -> Pattern_List noRange (head rest:ps) : (tail $ tail rest)
                                                                 _ -> Pattern_InfixConstructor noRange (head rest) name (head $ tail rest) : (tail $ tail rest)
                                  | otherwise              -> Pattern_InfixConstructor noRange (head rest) name (head $ tail rest) : (tail $ tail rest)
            Name_Special    _ _ _ | isTupleConstructor con -> Pattern_Tuple noRange (take n rest) : drop n rest
                                  | con == "[]"            -> Pattern_List  noRange [] : rest
                                  | otherwise              -> Pattern_Constructor noRange name (take n rest) : drop n rest

-- add parentheses to a pattern in the correct places
-- bool means: if needed, should there be parenthesis around the complete pattern?
parensPattern :: Bool -> Pattern -> Pattern
parensPattern b = if b then rap . par else fst . par
  where
    par :: Pattern -> (Pattern, Bool) -- Bool means: are parentheses needed around this pattern, shoud it be used in a more complex pattern
    par p@(Pattern_Literal          _ _    ) = (p, False)
    par p@(Pattern_Variable         _ _    ) = (p, False)
    par   (Pattern_Constructor      r n ps ) = (Pattern_Constructor r n $ map (rap.par) ps, length ps > 0)
    par   (Pattern_Parenthesized    _ p    ) = par p
    par   (Pattern_InfixConstructor r l n k) = (Pattern_InfixConstructor r (rap $ par l) n (rap $ par k), True)
    par   (Pattern_List             r ps   ) = (Pattern_List r $ map (fst.par) ps, False)
    par   (Pattern_Tuple            r ps   ) = (Pattern_Tuple r $ map (fst.par) ps, False)
    par   (Pattern_Record           _ _ _  ) = pmError "parensPattern" "Records are not supported" 
    par p@(Pattern_Negate           _ _    ) = (p, True)
    par p@(Pattern_NegateFloat      _ _    ) = (p, True)
    par   (Pattern_As               r n p  ) = (Pattern_As r n (rap $ par p), False)
    par p@(Pattern_Wildcard         _      ) = (p, False)
    par   (Pattern_Irrefutable      _ _    ) = pmError "parensPattern" "Irrefutable patterns are not supported"  
    par   (Pattern_Successor        _ _ _  ) = pmError "parensPattern" "Successors are not supported" 
    rap :: (Pattern, Bool) -> Pattern
    rap (p, False) = p
    rap (p, True ) = Pattern_Parenthesized noRange p

--------------------------------------
--- finally, the algorithm itself! ---
--------------------------------------

-- returns the tree of missing patterns for a given list of patterns    
complement :: ImportEnvironment -> [Tp] -> [[PatternElement]] -> PatternsMissing
complement _   []       _      = PatternsMissing []
complement _   _        ([]:_) = PatternsMissing []
complement env (tp:tps) pss    | null $ unMissing anyComplement                              = PatternsMissing []
                               | all (((== WildcardElement) |^| isInfiniteElement).head) pss = anyComplement
                               | otherwise                                                   = finComplement
  where
    patComplement :: [[PatternElement]] -> PatternElement -> [Tp] -> PatternsMissing
    patComplement []  current tps = PatternsMissing [(current, wildMissing $ length tps)]
    patComplement pss current tps = case unMissing $ complement env tps $ map tail $ pss
                                    of []   -> PatternsMissing []
                                       tegs -> PatternsMissing [(current, PatternsMissing tegs)]
    anyComplement :: PatternsMissing
    anyComplement = patComplement (filter ((== WildcardElement).head) pss) WildcardElement tps
    conComplement :: (Name, [Tp]) -> PatternsMissing
    conComplement (con, args) = patComplement (  filter ((== FiniteElement (getNameName con)).head) pss
                                              ++ map (\ps -> FiniteElement (getNameName con) : replicate (length args) WildcardElement ++ tail ps)
                                                     (filter ((== WildcardElement).head) pss)
                                              )
                                              (FiniteElement (getNameName con)) (args ++ tps)
    finComplement :: PatternsMissing
    finComplement = case constructors env tp
                    of []   -> wildMissing $ 1 + length tps
                       cons -> PatternsMissing $ concatMap (unMissing.conComplement) cons

----------------------------
--- unreachable patterns ---
----------------------------

-- complements the list of reachable patterns
unreachable :: ImportEnvironment -> [Tp] -> [([PatternElement], Int)] -> [Int]
unreachable env tps ps = let reach = reachable env tps ps
                         in  filter (not . flip elem reach) (map snd ps)

-- determines which patterns are reachable
-- possibly multiple occurances of indices
reachable :: ImportEnvironment -> [Tp] -> [([PatternElement], Int)] -> [Int]
reachable _   []       _  = pmError "reachable" "empty type list!"
reachable env (tp:tps) ps 
  | all ((== WildcardElement).head.fst) ps = conReachable ps
  | otherwise                              = concat $ map (conReachable.conPats) $ stop cons
  where
    cons :: [PatternElement]
    cons = thin $ map (head.fst) ps
    conPats :: PatternElement -> [([PatternElement], Int)]
    conPats con = map (\(es, i) -> (fill con es, i)) $ filter (((== con) |^| (== WildcardElement)).head.fst) ps
    fill :: PatternElement -> [PatternElement] -> [PatternElement]
    fill e@(FiniteElement c) (WildcardElement : es) = e : replicate (nrOfArguments (importEnvironmentToEnv env) c) WildcardElement ++ es
    fill e                   (_               : es) = e : es
    stop :: [PatternElement] -> [PatternElement]
    stop es | length (constructors env tp) > length es = FiniteElement "[*]" : es
            | length (constructors env tp) == 0        = FiniteElement "[*]" : es
            | otherwise                                = es
    conReachable :: [([PatternElement], Int)] -> [Int]
    conReachable [] = []
    conReachable pats 
      | null.tail.fst.head $ pats = [snd.head $ pats]
      | otherwise                 = reachable env (arguments (elementString.head.fst.head $ pats) ++ tps) 
                                            $ map (\(es, i) -> (tail es, i)) pats
    arguments :: String -> [Tp]
    arguments c = maybe [] id $ lookup c $ map (\(n, tps) -> (getNameName n, tps)) $ constructors env tp

-- remove double occurances and wildcards
thin :: [PatternElement] -> [PatternElement]
thin []                     = []
thin (WildcardElement : es) = thin es
thin (e               : es) | elem e thines =     thines
                            | otherwise     = e : thines
  where thines = thin es                            
                       


encloseSep :: String -> String -> String -> [OneLineTree] -> OneLineTree
encloseSep left sep right [] = OneLineNode [OneLineText left, OneLineText right]
encloseSep left sep right (t:ts) =
    OneLineNode ([ OneLineText left] ++ (t : concatMap (\t -> [OneLineText sep,t]) ts) ++ [OneLineText right] )

punctuate :: String -> [OneLineTree] -> OneLineTree
punctuate _ [] = OneLineText ""
punctuate _ [t] = t
punctuate s (t:ts) = OneLineNode (t : concatMap (\t -> [OneLineText s,t]) ts)
    
parens :: OneLineTree -> OneLineTree
parens tree = OneLineNode [ OneLineText "(", tree, OneLineText ")" ]

sepBy :: OneLineTree -> [OneLineTree] -> [OneLineTree]
sepBy separator list =
    intersperse separator (map (\x -> OneLineNode [x]) list)

intErr :: String -> String -> a
intErr node message = internalError "UHA_OneLine" node message

oneLineTreeAsOperator :: OneLineTree -> OneLineTree
oneLineTreeAsOperator tree =
   case tree of
      OneLineNode [OneLineText (first:_)]
         |  isAlpha first || first == '_'
         -> OneLineNode [ OneLineText "`", tree, OneLineText "`" ]
      _  -> tree
                  
type ScopeInfo = ( [Names]          -- duplicated variables
                 , [Name]           -- unused variables
                 , [(Name, Name)]   -- shadowed variables
                 )

changeOfScope :: Names -> Names -> Names -> (Names, Names, ScopeInfo)
changeOfScope names unboundNames namesInScope = 
   let (uniqueNames, duplicatedNames) = uniqueAppearance names
       unusedNames   = uniqueNames \\ unboundNames
       shadowedNames = let f n = [ (n, n') | n' <- namesInScope, n == n' ]
                       in concatMap f uniqueNames
   in ( uniqueNames ++ map head duplicatedNames ++ (namesInScope \\ names)
      , unboundNames \\ names
      , (duplicatedNames, unusedNames, shadowedNames)
      )
      
uniqueAppearance :: Ord a => [a] -> ([a],[[a]])
uniqueAppearance = foldr insert ([],[]) . group . sort
   where insert [x] (as,bs) = (x:as,bs)
         insert xs  (as,bs) = (as,xs:bs)

matchConverter0 :: [([String],())] -> ()
matchConverter0 = const ()

matchConverter1 :: [([String],a)] -> [(a,[String])]
matchConverter1 = map (\(a,b) -> (b,a))  
                  
matchConverter2 :: [([String],(a,b))] -> ([(a,[String])],[(b,[String])])
matchConverter2 = let insert (metas,(a,b)) (as,bs) = ((a,metas):as,(b,metas):bs)
                  in foldr insert ([],[])                  

matchConverter3 :: [([String],(a,b,c))] -> ([(a,[String])],[(b,[String])],[(c,[String])])
matchConverter3 = let insert (metas,(a,b,c)) (as,bs,cs) = ((a,metas):as,(b,metas):bs,(c,metas):cs)
                  in foldr insert ([],[],[]) 

allMatch :: [Maybe [a]] -> Maybe [a]
allMatch = rec []
  where rec xs []             = Just xs
        rec xs (Nothing:_)    = Nothing
        rec xs (Just ys:rest) = rec (ys ++ xs) rest

data Match a = NoMatch | NonTerminalMatch a | MetaVariableMatch String

instance Show (Match a) where
  show (NoMatch) = "NoMatch"
  show (NonTerminalMatch a) = "NonTerminal ??"
  show (MetaVariableMatch s) = "MetaVariableMatch "++show s

expressionVariableMatcher :: Expression -> Maybe String
expressionVariableMatcher expr =
   case expr of
      Expression_Variable _ name -> Just (show name)
      _                          -> Nothing

match0 = generalMatch expressionVariableMatcher matchConverter0
match1 = generalMatch expressionVariableMatcher matchConverter1
match2 = generalMatch expressionVariableMatcher matchConverter2
match3 = generalMatch expressionVariableMatcher matchConverter3

match0' = generalMatch noMatch matchConverter0 noMetaVariableInfo 0
match1' = generalMatch noMatch matchConverter1 noMetaVariableInfo 0
match2' = generalMatch noMatch matchConverter2 noMetaVariableInfo 0

matchOnlyVariable localInfo tryPats = 
   let ((),matches,_,_,_) = match0 localInfo 0 noMatch tryPats [] []
   in matches

noMatch :: a -> Maybe b
noMatch = const Nothing

--noMetaVariableInfo :: MetaVariableInfo
noMetaVariableInfo = internalError "PatternMatching.ag" "noMetaVariableInfo" ""

generalMatch :: (nonTerminal -> Maybe String) 
             -> ([([String], childrenTuple)] -> childrenResult)
             -> (ConstraintSet, MetaVariableInfo)
             -> Int             
             -> (nonTerminal -> Maybe childrenTuple) 
             -> [(nonTerminal, [String])] 
             -> [((nonTerminal, [String]), Core_TypingStrategy)] 
             -> [[Maybe (MetaVariableTable MetaVariableInfo)]] 
             -> ( childrenResult
                , [Maybe (MetaVariableTable MetaVariableInfo)]
                , ConstraintSet
                , Int
                , IO ()
                )

generalMatch exprVarMatcher converter metaVariableInfo unique matcher tryPats allPats childrenResults =
   let match (expr,metas) = 
          case exprVarMatcher expr of
             Just s | s `elem` metas -> MetaVariableMatch s
             _ -> case matcher expr of
                     Just x  -> NonTerminalMatch (metas,x)
                     Nothing -> NoMatch
           
       (allPatterns, allStrategies) = unzip allPats
       matchListTry = map match tryPats
       matchListNew = map match allPatterns
       
       matchNTTry  = [ x | NonTerminalMatch x <- matchListTry ]
       matchNTNew  = [ x | NonTerminalMatch x <- matchListNew ]
       forChildren = converter (matchNTTry ++ matchNTNew)
       
       numberOfTry = length matchNTTry
       (resultTry,resultNew) = unzip . map (splitAt numberOfTry) $ 
                               if null childrenResults
                                 then [repeat (Just [])]
                                 else childrenResults
       inspectMatch m (res, nts) =
          case m of
             NoMatch             -> (Nothing:res, nts)
             NonTerminalMatch _  -> (allMatch (head nts):res, tail nts)
             MetaVariableMatch s -> (Just [(s,(constraintSet, snd metaVariableInfo))]:res, nts) --  !!!
       
       result   = fst (foldr inspectMatch ([],reverse $ transpose resultTry) matchListTry)       
       complete = let (list,_) = foldr inspectMatch ([],reverse $ transpose resultNew) matchListNew
                  in [ (x, y) | (Just x, y) <- zip list allStrategies ]

       (constraintSet, debugIO, newUnique) = 
          case complete of
          
             [] -> (fst metaVariableInfo, return (), unique)
             
             (childrenInfo, typingStrategy):_ 
                -> applyTypingStrategy typingStrategy metaVariableInfo childrenInfo unique            
   in (forChildren, result, constraintSet, newUnique, debugIO)
   
     {-  msg = unlines [ "try-in: " ++ show (length tryPats)
              , "result: " ++ show (length result)
              , "strategies: " ++ show (length allStrategies)
              , "nt-match try: " ++ show (length matchNTTry)
              , "nt-match new: " ++ show (length matchNTNew)
              , "result try: " ++ if null childrenResults then "???" else show (length $ transpose resultTry)
              , "result new: " ++ if null childrenResults then "???" else show (map (map (maybe "N" (const "J"))) (transpose resultNew))
              , "complete matches: " ++ show (length complete)
              ] -}
-- Alternative -------------------------------------------------
-- semantic domain
type T_Alternative = ([((Expression, [String]), Core_TypingStrategy)]) ->
                     (Tp) ->
                     (Tp) ->
                     (Int) ->
                     ([(Name,Tps,Tp,Bool)]) ->
                     (ImportEnvironment) ->
                     (LocalTypes) ->
                     (IO ()) ->
                     (Tps) ->
                     (Names) ->
                     (Int) ->
                     (OverloadedVariables) ->
                     (Names) ->
                     ([Warning]) ->
                     (Predicates) ->
                     (WrappedSubstitution) ->
                     (TypeAnnotations) ->
                     ( (Assumptions),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),( ([PatternElement], Bool) ),(LocalTypes),(IO ()),(OneLineTree),(OverloadedVariables),([Warning]),(Alternative),(TypeAnnotations),(Names),(Warning))
-- cata
sem_Alternative :: (Alternative) ->
                   (T_Alternative)
sem_Alternative ((Alternative_Alternative (_range) (_pattern) (_righthandside))) =
    (sem_Alternative_Alternative ((sem_Range (_range))) ((sem_Pattern (_pattern))) ((sem_RightHandSide (_righthandside))))
sem_Alternative ((Alternative_Empty (_range))) =
    (sem_Alternative_Empty ((sem_Range (_range))))
sem_Alternative_Alternative :: (T_Range) ->
                               (T_Pattern) ->
                               (T_RightHandSide) ->
                               (T_Alternative)
sem_Alternative_Alternative (_range) (_pattern) (_righthandside) (_lhs_allPatterns) (_lhs_betaLeft) (_lhs_betaRight) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_nrOfAlternatives) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) =
    let (_self) =
            Alternative_Alternative _range_self _pattern_self _righthandside_self
        ((_csetBinds,_assumptions')) =
            (_pattern_environment .===. _righthandside_assumptions) _cinfoBind
        (_conLeft) =
            [ (_pattern_beta .==. _lhs_betaLeft) _cinfoLeft ]
        (_conRight) =
            [ (_righthandside_beta .==. _lhs_betaRight) _cinfoRight ]
        (_cinfoLeft) =
            \tppair ->
            CInfo { info       = (NTAlternative, AltAlternative, 0, "left")
                  , location   = "case pattern"
                  , errorrange = _range_self
                  , sources    = [ sourcePattern _pattern_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getPatRange _pattern_self) ]
                  }
        (_cinfoRight) =
            \tppair ->
            CInfo { info       = (NTAlternative, AltAlternative, 1, "right")
                  , location   = "right-hand side of case alternative"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression (_righthandside_oneLineTree "") ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getRHSRange _righthandside_self) ] ++
                                 if _lhs_nrOfAlternatives > 1 then [] else [ HighlyTrusted ]
                  }
        (_cinfoBind) =
            variableBindingCInfo (NTAlternative, AltAlternative, 2)
        (_oneLineTree) =
            OneLineNode [ _pattern_oneLineTree, _righthandside_oneLineTree " -> " ]
        ((_namesInScope,_unboundNames,_scopeInfo)) =
            changeOfScope _pattern_patVarNames _righthandside_unboundNames _lhs_namesInScope
        ( _range_self) =
            (_range )
        ( _pattern_beta,_pattern_betaUnique,_pattern_constraints,_pattern_elements,_pattern_environment,_pattern_oneLineTree,_pattern_patVarNames,_pattern_patternMatchWarnings,_pattern_self,_pattern_unboundNames) =
            (_pattern (_lhs_betaUnique) (_lhs_importEnvironment) (_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution))
        ( _righthandside_assumptions,_righthandside_beta,_righthandside_betaUnique,_righthandside_collectednotypedef,_righthandside_constraints,_righthandside_fallthrough,_righthandside_localTypes,_righthandside_matchIO,_righthandside_oneLineTree,_righthandside_overloadedVars,_righthandside_patternMatchWarnings,_righthandside_self,_righthandside_typeAnnotations,_righthandside_unboundNames) =
            (_righthandside (_lhs_allPatterns) (_pattern_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (eltsFM _pattern_environment ++ getMonos _csetBinds ++ _lhs_monos) (_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_pattern_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations))
    in  ( _assumptions'
         ,_righthandside_betaUnique
         ,_righthandside_collectednotypedef
         ,_csetBinds .>>.
          Node [ _conLeft  .<. _pattern_constraints
               , _conRight .<. _righthandside_constraints
               ]
         ,(_pattern_elements, _righthandside_fallthrough)
         ,_righthandside_localTypes
         ,_righthandside_matchIO
         ,_oneLineTree
         ,_righthandside_overloadedVars
         ,_righthandside_patternMatchWarnings
         ,_self
         ,_righthandside_typeAnnotations
         ,_unboundNames
         ,UnreachablePatternCase _range _pattern_self
         )
sem_Alternative_Empty :: (T_Range) ->
                         (T_Alternative)
sem_Alternative_Empty (_range) (_lhs_allPatterns) (_lhs_betaLeft) (_lhs_betaRight) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_nrOfAlternatives) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) =
    let (_self) =
            Alternative_Empty _range_self
        (_oneLineTree) =
            OneLineText ""
        ( _range_self) =
            (_range )
    in  ( noAssumptions,_lhs_betaUnique,_lhs_collectednotypedef,emptyTree,([], False),_lhs_localTypes,_lhs_matchIO,_oneLineTree,_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,[],pmError "Alternative_Empty.unrwar" "empty alternative")
-- Alternatives ------------------------------------------------
-- semantic domain
type T_Alternatives = ([((Expression, [String]), Core_TypingStrategy)]) ->
                      (Tp) ->
                      (Tp) ->
                      (Int) ->
                      ([(Name,Tps,Tp,Bool)]) ->
                      (ImportEnvironment) ->
                      (LocalTypes) ->
                      (IO ()) ->
                      (Tps) ->
                      (Names) ->
                      (Int) ->
                      (OverloadedVariables) ->
                      (Names) ->
                      ([Warning]) ->
                      (Predicates) ->
                      (WrappedSubstitution) ->
                      (TypeAnnotations) ->
                      ( (Assumptions),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSets),([([PatternElement], Bool)]),(LocalTypes),(IO ()),( [ OneLineTree] ),(OverloadedVariables),([Warning]),(Alternatives),(TypeAnnotations),(Names),([Warning]))
-- cata
sem_Alternatives :: (Alternatives) ->
                    (T_Alternatives)
sem_Alternatives (list) =
    (foldr (sem_Alternatives_Cons) (sem_Alternatives_Nil) ((map sem_Alternative list)))
sem_Alternatives_Cons :: (T_Alternative) ->
                         (T_Alternatives) ->
                         (T_Alternatives)
sem_Alternatives_Cons (_hd) (_tl) (_lhs_allPatterns) (_lhs_betaLeft) (_lhs_betaRight) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_nrOfAlternatives) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_assumptions,_hd_betaUnique,_hd_collectednotypedef,_hd_constraints,_hd_elements,_hd_localTypes,_hd_matchIO,_hd_oneLineTree,_hd_overloadedVars,_hd_patternMatchWarnings,_hd_self,_hd_typeAnnotations,_hd_unboundNames,_hd_unrwar) =
            (_hd (_lhs_allPatterns) (_lhs_betaLeft) (_lhs_betaRight) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_nrOfAlternatives) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations))
        ( _tl_assumptions,_tl_betaUnique,_tl_collectednotypedef,_tl_constraintslist,_tl_elementss,_tl_localTypes,_tl_matchIO,_tl_oneLineTree,_tl_overloadedVars,_tl_patternMatchWarnings,_tl_self,_tl_typeAnnotations,_tl_unboundNames,_tl_unrwars) =
            (_tl (_lhs_allPatterns) (_lhs_betaLeft) (_lhs_betaRight) (_hd_betaUnique) (_hd_collectednotypedef) (_lhs_importEnvironment) (_hd_localTypes) (_hd_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_nrOfAlternatives) (_hd_overloadedVars) (_lhs_overloads) (_hd_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_hd_typeAnnotations))
    in  ( _hd_assumptions `combine` _tl_assumptions,_tl_betaUnique,_tl_collectednotypedef,_hd_constraints : _tl_constraintslist,_hd_elements : _tl_elementss,_tl_localTypes,_tl_matchIO,_hd_oneLineTree  :  _tl_oneLineTree,_tl_overloadedVars,_tl_patternMatchWarnings,_self,_tl_typeAnnotations,_hd_unboundNames ++ _tl_unboundNames,_hd_unrwar   : _tl_unrwars)
sem_Alternatives_Nil :: (T_Alternatives)
sem_Alternatives_Nil (_lhs_allPatterns) (_lhs_betaLeft) (_lhs_betaRight) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_nrOfAlternatives) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) =
    let (_self) =
            []
    in  ( noAssumptions,_lhs_betaUnique,_lhs_collectednotypedef,[],[],_lhs_localTypes,_lhs_matchIO,[],_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,[],[])
-- AnnotatedType -----------------------------------------------
-- semantic domain
type T_AnnotatedType = (Names) ->
                       ( (AnnotatedType),(Names))
-- cata
sem_AnnotatedType :: (AnnotatedType) ->
                     (T_AnnotatedType)
sem_AnnotatedType ((AnnotatedType_AnnotatedType (_range) (_strict) (_type))) =
    (sem_AnnotatedType_AnnotatedType ((sem_Range (_range))) (_strict) ((sem_Type (_type))))
sem_AnnotatedType_AnnotatedType :: (T_Range) ->
                                   (Bool) ->
                                   (T_Type) ->
                                   (T_AnnotatedType)
sem_AnnotatedType_AnnotatedType (_range) (_strict) (_type) (_lhs_namesInScope) =
    let (_self) =
            AnnotatedType_AnnotatedType _range_self _strict _type_self
        ( _range_self) =
            (_range )
        ( _type_self) =
            (_type )
    in  ( _self,[])
-- AnnotatedTypes ----------------------------------------------
-- semantic domain
type T_AnnotatedTypes = (Names) ->
                        ( (AnnotatedTypes),(Names))
-- cata
sem_AnnotatedTypes :: (AnnotatedTypes) ->
                      (T_AnnotatedTypes)
sem_AnnotatedTypes (list) =
    (foldr (sem_AnnotatedTypes_Cons) (sem_AnnotatedTypes_Nil) ((map sem_AnnotatedType list)))
sem_AnnotatedTypes_Cons :: (T_AnnotatedType) ->
                           (T_AnnotatedTypes) ->
                           (T_AnnotatedTypes)
sem_AnnotatedTypes_Cons (_hd) (_tl) (_lhs_namesInScope) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_self,_hd_unboundNames) =
            (_hd (_lhs_namesInScope))
        ( _tl_self,_tl_unboundNames) =
            (_tl (_lhs_namesInScope))
    in  ( _self,_hd_unboundNames ++ _tl_unboundNames)
sem_AnnotatedTypes_Nil :: (T_AnnotatedTypes)
sem_AnnotatedTypes_Nil (_lhs_namesInScope) =
    let (_self) =
            []
    in  ( _self,[])
-- Body --------------------------------------------------------
-- semantic domain
type T_Body = ([((Expression, [String]), Core_TypingStrategy)]) ->
              (Int) ->
              ([(Name,Tps,Tp,Bool)]) ->
              (ImportEnvironment) ->
              (LocalTypes) ->
              (IO ()) ->
              (Tps) ->
              (Names) ->
              (OverloadedVariables) ->
              (Names) ->
              ([Warning]) ->
              (Predicates) ->
              (WrappedSubstitution) ->
              (TypeAnnotations) ->
              ( (Assumptions),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(Names),(LocalTypes),(IO ()),([(Name,Tp)]),(OverloadedVariables),([Warning]),(Body),(TypeEnvironment),(TypeAnnotations),(Names))
-- cata
sem_Body :: (Body) ->
            (T_Body)
sem_Body ((Body_Body (_range) (_importdeclarations) (_declarations))) =
    (sem_Body_Body ((sem_Range (_range))) ((sem_ImportDeclarations (_importdeclarations))) ((sem_Declarations (_declarations))))
sem_Body_Body :: (T_Range) ->
                 (T_ImportDeclarations) ->
                 (T_Declarations) ->
                 (T_Body)
sem_Body_Body (_range) (_importdeclarations) (_declarations) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) =
    let (_self) =
            Body_Body _range_self _importdeclarations_self _declarations_self
        ((_aset,_cset,_monoTable)) =
            performBindingGroup [] _declarations_typeSignatures _declarations_bindingGroups
        ((_csetBinds,_aset')) =
            (typeEnvironment _lhs_importEnvironment .:::. _aset) _cinfo
        ((_anns,_notypedefs)) =
            findTypeAnnotations True [] _declarations_typeSignatures _declarations_bindingGroups
        (_cinfo) =
            \var tppair ->
            CInfo { info       = (NTBody, AltBody, 0, show var)
                  , location   = "variable"
                  , errorrange = getNameRange var
                  , sources    = [ sourceExpression (OneLineText (show var)) ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , HighlyTrusted
                                 , IsImported var
                                 ]
                  }
        ( _range_self) =
            (_range )
        ( _importdeclarations_self) =
            (_importdeclarations )
        ( _declarations_betaUnique,_declarations_bindingGroups,_declarations_collectednotypedef,_declarations_declVarNames,_declarations_localTypes,_declarations_matchIO,_declarations_oneLineTree,_declarations_overloadedVars,_declarations_patternMatchWarnings,_declarations_self,_declarations_typeAnnotations,_declarations_typeSignatures,_declarations_unboundNames) =
            (_declarations (_lhs_allPatterns) (_lhs_betaUnique) ([]) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_monoTable) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (emptyFM))
    in  ( _aset'
         ,_declarations_betaUnique
         ,_notypedefs ++ _declarations_collectednotypedef
         ,Node [ _csetBinds .<<. _cset ]
         ,_declarations_declVarNames
         ,_declarations_localTypes
         ,_declarations_matchIO
         ,[ (n,tp) | (n,_,tp,_) <- _notypedefs ]
         ,_declarations_overloadedVars
         ,_declarations_patternMatchWarnings
         ,_self
         ,convertTop _lhs_substitution _lhs_predicates _notypedefs `plusFM` _declarations_typeSignatures
         ,_anns ++ _declarations_typeAnnotations
         ,_declarations_unboundNames
         )
-- Constructor -------------------------------------------------
-- semantic domain
type T_Constructor = (Names) ->
                     ( (Constructor),(Names))
-- cata
sem_Constructor :: (Constructor) ->
                   (T_Constructor)
sem_Constructor ((Constructor_Constructor (_range) (_constructor) (_types))) =
    (sem_Constructor_Constructor ((sem_Range (_range))) ((sem_Name (_constructor))) ((sem_AnnotatedTypes (_types))))
sem_Constructor ((Constructor_Infix (_range) (_leftType) (_constructorOperator) (_rightType))) =
    (sem_Constructor_Infix ((sem_Range (_range))) ((sem_AnnotatedType (_leftType))) ((sem_Name (_constructorOperator))) ((sem_AnnotatedType (_rightType))))
sem_Constructor ((Constructor_Record (_range) (_constructor) (_fieldDeclarations))) =
    (sem_Constructor_Record ((sem_Range (_range))) ((sem_Name (_constructor))) ((sem_FieldDeclarations (_fieldDeclarations))))
sem_Constructor_Constructor :: (T_Range) ->
                               (T_Name) ->
                               (T_AnnotatedTypes) ->
                               (T_Constructor)
sem_Constructor_Constructor (_range) (_constructor) (_types) (_lhs_namesInScope) =
    let (_self) =
            Constructor_Constructor _range_self _constructor_self _types_self
        ( _range_self) =
            (_range )
        ( _constructor_isIdentifier,_constructor_isOperator,_constructor_isSpecial,_constructor_oneLineTree,_constructor_self) =
            (_constructor )
        ( _types_self,_types_unboundNames) =
            (_types (_lhs_namesInScope))
    in  ( _self,_types_unboundNames)
sem_Constructor_Infix :: (T_Range) ->
                         (T_AnnotatedType) ->
                         (T_Name) ->
                         (T_AnnotatedType) ->
                         (T_Constructor)
sem_Constructor_Infix (_range) (_leftType) (_constructorOperator) (_rightType) (_lhs_namesInScope) =
    let (_self) =
            Constructor_Infix _range_self _leftType_self _constructorOperator_self _rightType_self
        ( _range_self) =
            (_range )
        ( _leftType_self,_leftType_unboundNames) =
            (_leftType (_lhs_namesInScope))
        ( _constructorOperator_isIdentifier,_constructorOperator_isOperator,_constructorOperator_isSpecial,_constructorOperator_oneLineTree,_constructorOperator_self) =
            (_constructorOperator )
        ( _rightType_self,_rightType_unboundNames) =
            (_rightType (_lhs_namesInScope))
    in  ( _self,_leftType_unboundNames ++ _rightType_unboundNames)
sem_Constructor_Record :: (T_Range) ->
                          (T_Name) ->
                          (T_FieldDeclarations) ->
                          (T_Constructor)
sem_Constructor_Record (_range) (_constructor) (_fieldDeclarations) (_lhs_namesInScope) =
    let (_self) =
            Constructor_Record _range_self _constructor_self _fieldDeclarations_self
        ( _range_self) =
            (_range )
        ( _constructor_isIdentifier,_constructor_isOperator,_constructor_isSpecial,_constructor_oneLineTree,_constructor_self) =
            (_constructor )
        ( _fieldDeclarations_self,_fieldDeclarations_unboundNames) =
            (_fieldDeclarations (_lhs_namesInScope))
    in  ( _self,_fieldDeclarations_unboundNames)
-- Constructors ------------------------------------------------
-- semantic domain
type T_Constructors = (Names) ->
                      ( (Constructors),(Names))
-- cata
sem_Constructors :: (Constructors) ->
                    (T_Constructors)
sem_Constructors (list) =
    (foldr (sem_Constructors_Cons) (sem_Constructors_Nil) ((map sem_Constructor list)))
sem_Constructors_Cons :: (T_Constructor) ->
                         (T_Constructors) ->
                         (T_Constructors)
sem_Constructors_Cons (_hd) (_tl) (_lhs_namesInScope) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_self,_hd_unboundNames) =
            (_hd (_lhs_namesInScope))
        ( _tl_self,_tl_unboundNames) =
            (_tl (_lhs_namesInScope))
    in  ( _self,_hd_unboundNames ++ _tl_unboundNames)
sem_Constructors_Nil :: (T_Constructors)
sem_Constructors_Nil (_lhs_namesInScope) =
    let (_self) =
            []
    in  ( _self,[])
-- ContextItem -------------------------------------------------
-- semantic domain
type T_ContextItem = ( (ContextItem))
-- cata
sem_ContextItem :: (ContextItem) ->
                   (T_ContextItem)
sem_ContextItem ((ContextItem_ContextItem (_range) (_name) (_types))) =
    (sem_ContextItem_ContextItem ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Types (_types))))
sem_ContextItem_ContextItem :: (T_Range) ->
                               (T_Name) ->
                               (T_Types) ->
                               (T_ContextItem)
sem_ContextItem_ContextItem (_range) (_name) (_types) =
    let (_self) =
            ContextItem_ContextItem _range_self _name_self _types_self
        (_tyconEnv) =
            internalError "PartialSyntax.ag" "n/a" "ContextItem.ContextItem"
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _types_self) =
            (_types )
    in  ( _self)
-- ContextItems ------------------------------------------------
-- semantic domain
type T_ContextItems = ( (ContextItems))
-- cata
sem_ContextItems :: (ContextItems) ->
                    (T_ContextItems)
sem_ContextItems (list) =
    (foldr (sem_ContextItems_Cons) (sem_ContextItems_Nil) ((map sem_ContextItem list)))
sem_ContextItems_Cons :: (T_ContextItem) ->
                         (T_ContextItems) ->
                         (T_ContextItems)
sem_ContextItems_Cons (_hd) (_tl) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  ( _self)
sem_ContextItems_Nil :: (T_ContextItems)
sem_ContextItems_Nil  =
    let (_self) =
            []
    in  ( _self)
-- Declaration -------------------------------------------------
-- semantic domain
type T_Declaration = ([((Expression, [String]), Core_TypingStrategy)]) ->
                     (Int) ->
                     (BindingGroups) ->
                     ([(Name,Tps,Tp,Bool)]) ->
                     (ImportEnvironment) ->
                     (LocalTypes) ->
                     (IO ()) ->
                     (MonoTable) ->
                     (Tps) ->
                     (Names) ->
                     (OverloadedVariables) ->
                     (Names) ->
                     ([Warning]) ->
                     (Predicates) ->
                     (WrappedSubstitution) ->
                     (TypeAnnotations) ->
                     (FiniteMap Name TpScheme) ->
                     ( (Int),(BindingGroups),([(Name,Tps,Tp,Bool)]),(Names),(LocalTypes),(IO ()),(OneLineTree),(OverloadedVariables),([Warning]),(Declaration),(TypeAnnotations),(FiniteMap Name TpScheme),(Names))
-- cata
sem_Declaration :: (Declaration) ->
                   (T_Declaration)
sem_Declaration ((Declaration_Class (_range) (_context) (_simpletype) (_where))) =
    (sem_Declaration_Class ((sem_Range (_range))) ((sem_ContextItems (_context))) ((sem_SimpleType (_simpletype))) ((sem_MaybeDeclarations (_where))))
sem_Declaration ((Declaration_Data (_range) (_context) (_simpletype) (_constructors) (_derivings))) =
    (sem_Declaration_Data ((sem_Range (_range))) ((sem_ContextItems (_context))) ((sem_SimpleType (_simpletype))) ((sem_Constructors (_constructors))) ((sem_Names (_derivings))))
sem_Declaration ((Declaration_Default (_range) (_types))) =
    (sem_Declaration_Default ((sem_Range (_range))) ((sem_Types (_types))))
sem_Declaration ((Declaration_Empty (_range))) =
    (sem_Declaration_Empty ((sem_Range (_range))))
sem_Declaration ((Declaration_Fixity (_range) (_fixity) (_priority) (_operators))) =
    (sem_Declaration_Fixity ((sem_Range (_range))) ((sem_Fixity (_fixity))) ((sem_MaybeInt (_priority))) ((sem_Names (_operators))))
sem_Declaration ((Declaration_FunctionBindings (_range) (_bindings))) =
    (sem_Declaration_FunctionBindings ((sem_Range (_range))) ((sem_FunctionBindings (_bindings))))
sem_Declaration ((Declaration_Instance (_range) (_context) (_name) (_types) (_where))) =
    (sem_Declaration_Instance ((sem_Range (_range))) ((sem_ContextItems (_context))) ((sem_Name (_name))) ((sem_Types (_types))) ((sem_MaybeDeclarations (_where))))
sem_Declaration ((Declaration_Newtype (_range) (_context) (_simpletype) (_constructor) (_derivings))) =
    (sem_Declaration_Newtype ((sem_Range (_range))) ((sem_ContextItems (_context))) ((sem_SimpleType (_simpletype))) ((sem_Constructor (_constructor))) ((sem_Names (_derivings))))
sem_Declaration ((Declaration_PatternBinding (_range) (_pattern) (_righthandside))) =
    (sem_Declaration_PatternBinding ((sem_Range (_range))) ((sem_Pattern (_pattern))) ((sem_RightHandSide (_righthandside))))
sem_Declaration ((Declaration_Type (_range) (_simpletype) (_type))) =
    (sem_Declaration_Type ((sem_Range (_range))) ((sem_SimpleType (_simpletype))) ((sem_Type (_type))))
sem_Declaration ((Declaration_TypeSignature (_range) (_names) (_type))) =
    (sem_Declaration_TypeSignature ((sem_Range (_range))) ((sem_Names (_names))) ((sem_Type (_type))))
sem_Declaration_Class :: (T_Range) ->
                         (T_ContextItems) ->
                         (T_SimpleType) ->
                         (T_MaybeDeclarations) ->
                         (T_Declaration)
sem_Declaration_Class (_range) (_context) (_simpletype) (_where) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_typeSignatures) =
    let (_self) =
            Declaration_Class _range_self _context_self _simpletype_self _where_self
        ((_assumptions,_constraints,_unboundNames)) =
            internalError "PartialSyntax.ag" "n/a" "Declaration.Class"
        (_oneLineTree) =
            intErr "Declaration" "class"
        ( _range_self) =
            (_range )
        ( _context_self) =
            (_context )
        ( _simpletype_self) =
            (_simpletype )
        ( _where_assumptions,_where_betaUnique,_where_collectednotypedef,_where_constraints,_where_localTypes,_where_matchIO,_where_namesInScope,_where_oneLineTree,_where_overloadedVars,_where_patternMatchWarnings,_where_self,_where_typeAnnotations,_where_unboundNames) =
            (_where (_lhs_allPatterns) (_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_constraints) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_unboundNames))
    in  ( _where_betaUnique,_lhs_bindingGroups,_where_collectednotypedef,[],_where_localTypes,_where_matchIO,_oneLineTree,_where_overloadedVars,_where_patternMatchWarnings,_self,_where_typeAnnotations,_lhs_typeSignatures,_unboundNames)
sem_Declaration_Data :: (T_Range) ->
                        (T_ContextItems) ->
                        (T_SimpleType) ->
                        (T_Constructors) ->
                        (T_Names) ->
                        (T_Declaration)
sem_Declaration_Data (_range) (_context) (_simpletype) (_constructors) (_derivings) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_typeSignatures) =
    let (_self) =
            Declaration_Data _range_self _context_self _simpletype_self _constructors_self _derivings_self
        (_oneLineTree) =
            intErr "Declaration" "data"
        ( _range_self) =
            (_range )
        ( _context_self) =
            (_context )
        ( _simpletype_self) =
            (_simpletype )
        ( _constructors_self,_constructors_unboundNames) =
            (_constructors (_lhs_namesInScope))
        ( _derivings_isIdentifier,_derivings_isOperator,_derivings_isSpecial,_derivings_oneLineTree,_derivings_self) =
            (_derivings )
    in  ( _lhs_betaUnique,_lhs_bindingGroups,_lhs_collectednotypedef,[],_lhs_localTypes,_lhs_matchIO,_oneLineTree,_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,_lhs_typeSignatures,_constructors_unboundNames)
sem_Declaration_Default :: (T_Range) ->
                           (T_Types) ->
                           (T_Declaration)
sem_Declaration_Default (_range) (_types) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_typeSignatures) =
    let (_self) =
            Declaration_Default _range_self _types_self
        (_oneLineTree) =
            intErr "Declaration" "default"
        ( _range_self) =
            (_range )
        ( _types_self) =
            (_types )
    in  ( _lhs_betaUnique,_lhs_bindingGroups,_lhs_collectednotypedef,[],_lhs_localTypes,_lhs_matchIO,_oneLineTree,_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,_lhs_typeSignatures,[])
sem_Declaration_Empty :: (T_Range) ->
                         (T_Declaration)
sem_Declaration_Empty (_range) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_typeSignatures) =
    let (_self) =
            Declaration_Empty _range_self
        (_oneLineTree) =
            OneLineText ""
        ( _range_self) =
            (_range )
    in  ( _lhs_betaUnique,_lhs_bindingGroups,_lhs_collectednotypedef,[],_lhs_localTypes,_lhs_matchIO,_oneLineTree,_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,_lhs_typeSignatures,[])
sem_Declaration_Fixity :: (T_Range) ->
                          (T_Fixity) ->
                          (T_MaybeInt) ->
                          (T_Names) ->
                          (T_Declaration)
sem_Declaration_Fixity (_range) (_fixity) (_priority) (_operators) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_typeSignatures) =
    let (_self) =
            Declaration_Fixity _range_self _fixity_self _priority_self _operators_self
        (_oneLineTree) =
            intErr "Declaration" "fixity"
        ( _range_self) =
            (_range )
        ( _fixity_self) =
            (_fixity )
        ( _priority_self) =
            (_priority )
        ( _operators_isIdentifier,_operators_isOperator,_operators_isSpecial,_operators_oneLineTree,_operators_self) =
            (_operators )
    in  ( _lhs_betaUnique,_lhs_bindingGroups,_lhs_collectednotypedef,[],_lhs_localTypes,_lhs_matchIO,_oneLineTree,_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,_lhs_typeSignatures,[])
sem_Declaration_FunctionBindings :: (T_Range) ->
                                    (T_FunctionBindings) ->
                                    (T_Declaration)
sem_Declaration_FunctionBindings (_range) (_bindings) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_typeSignatures) =
    let (_self) =
            Declaration_FunctionBindings _range_self _bindings_self
        (_beta) =
            TVar _lhs_betaUnique
        (_betaRight) =
            TVar (_lhs_betaUnique + 1)
        (_betasLeft) =
            take _bindings_numberOfPatterns (map TVar [_lhs_betaUnique + 2..])
        (_newcon) =
            (_beta .==. foldr (.->.) _betaRight _betasLeft) _cinfo
        (_mybdggrp) =
            ( unitFM _bindings_name _beta
            , _bindings_assumptions
            , [ Node [ Phase (-1) [_newcon]
                     , Receive _lhs_betaUnique
                     , Node _bindings_constraintslist
                     ]
              ]
            )
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTDeclaration, AltFunctionBindings, 0, show _bindings_name)
                  , location   = "function bindings (INTERNAL ERROR)"
                  , errorrange = _range_self
                  , sources    = [ ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , SuperHighlyTrusted
                                 , FuntionBindingEdge _bindings_numberOfPatterns
                                 ]
                  }
        (_oneLineTree) =
            punctuate ";" _bindings_oneLineTree
        ( _range_self) =
            (_range )
        ( _bindings_argcount,_bindings_assumptions,_bindings_betaUnique,_bindings_collectednotypedef,_bindings_constraintslist,_bindings_elementss,_bindings_localTypes,_bindings_matchIO,_bindings_name,_bindings_numberOfPatterns,_bindings_oneLineTree,_bindings_overloadedVars,_bindings_patternMatchWarnings,_bindings_self,_bindings_typeAnnotations,_bindings_unboundNames,_bindings_unrwars) =
            (_bindings (_lhs_allPatterns) (_betaRight) (_lhs_betaUnique + 2 + _bindings_numberOfPatterns) (_betasLeft) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (findMono _bindings_name _lhs_monoTable ++ _lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations))
    in  ( _bindings_betaUnique
         ,_mybdggrp : _lhs_bindingGroups
         ,_bindings_collectednotypedef
         ,[_bindings_name]
         ,_bindings_localTypes
         ,_bindings_matchIO
         ,_oneLineTree
         ,_bindings_overloadedVars
         ,patternMatchWarnings _lhs_importEnvironment
                               _lhs_substitution
                               _beta
                               (take _bindings_argcount . fst . functionSpine)
                               _bindings_elementss
                               _range
                               (Just _bindings_name)
                               True
                               _bindings_unrwars
                               "function bindings"
                               "="
          ++ _bindings_patternMatchWarnings
         ,_self
         ,_bindings_typeAnnotations
         ,_lhs_typeSignatures
         ,_bindings_unboundNames
         )
sem_Declaration_Instance :: (T_Range) ->
                            (T_ContextItems) ->
                            (T_Name) ->
                            (T_Types) ->
                            (T_MaybeDeclarations) ->
                            (T_Declaration)
sem_Declaration_Instance (_range) (_context) (_name) (_types) (_where) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_typeSignatures) =
    let (_self) =
            Declaration_Instance _range_self _context_self _name_self _types_self _where_self
        ((_assumptions,_constraints,_unboundNames)) =
            internalError "PartialSyntax.ag" "n/a" "Declaration.Instance"
        (_oneLineTree) =
            intErr "Declaration" "instance"
        ( _range_self) =
            (_range )
        ( _context_self) =
            (_context )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _types_self) =
            (_types )
        ( _where_assumptions,_where_betaUnique,_where_collectednotypedef,_where_constraints,_where_localTypes,_where_matchIO,_where_namesInScope,_where_oneLineTree,_where_overloadedVars,_where_patternMatchWarnings,_where_self,_where_typeAnnotations,_where_unboundNames) =
            (_where (_lhs_allPatterns) (_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_constraints) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_unboundNames))
    in  ( _where_betaUnique,_lhs_bindingGroups,_where_collectednotypedef,[],_where_localTypes,_where_matchIO,_oneLineTree,_where_overloadedVars,_where_patternMatchWarnings,_self,_where_typeAnnotations,_lhs_typeSignatures,_unboundNames)
sem_Declaration_Newtype :: (T_Range) ->
                           (T_ContextItems) ->
                           (T_SimpleType) ->
                           (T_Constructor) ->
                           (T_Names) ->
                           (T_Declaration)
sem_Declaration_Newtype (_range) (_context) (_simpletype) (_constructor) (_derivings) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_typeSignatures) =
    let (_self) =
            Declaration_Newtype _range_self _context_self _simpletype_self _constructor_self _derivings_self
        (_oneLineTree) =
            intErr "Declaration" "newtype"
        ( _range_self) =
            (_range )
        ( _context_self) =
            (_context )
        ( _simpletype_self) =
            (_simpletype )
        ( _constructor_self,_constructor_unboundNames) =
            (_constructor (_lhs_namesInScope))
        ( _derivings_isIdentifier,_derivings_isOperator,_derivings_isSpecial,_derivings_oneLineTree,_derivings_self) =
            (_derivings )
    in  ( _lhs_betaUnique,_lhs_bindingGroups,_lhs_collectednotypedef,[],_lhs_localTypes,_lhs_matchIO,_oneLineTree,_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,_lhs_typeSignatures,_constructor_unboundNames)
sem_Declaration_PatternBinding :: (T_Range) ->
                                  (T_Pattern) ->
                                  (T_RightHandSide) ->
                                  (T_Declaration)
sem_Declaration_PatternBinding (_range) (_pattern) (_righthandside) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_typeSignatures) =
    let (_self) =
            Declaration_PatternBinding _range_self _pattern_self _righthandside_self
        (_newcon) =
            [ (_righthandside_beta .==. _pattern_beta) _cinfo ]
        (_mybdggrp) =
            ( _pattern_environment
            , _righthandside_assumptions
            , [ _newcon .>.
                Node [ _pattern_constraints
                     , _righthandside_constraints
                     ]
              ]
            )
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTDeclaration, AltPatternBinding, 0, "")
                  , location   = "right hand side"
                  , errorrange = getRHSRange _righthandside_self
                  , sources    = [ sourceExpression (_righthandside_oneLineTree "") ]
                  , typepair   = tppair
                  , properties = [ ]
                  }
        (_oneLineTree) =
            OneLineNode
                [ OneLineNode [_pattern_oneLineTree]
                , OneLineNode [_righthandside_oneLineTree " = "]
                ]
        ( _range_self) =
            (_range )
        ( _pattern_beta,_pattern_betaUnique,_pattern_constraints,_pattern_elements,_pattern_environment,_pattern_oneLineTree,_pattern_patVarNames,_pattern_patternMatchWarnings,_pattern_self,_pattern_unboundNames) =
            (_pattern (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution))
        ( _righthandside_assumptions,_righthandside_beta,_righthandside_betaUnique,_righthandside_collectednotypedef,_righthandside_constraints,_righthandside_fallthrough,_righthandside_localTypes,_righthandside_matchIO,_righthandside_oneLineTree,_righthandside_overloadedVars,_righthandside_patternMatchWarnings,_righthandside_self,_righthandside_typeAnnotations,_righthandside_unboundNames) =
            (_righthandside (_lhs_allPatterns) (_pattern_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (findMono (head (keysFM _pattern_environment)) _lhs_monoTable ++ _lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_pattern_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations))
    in  ( _righthandside_betaUnique
         ,_mybdggrp : _lhs_bindingGroups
         ,_righthandside_collectednotypedef
         ,_pattern_patVarNames
         ,_righthandside_localTypes
         ,_righthandside_matchIO
         ,_oneLineTree
         ,_righthandside_overloadedVars
         ,patternMatchWarnings _lhs_importEnvironment
                               _lhs_substitution
                               _pattern_beta
                               (:[])
                               [(_pattern_elements, _righthandside_fallthrough)]
                               _range
                               Nothing
                               False
                               []
                               "pattern binding"
                               "="
          ++ _righthandside_patternMatchWarnings
         ,_self
         ,_righthandside_typeAnnotations
         ,_lhs_typeSignatures
         ,_pattern_unboundNames ++ _righthandside_unboundNames
         )
sem_Declaration_Type :: (T_Range) ->
                        (T_SimpleType) ->
                        (T_Type) ->
                        (T_Declaration)
sem_Declaration_Type (_range) (_simpletype) (_type) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_typeSignatures) =
    let (_self) =
            Declaration_Type _range_self _simpletype_self _type_self
        (_oneLineTree) =
            intErr "Declaration" "type"
        ( _range_self) =
            (_range )
        ( _simpletype_self) =
            (_simpletype )
        ( _type_self) =
            (_type )
    in  ( _lhs_betaUnique,_lhs_bindingGroups,_lhs_collectednotypedef,[],_lhs_localTypes,_lhs_matchIO,_oneLineTree,_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,_lhs_typeSignatures,[])
sem_Declaration_TypeSignature :: (T_Range) ->
                                 (T_Names) ->
                                 (T_Type) ->
                                 (T_Declaration)
sem_Declaration_TypeSignature (_range) (_names) (_type) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_typeSignatures) =
    let (_self) =
            Declaration_TypeSignature _range_self _names_self _type_self
        (_typeScheme) =
            makeTpSchemeFromType _type_self
        (_oneLineTree) =
            OneLineNode
                 [ OneLineText (concat . intersperse "," . map show $ _names_self)
                 , OneLineText " :: "
                 , OneLineText (show (makeTpSchemeFromType _type_self))
                 ]
        ( _range_self) =
            (_range )
        ( _names_isIdentifier,_names_isOperator,_names_isSpecial,_names_oneLineTree,_names_self) =
            (_names )
        ( _type_self) =
            (_type )
    in  ( _lhs_betaUnique,_lhs_bindingGroups,_lhs_collectednotypedef,[],_lhs_localTypes,_lhs_matchIO,_oneLineTree,_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,addListToFM _lhs_typeSignatures [ (name, _typeScheme) | name <- _names_self ],[])
-- Declarations ------------------------------------------------
-- semantic domain
type T_Declarations = ([((Expression, [String]), Core_TypingStrategy)]) ->
                      (Int) ->
                      (BindingGroups) ->
                      ([(Name,Tps,Tp,Bool)]) ->
                      (ImportEnvironment) ->
                      (LocalTypes) ->
                      (IO ()) ->
                      (MonoTable) ->
                      (Tps) ->
                      (Names) ->
                      (OverloadedVariables) ->
                      (Names) ->
                      ([Warning]) ->
                      (Predicates) ->
                      (WrappedSubstitution) ->
                      (TypeAnnotations) ->
                      (FiniteMap Name TpScheme) ->
                      ( (Int),(BindingGroups),([(Name,Tps,Tp,Bool)]),(Names),(LocalTypes),(IO ()),( [ OneLineTree] ),(OverloadedVariables),([Warning]),(Declarations),(TypeAnnotations),(FiniteMap Name TpScheme),(Names))
-- cata
sem_Declarations :: (Declarations) ->
                    (T_Declarations)
sem_Declarations (list) =
    (foldr (sem_Declarations_Cons) (sem_Declarations_Nil) ((map sem_Declaration list)))
sem_Declarations_Cons :: (T_Declaration) ->
                         (T_Declarations) ->
                         (T_Declarations)
sem_Declarations_Cons (_hd) (_tl) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_typeSignatures) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_betaUnique,_hd_bindingGroups,_hd_collectednotypedef,_hd_declVarNames,_hd_localTypes,_hd_matchIO,_hd_oneLineTree,_hd_overloadedVars,_hd_patternMatchWarnings,_hd_self,_hd_typeAnnotations,_hd_typeSignatures,_hd_unboundNames) =
            (_hd (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_typeSignatures))
        ( _tl_betaUnique,_tl_bindingGroups,_tl_collectednotypedef,_tl_declVarNames,_tl_localTypes,_tl_matchIO,_tl_oneLineTree,_tl_overloadedVars,_tl_patternMatchWarnings,_tl_self,_tl_typeAnnotations,_tl_typeSignatures,_tl_unboundNames) =
            (_tl (_lhs_allPatterns) (_hd_betaUnique) (_hd_bindingGroups) (_hd_collectednotypedef) (_lhs_importEnvironment) (_hd_localTypes) (_hd_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_namesInScope) (_hd_overloadedVars) (_lhs_overloads) (_hd_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_hd_typeAnnotations) (_hd_typeSignatures))
    in  ( _tl_betaUnique,_tl_bindingGroups,_tl_collectednotypedef,_hd_declVarNames ++ _tl_declVarNames,_tl_localTypes,_tl_matchIO,_hd_oneLineTree  :  _tl_oneLineTree,_tl_overloadedVars,_tl_patternMatchWarnings,_self,_tl_typeAnnotations,_tl_typeSignatures,_hd_unboundNames ++ _tl_unboundNames)
sem_Declarations_Nil :: (T_Declarations)
sem_Declarations_Nil (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_typeSignatures) =
    let (_self) =
            []
    in  ( _lhs_betaUnique,_lhs_bindingGroups,_lhs_collectednotypedef,[],_lhs_localTypes,_lhs_matchIO,[],_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,_lhs_typeSignatures,[])
-- Export ------------------------------------------------------
-- semantic domain
type T_Export = ( (Export))
-- cata
sem_Export :: (Export) ->
              (T_Export)
sem_Export ((Export_Module (_range) (_name))) =
    (sem_Export_Module ((sem_Range (_range))) ((sem_Name (_name))))
sem_Export ((Export_TypeOrClass (_range) (_name) (_names))) =
    (sem_Export_TypeOrClass ((sem_Range (_range))) ((sem_Name (_name))) ((sem_MaybeNames (_names))))
sem_Export ((Export_TypeOrClassComplete (_range) (_name))) =
    (sem_Export_TypeOrClassComplete ((sem_Range (_range))) ((sem_Name (_name))))
sem_Export ((Export_Variable (_range) (_name))) =
    (sem_Export_Variable ((sem_Range (_range))) ((sem_Name (_name))))
sem_Export_Module :: (T_Range) ->
                     (T_Name) ->
                     (T_Export)
sem_Export_Module (_range) (_name) =
    let (_self) =
            Export_Module _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( _self)
sem_Export_TypeOrClass :: (T_Range) ->
                          (T_Name) ->
                          (T_MaybeNames) ->
                          (T_Export)
sem_Export_TypeOrClass (_range) (_name) (_names) =
    let (_self) =
            Export_TypeOrClass _range_self _name_self _names_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _names_self) =
            (_names )
    in  ( _self)
sem_Export_TypeOrClassComplete :: (T_Range) ->
                                  (T_Name) ->
                                  (T_Export)
sem_Export_TypeOrClassComplete (_range) (_name) =
    let (_self) =
            Export_TypeOrClassComplete _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( _self)
sem_Export_Variable :: (T_Range) ->
                       (T_Name) ->
                       (T_Export)
sem_Export_Variable (_range) (_name) =
    let (_self) =
            Export_Variable _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( _self)
-- Exports -----------------------------------------------------
-- semantic domain
type T_Exports = ( (Exports))
-- cata
sem_Exports :: (Exports) ->
               (T_Exports)
sem_Exports (list) =
    (foldr (sem_Exports_Cons) (sem_Exports_Nil) ((map sem_Export list)))
sem_Exports_Cons :: (T_Export) ->
                    (T_Exports) ->
                    (T_Exports)
sem_Exports_Cons (_hd) (_tl) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  ( _self)
sem_Exports_Nil :: (T_Exports)
sem_Exports_Nil  =
    let (_self) =
            []
    in  ( _self)
-- Expression --------------------------------------------------
-- semantic domain
type T_Expression = ([((Expression, [String]), Core_TypingStrategy)]) ->
                    (Int) ->
                    ([(Name,Tps,Tp,Bool)]) ->
                    (ImportEnvironment) ->
                    (LocalTypes) ->
                    (IO ()) ->
                    (Tps) ->
                    (Names) ->
                    (OverloadedVariables) ->
                    (Names) ->
                    ([Warning]) ->
                    (Predicates) ->
                    (WrappedSubstitution) ->
                    ([(Expression     , [String])]) ->
                    (TypeAnnotations) ->
                    (Int) ->
                    ( (Assumptions),(Tp),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(LocalTypes),(IO ()),([Maybe (MetaVariableTable MetaVariableInfo)]),(OneLineTree),(OverloadedVariables),([Warning]),(Expression),(TypeAnnotations),(Names),(Int))
-- cata
sem_Expression :: (Expression) ->
                  (T_Expression)
sem_Expression ((Expression_Case (_range) (_expression) (_alternatives))) =
    (sem_Expression_Case ((sem_Range (_range))) ((sem_Expression (_expression))) ((sem_Alternatives (_alternatives))))
sem_Expression ((Expression_Comprehension (_range) (_expression) (_qualifiers))) =
    (sem_Expression_Comprehension ((sem_Range (_range))) ((sem_Expression (_expression))) ((sem_Qualifiers (_qualifiers))))
sem_Expression ((Expression_Constructor (_range) (_name))) =
    (sem_Expression_Constructor ((sem_Range (_range))) ((sem_Name (_name))))
sem_Expression ((Expression_Do (_range) (_statements))) =
    (sem_Expression_Do ((sem_Range (_range))) ((sem_Statements (_statements))))
sem_Expression ((Expression_Enum (_range) (_from) (_then) (_to))) =
    (sem_Expression_Enum ((sem_Range (_range))) ((sem_Expression (_from))) ((sem_MaybeExpression (_then))) ((sem_MaybeExpression (_to))))
sem_Expression ((Expression_If (_range) (_guardExpression) (_thenExpression) (_elseExpression))) =
    (sem_Expression_If ((sem_Range (_range))) ((sem_Expression (_guardExpression))) ((sem_Expression (_thenExpression))) ((sem_Expression (_elseExpression))))
sem_Expression ((Expression_InfixApplication (_range) (_leftExpression) (_operator) (_rightExpression))) =
    (sem_Expression_InfixApplication ((sem_Range (_range))) ((sem_MaybeExpression (_leftExpression))) ((sem_Expression (_operator))) ((sem_MaybeExpression (_rightExpression))))
sem_Expression ((Expression_Lambda (_range) (_patterns) (_expression))) =
    (sem_Expression_Lambda ((sem_Range (_range))) ((sem_Patterns (_patterns))) ((sem_Expression (_expression))))
sem_Expression ((Expression_Let (_range) (_declarations) (_expression))) =
    (sem_Expression_Let ((sem_Range (_range))) ((sem_Declarations (_declarations))) ((sem_Expression (_expression))))
sem_Expression ((Expression_List (_range) (_expressions))) =
    (sem_Expression_List ((sem_Range (_range))) ((sem_Expressions (_expressions))))
sem_Expression ((Expression_Literal (_range) (_literal))) =
    (sem_Expression_Literal ((sem_Range (_range))) ((sem_Literal (_literal))))
sem_Expression ((Expression_Negate (_range) (_expression))) =
    (sem_Expression_Negate ((sem_Range (_range))) ((sem_Expression (_expression))))
sem_Expression ((Expression_NegateFloat (_range) (_expression))) =
    (sem_Expression_NegateFloat ((sem_Range (_range))) ((sem_Expression (_expression))))
sem_Expression ((Expression_NormalApplication (_range) (_function) (_arguments))) =
    (sem_Expression_NormalApplication ((sem_Range (_range))) ((sem_Expression (_function))) ((sem_Expressions (_arguments))))
sem_Expression ((Expression_Parenthesized (_range) (_expression))) =
    (sem_Expression_Parenthesized ((sem_Range (_range))) ((sem_Expression (_expression))))
sem_Expression ((Expression_RecordConstruction (_range) (_name) (_recordExpressionBindings))) =
    (sem_Expression_RecordConstruction ((sem_Range (_range))) ((sem_Name (_name))) ((sem_RecordExpressionBindings (_recordExpressionBindings))))
sem_Expression ((Expression_RecordUpdate (_range) (_expression) (_recordExpressionBindings))) =
    (sem_Expression_RecordUpdate ((sem_Range (_range))) ((sem_Expression (_expression))) ((sem_RecordExpressionBindings (_recordExpressionBindings))))
sem_Expression ((Expression_Tuple (_range) (_expressions))) =
    (sem_Expression_Tuple ((sem_Range (_range))) ((sem_Expressions (_expressions))))
sem_Expression ((Expression_Typed (_range) (_expression) (_type))) =
    (sem_Expression_Typed ((sem_Range (_range))) ((sem_Expression (_expression))) ((sem_Type (_type))))
sem_Expression ((Expression_Variable (_range) (_name))) =
    (sem_Expression_Variable ((sem_Range (_range))) ((sem_Name (_name))))
sem_Expression_Case :: (T_Range) ->
                       (T_Expression) ->
                       (T_Alternatives) ->
                       (T_Expression)
sem_Expression_Case (_range) (_expression) (_alternatives) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Case _range_self _expression_self _alternatives_self
        (_constraints) =
            Node [ _newcon .<. _expression_constraints
                 , Node _alternatives_constraintslist
                 ]
        (_beta) =
            TVar _lhs_betaUnique
        (_beta') =
            TVar (_lhs_betaUnique + 1)
        (_newcon) =
            [ (_expression_beta .==. _beta') _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTExpression, AltCase, 0, "")
                  , location   = "scrutinee of case expression"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm _expression_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getExprRange _expression_self) ]
                  }
        (_oneLineTree) =
            OneLineNode
                [ OneLineText "case "
                , OneLineNode [_expression_oneLineTree]
                , OneLineText " of "
                , encloseSep "{" "; " "}" _alternatives_oneLineTree
                ]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        ( _range_self) =
            (_range )
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_localTypes,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,_expression_self,_expression_typeAnnotations,_expression_unboundNames,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_lhs_betaUnique + 2) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) ([]) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _alternatives_assumptions,_alternatives_betaUnique,_alternatives_collectednotypedef,_alternatives_constraintslist,_alternatives_elementss,_alternatives_localTypes,_alternatives_matchIO,_alternatives_oneLineTree,_alternatives_overloadedVars,_alternatives_patternMatchWarnings,_alternatives_self,_alternatives_typeAnnotations,_alternatives_unboundNames,_alternatives_unrwars) =
            (_alternatives (_lhs_allPatterns) (_beta') (_beta) (_expression_betaUnique) (_expression_collectednotypedef) (_lhs_importEnvironment) (_expression_localTypes) (_expression_matchIO) (_lhs_monos) (_lhs_namesInScope) (length _alternatives_constraintslist) (_expression_overloadedVars) (_lhs_overloads) (_expression_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_expression_typeAnnotations))
    in  ( _expression_assumptions `combine` _alternatives_assumptions
         ,_beta
         ,_alternatives_betaUnique
         ,_alternatives_collectednotypedef
         ,_constraints
         ,_alternatives_localTypes
         ,_alternatives_matchIO
         ,matchOnlyVariable _localInfo _lhs_tryPatterns
         ,_oneLineTree
         ,_alternatives_overloadedVars
         ,patternMatchWarnings _lhs_importEnvironment
                               _lhs_substitution
                               _expression_beta
                               (:[])
                               _alternatives_elementss
                               _range
                               Nothing
                               False
                               _alternatives_unrwars
                               "case expression"
                               "->"
          ++ _alternatives_patternMatchWarnings
         ,_self
         ,_alternatives_typeAnnotations
         ,_expression_unboundNames ++ _alternatives_unboundNames
         ,_expression_uniqueSecondRound
         )
sem_Expression_Comprehension :: (T_Range) ->
                                (T_Expression) ->
                                (T_Qualifiers) ->
                                (T_Expression)
sem_Expression_Comprehension (_range) (_expression) (_qualifiers) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Comprehension _range_self _expression_self _qualifiers_self
        (_constraints) =
            _newcon .>. Node [ _qualifiers_constraints ]
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            [ (listType _expression_beta .==. _beta) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTExpression, AltComprehension, 0, "")
                  , location   = "list comprehension"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint ]
                  }
        (_oneLineTree) =
            OneLineNode
                [ OneLineText "[ "
                , OneLineNode [_expression_oneLineTree]
                , OneLineText " | "
                , OneLineNode [ punctuate ", " _qualifiers_oneLineTree ]
                , OneLineText " ]"
                ]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        ( _range_self) =
            (_range )
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_localTypes,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,_expression_self,_expression_typeAnnotations,_expression_unboundNames,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_qualifiers_monos) (_qualifiers_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) ([]) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _qualifiers_assumptions,_qualifiers_betaUnique,_qualifiers_collectednotypedef,_qualifiers_constraints,_qualifiers_localTypes,_qualifiers_matchIO,_qualifiers_monos,_qualifiers_namesInScope,_qualifiers_oneLineTree,_qualifiers_overloadedVars,_qualifiers_patternMatchWarnings,_qualifiers_self,_qualifiers_typeAnnotations,_qualifiers_unboundNames,_qualifiers_uniqueSecondRound) =
            (_qualifiers (_lhs_allPatterns)
                         (_expression_assumptions)
                         (_expression_betaUnique)
                         (_expression_collectednotypedef)
                         (_expression_constraints)
                         (_lhs_importEnvironment)
                         (_expression_localTypes)
                         (_expression_matchIO)
                         (_lhs_monos)
                         (_lhs_namesInScope)
                         (_expression_overloadedVars)
                         (_lhs_overloads)
                         (_expression_patternMatchWarnings)
                         (_lhs_predicates)
                         (_lhs_substitution)
                         (_expression_typeAnnotations)
                         (_expression_unboundNames)
                         (_expression_uniqueSecondRound))
    in  ( _qualifiers_assumptions,_beta,_qualifiers_betaUnique,_qualifiers_collectednotypedef,_constraints,_qualifiers_localTypes,_qualifiers_matchIO,matchOnlyVariable _localInfo _lhs_tryPatterns,_oneLineTree,_qualifiers_overloadedVars,_qualifiers_patternMatchWarnings,_self,_qualifiers_typeAnnotations,_qualifiers_unboundNames,_qualifiers_uniqueSecondRound)
sem_Expression_Constructor :: (T_Range) ->
                              (T_Name) ->
                              (T_Expression)
sem_Expression_Constructor (_range) (_name) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Constructor _range_self _name_self
        (_constraints) =
            listTree _newcon
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            case lookupFM (valueConstructors _lhs_importEnvironment) _name_self of
               Nothing  -> []
               Just ctp -> [ (_beta .::. ctp) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTExpression, AltConstructor, 0, "")
                  , location   = "constructor"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _name_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , HighlyTrusted
                                 , IsImported _name_self
                                 ]
                  }
        (_oneLineTree) =
            OneLineNode [_name_oneLineTree]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        (((),_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match0 _localInfo _lhs_uniqueSecondRound
                   (match_Expression_Constructor _name_self)
                   _lhs_tryPatterns _lhs_allPatterns
                   []
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( noAssumptions,_beta,_lhs_betaUnique + 1,_lhs_collectednotypedef,_newConstraintSet,_lhs_localTypes,_lhs_matchIO >> _ioMatch,_matches,_oneLineTree,_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,[],_newUnique)
sem_Expression_Do :: (T_Range) ->
                     (T_Statements) ->
                     (T_Expression)
sem_Expression_Do (_range) (_statements) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Do _range_self _statements_self
        (_constraints) =
            emptyTree
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            case _statements_generatorBeta of
               Nothing -> []
               Just b  -> [ (ioType b .==. _beta) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTExpression, AltDo, 0, "")
                  , location   = "do-expression"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint ]
                  }
        (_oneLineTree) =
            OneLineNode
                [ OneLineText "do "
                , OneLineNode (sepBy (OneLineText "; ") _statements_oneLineTree)
                ]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        ( _range_self) =
            (_range )
        ( _statements_assumptions,_statements_betaUnique,_statements_collectednotypedef,_statements_constraints,_statements_generatorBeta,_statements_localTypes,_statements_matchIO,_statements_namesInScope,_statements_oneLineTree,_statements_overloadedVars,_statements_patternMatchWarnings,_statements_self,_statements_typeAnnotations,_statements_unboundNames,_statements_uniqueSecondRound) =
            (_statements (_lhs_allPatterns) (noAssumptions) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_constraints) (Nothing) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) ([]) (_lhs_uniqueSecondRound))
    in  ( _statements_assumptions,_beta,_statements_betaUnique,_statements_collectednotypedef,Node [ _newcon .<. _statements_constraints ],_statements_localTypes,_statements_matchIO,matchOnlyVariable _localInfo _lhs_tryPatterns,_oneLineTree,_statements_overloadedVars,_statements_patternMatchWarnings,_self,_statements_typeAnnotations,_statements_unboundNames,_statements_uniqueSecondRound)
sem_Expression_Enum :: (T_Range) ->
                       (T_Expression) ->
                       (T_MaybeExpression) ->
                       (T_MaybeExpression) ->
                       (T_Expression)
sem_Expression_Enum (_range) (_from) (_then) (_to) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Enum _range_self _from_self _then_self _to_self
        (_constraints) =
            [ (listType intType .==. _beta) _cinfoResult ] .>.
            Node [ _conFrom .<. _from_constraints
                 , _conThen .<. _then_constraints
                 , _conTo   .<. _to_constraints
                 ]
        (_beta) =
            TVar _lhs_betaUnique
        (_conFrom) =
            [ (_from_beta .==. intType) _cinfoFrom ]
        (_conThen) =
            [ (_then_beta .==. intType) _cinfoThen ]
        (_conTo) =
            [ (_to_beta   .==. intType) _cinfoTo   ]
        (_cinfoFrom) =
            \tppair ->
            CInfo { info       = (NTExpression, AltEnum, 0, "from")
                  , location   = "enumeration"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm _from_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getExprRange _from_self) ]
                  }
        (_cinfoThen) =
            \tppair ->
            CInfo { info       = (NTExpression, AltEnum, 1, "then")
                  , location   = "enumeration"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm (convertMaybeOneLineTree _then_oneLineTree) ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getMaybeExprRange _then_self) ]
                  }
        (_cinfoTo) =
            \tppair ->
            CInfo { info       = (NTExpression, AltEnum, 2, "to")
                  , location   = "enumeration"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm (convertMaybeOneLineTree _to_oneLineTree) ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getMaybeExprRange _to_self) ]
                  }
        (_cinfoResult) =
            \tppair ->
            CInfo { info       = (NTExpression, AltEnum, 3, "result")
                  , location   = "enumeration"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint ]
                  }
        (_oneLineTree) =
            OneLineNode (
                [ OneLineText "["
                , OneLineNode [_from_oneLineTree]
                ]
                ++
                maybe [] (\x -> [OneLineText ", ", x]) _then_oneLineTree
                ++
                [ OneLineText " .. " ]
                ++
                maybe [] (\x -> [OneLineNode [x]]) _to_oneLineTree
                ++
                [ OneLineText "]" ]
            )
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        (((_t1,_t2,_t3),_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match3 _localInfo _to_uniqueSecondRound
                   match_Expression_Enum
                   _lhs_tryPatterns _lhs_allPatterns
                   [_from_matches, _then_matches, _to_matches]
        ( _range_self) =
            (_range )
        ( _from_assumptions,_from_beta,_from_betaUnique,_from_collectednotypedef,_from_constraints,_from_localTypes,_from_matchIO,_from_matches,_from_oneLineTree,_from_overloadedVars,_from_patternMatchWarnings,_from_self,_from_typeAnnotations,_from_unboundNames,_from_uniqueSecondRound) =
            (_from (_lhs_allPatterns) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_t1) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _then_assumptions,_then_beta,_then_betaUnique,_then_collectednotypedef,_then_constraints,_then_localTypes,_then_matchIO,_then_matches,_then_oneLineTree,_then_overloadedVars,_then_patternMatchWarnings,_then_section,_then_self,_then_typeAnnotations,_then_unboundNames,_then_uniqueSecondRound) =
            (_then (_lhs_allPatterns) (_from_betaUnique) (_from_collectednotypedef) (_lhs_importEnvironment) (_from_localTypes) (_from_matchIO) (_lhs_monos) (_lhs_namesInScope) (_from_overloadedVars) (_lhs_overloads) (_from_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_t2) (_from_typeAnnotations) (_from_uniqueSecondRound))
        ( _to_assumptions,_to_beta,_to_betaUnique,_to_collectednotypedef,_to_constraints,_to_localTypes,_to_matchIO,_to_matches,_to_oneLineTree,_to_overloadedVars,_to_patternMatchWarnings,_to_section,_to_self,_to_typeAnnotations,_to_unboundNames,_to_uniqueSecondRound) =
            (_to (_lhs_allPatterns) (_then_betaUnique) (_then_collectednotypedef) (_lhs_importEnvironment) (_then_localTypes) (_then_matchIO) (_lhs_monos) (_lhs_namesInScope) (_then_overloadedVars) (_lhs_overloads) (_then_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_t3) (_then_typeAnnotations) (_then_uniqueSecondRound))
    in  ( _from_assumptions `combine` _then_assumptions `combine` _to_assumptions,_beta,_to_betaUnique,_to_collectednotypedef,_newConstraintSet,_to_localTypes,_to_matchIO >> _ioMatch,_matches,_oneLineTree,_to_overloadedVars,_to_patternMatchWarnings,_self,_to_typeAnnotations,_from_unboundNames ++ _then_unboundNames ++ _to_unboundNames,_newUnique)
sem_Expression_If :: (T_Range) ->
                     (T_Expression) ->
                     (T_Expression) ->
                     (T_Expression) ->
                     (T_Expression)
sem_Expression_If (_range) (_guardExpression) (_thenExpression) (_elseExpression) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_If _range_self _guardExpression_self _thenExpression_self _elseExpression_self
        (_constraints) =
            Node [ _conGuard .<. _guardExpression_constraints
                 , _conThen  .<. _thenExpression_constraints
                 , _conElse  .<. _elseExpression_constraints
                 ]
        (_beta) =
            TVar _lhs_betaUnique
        (_conGuard) =
            [ (_guardExpression_beta .==. boolType) _cinfoGuard ]
        (_conThen) =
            [ (_thenExpression_beta  .==. _beta   ) _cinfoThen  ]
        (_conElse) =
            [ (_elseExpression_beta  .==. _beta   ) _cinfoElse  ]
        (_cinfoGuard) =
            \tppair ->
            CInfo { info       = (NTExpression, AltIf, 0, "guard")
                  , location   = "conditional"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm _guardExpression_oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getExprRange _guardExpression_self) ]
                  }
        (_cinfoThen) =
            \tppair ->
            CInfo { info       = (NTExpression, AltIf, 1, "then")
                  , location   = "then branch of conditional"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm _thenExpression_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getExprRange _thenExpression_self)
                                 , Unifier (tpToInt _beta) ]
                  }
        (_cinfoElse) =
            \tppair ->
            CInfo { info       = (NTExpression, AltIf,2, "else")
                  , location   = "else branch of conditional"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm _elseExpression_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getExprRange _elseExpression_self)
                                 , Unifier (tpToInt _beta) ]
                  }
        (_oneLineTree) =
            OneLineNode
                [ OneLineText "if "
                , OneLineNode [_guardExpression_oneLineTree]
                , OneLineText " then "
                , OneLineNode [_thenExpression_oneLineTree]
                , OneLineText " else "
                , OneLineNode [_elseExpression_oneLineTree]
                ]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        (((_t1,_t2,_t3),_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match3 _localInfo _elseExpression_uniqueSecondRound
                   match_Expression_If
                   _lhs_tryPatterns _lhs_allPatterns
                   [_guardExpression_matches,_thenExpression_matches,_elseExpression_matches]
        ( _range_self) =
            (_range )
        ( _guardExpression_assumptions
         ,_guardExpression_beta
         ,_guardExpression_betaUnique
         ,_guardExpression_collectednotypedef
         ,_guardExpression_constraints
         ,_guardExpression_localTypes
         ,_guardExpression_matchIO
         ,_guardExpression_matches
         ,_guardExpression_oneLineTree
         ,_guardExpression_overloadedVars
         ,_guardExpression_patternMatchWarnings
         ,_guardExpression_self
         ,_guardExpression_typeAnnotations
         ,_guardExpression_unboundNames
         ,_guardExpression_uniqueSecondRound
         ) =
            (_guardExpression (_lhs_allPatterns) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_t1) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _thenExpression_assumptions,_thenExpression_beta,_thenExpression_betaUnique,_thenExpression_collectednotypedef,_thenExpression_constraints,_thenExpression_localTypes,_thenExpression_matchIO,_thenExpression_matches,_thenExpression_oneLineTree,_thenExpression_overloadedVars,_thenExpression_patternMatchWarnings,_thenExpression_self,_thenExpression_typeAnnotations,_thenExpression_unboundNames,_thenExpression_uniqueSecondRound) =
            (_thenExpression (_lhs_allPatterns) (_guardExpression_betaUnique) (_guardExpression_collectednotypedef) (_lhs_importEnvironment) (_guardExpression_localTypes) (_guardExpression_matchIO) (_lhs_monos) (_lhs_namesInScope) (_guardExpression_overloadedVars) (_lhs_overloads) (_guardExpression_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_t2) (_guardExpression_typeAnnotations) (_guardExpression_uniqueSecondRound))
        ( _elseExpression_assumptions,_elseExpression_beta,_elseExpression_betaUnique,_elseExpression_collectednotypedef,_elseExpression_constraints,_elseExpression_localTypes,_elseExpression_matchIO,_elseExpression_matches,_elseExpression_oneLineTree,_elseExpression_overloadedVars,_elseExpression_patternMatchWarnings,_elseExpression_self,_elseExpression_typeAnnotations,_elseExpression_unboundNames,_elseExpression_uniqueSecondRound) =
            (_elseExpression (_lhs_allPatterns) (_thenExpression_betaUnique) (_thenExpression_collectednotypedef) (_lhs_importEnvironment) (_thenExpression_localTypes) (_thenExpression_matchIO) (_lhs_monos) (_lhs_namesInScope) (_thenExpression_overloadedVars) (_lhs_overloads) (_thenExpression_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_t3) (_thenExpression_typeAnnotations) (_thenExpression_uniqueSecondRound))
    in  ( _guardExpression_assumptions `combine` _thenExpression_assumptions `combine` _elseExpression_assumptions
         ,_beta
         ,_elseExpression_betaUnique
         ,_elseExpression_collectednotypedef
         ,_newConstraintSet
         ,_elseExpression_localTypes
         ,_elseExpression_matchIO >> _ioMatch
         ,_matches
         ,_oneLineTree
         ,_elseExpression_overloadedVars
         ,_elseExpression_patternMatchWarnings
         ,_self
         ,_elseExpression_typeAnnotations
         ,_guardExpression_unboundNames ++ _thenExpression_unboundNames ++ _elseExpression_unboundNames
         ,_newUnique
         )
sem_Expression_InfixApplication :: (T_Range) ->
                                   (T_MaybeExpression) ->
                                   (T_Expression) ->
                                   (T_MaybeExpression) ->
                                   (T_Expression)
sem_Expression_InfixApplication (_range) (_leftExpression) (_operator) (_rightExpression) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_InfixApplication _range_self _leftExpression_self _operator_self _rightExpression_self
        (_constraints) =
            _conTotal .>.
            Node [ _operator_constraints
                 , _leftExpression_constraints
                 , _rightExpression_constraints
                 ]
        (_beta) =
            TVar _lhs_betaUnique
        (_betaResOp) =
            TVar (_lhs_betaUnique + 1)
        (_conOperator) =
            (_operator_beta .==. _leftExpression_beta .->. _rightExpression_beta .->. _betaResOp) _cinfoOperator
        (_conTotal) =
            case (_leftExpression_section,_rightExpression_section) of
                   (False,False) -> [ _conOperator, (_betaResOp     .==. _beta)                        _cinfoComplete     ]
                   (True ,True ) -> [               (_operator_beta .==. _beta)                        _cinfoEmpty        ]
                   (False,True ) -> [ _conOperator, (_rightExpression_beta .->. _betaResOp .==. _beta) _cinfoRightSection ]
                   (True ,False) -> [ _conOperator, (_leftExpression_beta  .->. _betaResOp .==. _beta) _cinfoLeftSection  ]
        (_cinfoOperator) =
            \tppair ->
            CInfo { info       = (NTExpression, AltInfixApplication, 0, "operator")
                  , location   = "infix application"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceOperator _operatorName ]
                  , typepair   = tppair
                  , properties = (if _leftExpression_section || _rightExpression_section
                                    then [ HighlyTrusted ]
                                    else [ ApplicationEdge True
                                                   [ ( convertMaybeOneLineTree _leftExpression_oneLineTree
                                                     , _leftExpression_beta
                                                     , getMaybeExprRange _leftExpression_self
                                                     )
                                                   , ( convertMaybeOneLineTree _rightExpression_oneLineTree
                                                     , _rightExpression_beta
                                                     , getMaybeExprRange _rightExpression_self
                                                     )
                                                   ] ])
                                 ++
                                 [ SubTermRange (getExprRange _operator_self) ]
                  }
        (_cinfoComplete) =
            \tppair ->
            CInfo { info       = (NTExpression, AltInfixApplication, 1, "")
                  , location   = "infix application (INTERNAL ERROR)"
                  , errorrange = _range_self
                  , sources    = [ ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , SuperHighlyTrusted
                                 ]
                  }
        (_cinfoLeftSection) =
            \tppair ->
            CInfo { info       = (NTExpression, AltInfixApplication, 2, "left")
                  , location   = "left section"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree ]
                  , typepair   = tppair
                  , properties = [ ]
                  }
        (_cinfoRightSection) =
            \tppair ->
            CInfo { info       = (NTExpression, AltInfixApplication, 3, "right")
                  , location   = "right section"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree ]
                  , typepair   = tppair
                  , properties = [ ]
                  }
        (_cinfoEmpty) =
            \tppair ->
            CInfo { info       = (NTExpression, AltInfixApplication, 4, "empty")
                  , location   = "infix application"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , HighlyTrusted
                                 ]
                  }
        (_operatorName) =
            oneLineTreeAsOperator _operator_oneLineTree
        (_oneLineTree) =
            case (_leftExpression_oneLineTree, _rightExpression_oneLineTree) of
                (Nothing, Nothing) -> parens _operatorName
                (Just l , Nothing) -> encloseSep "(" " " ")" [l, _operatorName]
                (Nothing, Just r ) -> encloseSep "(" " " ")" [_operatorName, r]
                (Just l , Just r ) -> OneLineNode [ l, OneLineText " ", _operatorName, OneLineText " ", r ]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        (((_t1,_t2,_t3),_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match3 _localInfo _rightExpression_uniqueSecondRound
                   match_Expression_InfixApplication
                   _lhs_tryPatterns _lhs_allPatterns
                   [_leftExpression_matches, _operator_matches,_rightExpression_matches]
        ( _range_self) =
            (_range )
        ( _leftExpression_assumptions
         ,_leftExpression_beta
         ,_leftExpression_betaUnique
         ,_leftExpression_collectednotypedef
         ,_leftExpression_constraints
         ,_leftExpression_localTypes
         ,_leftExpression_matchIO
         ,_leftExpression_matches
         ,_leftExpression_oneLineTree
         ,_leftExpression_overloadedVars
         ,_leftExpression_patternMatchWarnings
         ,_leftExpression_section
         ,_leftExpression_self
         ,_leftExpression_typeAnnotations
         ,_leftExpression_unboundNames
         ,_leftExpression_uniqueSecondRound
         ) =
            (_leftExpression (_lhs_allPatterns) (_lhs_betaUnique + 2) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_t1) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _operator_assumptions,_operator_beta,_operator_betaUnique,_operator_collectednotypedef,_operator_constraints,_operator_localTypes,_operator_matchIO,_operator_matches,_operator_oneLineTree,_operator_overloadedVars,_operator_patternMatchWarnings,_operator_self,_operator_typeAnnotations,_operator_unboundNames,_operator_uniqueSecondRound) =
            (_operator (_lhs_allPatterns) (_leftExpression_betaUnique) (_leftExpression_collectednotypedef) (_lhs_importEnvironment) (_leftExpression_localTypes) (_leftExpression_matchIO) (_lhs_monos) (_lhs_namesInScope) (_leftExpression_overloadedVars) (_lhs_overloads) (_leftExpression_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_t2) (_leftExpression_typeAnnotations) (_leftExpression_uniqueSecondRound))
        ( _rightExpression_assumptions
         ,_rightExpression_beta
         ,_rightExpression_betaUnique
         ,_rightExpression_collectednotypedef
         ,_rightExpression_constraints
         ,_rightExpression_localTypes
         ,_rightExpression_matchIO
         ,_rightExpression_matches
         ,_rightExpression_oneLineTree
         ,_rightExpression_overloadedVars
         ,_rightExpression_patternMatchWarnings
         ,_rightExpression_section
         ,_rightExpression_self
         ,_rightExpression_typeAnnotations
         ,_rightExpression_unboundNames
         ,_rightExpression_uniqueSecondRound
         ) =
            (_rightExpression (_lhs_allPatterns) (_operator_betaUnique) (_operator_collectednotypedef) (_lhs_importEnvironment) (_operator_localTypes) (_operator_matchIO) (_lhs_monos) (_lhs_namesInScope) (_operator_overloadedVars) (_lhs_overloads) (_operator_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_t3) (_operator_typeAnnotations) (_operator_uniqueSecondRound))
    in  ( _leftExpression_assumptions `combine` _operator_assumptions `combine` _rightExpression_assumptions
         ,_beta
         ,_rightExpression_betaUnique
         ,_rightExpression_collectednotypedef
         ,_newConstraintSet
         ,_rightExpression_localTypes
         ,_rightExpression_matchIO >> _ioMatch
         ,_matches
         ,_oneLineTree
         ,_rightExpression_overloadedVars
         ,_rightExpression_patternMatchWarnings
         ,_self
         ,_rightExpression_typeAnnotations
         ,_leftExpression_unboundNames ++ _operator_unboundNames ++ _rightExpression_unboundNames
         ,_newUnique
         )
sem_Expression_Lambda :: (T_Range) ->
                         (T_Patterns) ->
                         (T_Expression) ->
                         (T_Expression)
sem_Expression_Lambda (_range) (_patterns) (_expression) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Lambda _range_self _patterns_self _expression_self
        (_constraints) =
            _newcon .>. _csetBinds .>>.
            Node [ Node _patterns_constraintslist
                 , _expression_constraints
                 ]
        (_beta) =
            TVar _lhs_betaUnique
        ((_csetBinds,_assumptions')) =
            (_patterns_environment .===. _expression_assumptions) _cinfoBind
        (_newcon) =
            [ (foldr (.->.) _expression_beta _patterns_betas .==. _beta) _cinfoType ]
        (_cinfoBind) =
            variableBindingCInfo (NTExpression, AltLambda, 0)
        (_cinfoType) =
            \tppair ->
            CInfo { info       = (NTExpression, AltLambda, 1, "type")
                  , location   = "lambda abstraction"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint ]
                  }
        (_oneLineTree) =
            OneLineNode
                (  [ OneLineText "\\", punctuate " " _patterns_oneLineTree, OneLineText " -> "
                   , OneLineNode [_expression_oneLineTree]
                   ]
                )
        ((_namesInScope,_unboundNames,_scopeInfo)) =
            changeOfScope _patterns_patVarNames _expression_unboundNames _lhs_namesInScope
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        ( _range_self) =
            (_range )
        ( _patterns_betaUnique,_patterns_betas,_patterns_constraintslist,_patterns_elementss,_patterns_environment,_patterns_numberOfPatterns,_patterns_oneLineTree,_patterns_patVarNames,_patterns_patternMatchWarnings,_patterns_self,_patterns_unboundNames) =
            (_patterns (_lhs_betaUnique + 1) (_lhs_importEnvironment) (_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution))
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_localTypes,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,_expression_self,_expression_typeAnnotations,_expression_unboundNames,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_patterns_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (eltsFM _patterns_environment ++ getMonos _csetBinds ++ _lhs_monos) (_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_patterns_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) ([]) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _assumptions'
         ,_beta
         ,_expression_betaUnique
         ,_expression_collectednotypedef
         ,_constraints
         ,_expression_localTypes
         ,_expression_matchIO
         ,matchOnlyVariable _localInfo _lhs_tryPatterns
         ,_oneLineTree
         ,_expression_overloadedVars
         ,patternMatchWarnings _lhs_importEnvironment
                               _lhs_substitution
                               _beta
                               (take (length _patterns_self) . fst . functionSpine)
                               [(concat _patterns_elementss, False)]
                               _range
                               (Just $ Name_Special noRange [] "\\")
                               True
                               []
                               "lambda expression"
                               "->"
          ++ _expression_patternMatchWarnings
         ,_self
         ,_expression_typeAnnotations
         ,_unboundNames
         ,_expression_uniqueSecondRound
         )
sem_Expression_Let :: (T_Range) ->
                      (T_Declarations) ->
                      (T_Expression) ->
                      (T_Expression)
sem_Expression_Let (_range) (_declarations) (_expression) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Let _range_self _declarations_self _expression_self
        (_constraints) =
            [ (_expression_beta .==. _beta) _cinfoType ] .>. _cset
        (_beta) =
            TVar _lhs_betaUnique
        (_mybdggroup) =
            (noAssumptions,_expression_assumptions,[_expression_constraints])
        ((_aset,_cset,_monoTable)) =
            performBindingGroup _lhs_monos _declarations_typeSignatures (_mybdggroup : _declarations_bindingGroups)
        ((_anns,_notypedefs)) =
            findTypeAnnotations False _lhs_monos _declarations_typeSignatures (_mybdggroup : _declarations_bindingGroups)
        (_cinfoType) =
            \tppair ->
            CInfo { info       = (NTExpression, AltLet, 0, "")
                  , location   = "let expression (INTERNAL ERROR)"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm _expression_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , SuperHighlyTrusted
                                 , SubTermRange (getExprRange _expression_self)
                                 ]
                  }
        ((_collectTypeConstructors,_collectValueConstructors,_collectTypeSynonyms,_collectConstructorEnv,_derivedFunctions,_operatorFixities)) =
            internalError "PartialSyntax.ag" "n/a" "toplevel Expression"
        (_oneLineTree) =
            OneLineNode
                [ OneLineText "let "
                , encloseSep "{" "; " "}" _declarations_oneLineTree
                , OneLineText " in "
                , OneLineNode [_expression_oneLineTree]
                ]
        ((_namesInScope,_unboundNames,_scopeInfo)) =
            changeOfScope _declarations_declVarNames (_declarations_unboundNames ++ _expression_unboundNames) _lhs_namesInScope
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        ( _range_self) =
            (_range )
        ( _declarations_betaUnique,_declarations_bindingGroups,_declarations_collectednotypedef,_declarations_declVarNames,_declarations_localTypes,_declarations_matchIO,_declarations_oneLineTree,_declarations_overloadedVars,_declarations_patternMatchWarnings,_declarations_self,_declarations_typeAnnotations,_declarations_typeSignatures,_declarations_unboundNames) =
            (_declarations (_lhs_allPatterns) (_lhs_betaUnique + 1) ([]) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_monoTable) (_lhs_monos) (_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (emptyFM))
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_localTypes,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,_expression_self,_expression_typeAnnotations,_expression_unboundNames,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_declarations_betaUnique) (_declarations_collectednotypedef) (_lhs_importEnvironment) (_declarations_localTypes) (_declarations_matchIO) (_lhs_monos) (_namesInScope) (_declarations_overloadedVars) (_lhs_overloads) (_declarations_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) ([]) (_declarations_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _aset
         ,_beta
         ,_expression_betaUnique
         ,_notypedefs ++ _declarations_collectednotypedef
         ,_constraints
         ,convertLocal _lhs_substitution _lhs_predicates _notypedefs
          `plusFM` foldFM (\n ts fm -> addToFM fm (NameWithRange n) ts) emptyFM  _declarations_typeSignatures
          `plusFM` _declarations_localTypes
         ,_expression_matchIO
         ,matchOnlyVariable _localInfo _lhs_tryPatterns
         ,_oneLineTree
         ,_expression_overloadedVars
         ,_expression_patternMatchWarnings
         ,_self
         ,_anns ++ _expression_typeAnnotations
         ,_unboundNames
         ,_expression_uniqueSecondRound
         )
sem_Expression_List :: (T_Range) ->
                       (T_Expressions) ->
                       (T_Expression)
sem_Expression_List (_range) (_expressions) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_List _range_self _expressions_self
        (_constraints) =
            _newcon .>.
             Node (zipWith3 _zipf _expressions_betas _childrenInfo _expressions_constraintslist)
        (_beta) =
            TVar _lhs_betaUnique
        (_beta') =
            TVar (_lhs_betaUnique + 1)
        (_newcon) =
            [ (listType _beta' .==. _beta) _cinfoResult ]
        (_childrenInfo) =
            zip _expressions_oneLineTree (map getExprRange _expressions_self)
        (_zipf) =
            \tp pair ctree -> [ (tp .==. _beta') (_cinfoElem pair) ] .<. ctree
        (_cinfoElem) =
            \(elemtext, elemrange) tppair ->
            CInfo { info       = (NTExpression, AltList, 0, "element")
                  , location   = "element of list"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm elemtext ]
                  , typepair   = tppair
                  , properties = [ SubTermRange elemrange ] ++
                                 if length _expressions_betas > 1 then [] else [ HighlyTrusted ]
                  }
        (_cinfoResult) =
            \tppair ->
            CInfo { info       = (NTExpression, AltList, 1, "result")
                  , location   = "list"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint ]
                  }
        (_oneLineTree) =
            encloseSep "[" ", " "]" _expressions_oneLineTree
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        ((_t1,_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match1 _localInfo _expressions_uniqueSecondRound
               match_Expression_List
               _lhs_tryPatterns _lhs_allPatterns
               [_expressions_matches]
        ( _range_self) =
            (_range )
        ( _expressions_assumptions,_expressions_betaUnique,_expressions_betas,_expressions_collectednotypedef,_expressions_constraintslist,_expressions_localTypes,_expressions_matchIO,_expressions_matches,_expressions_oneLineTree,_expressions_overloadedVars,_expressions_patternMatchWarnings,_expressions_self,_expressions_typeAnnotations,_expressions_unboundNames,_expressions_uniqueSecondRound) =
            (_expressions (_lhs_allPatterns) (_lhs_betaUnique + 2) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_t1) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _expressions_assumptions,_beta,_expressions_betaUnique,_expressions_collectednotypedef,_newConstraintSet,_expressions_localTypes,_expressions_matchIO,_matches,_oneLineTree,_expressions_overloadedVars,_expressions_patternMatchWarnings,_self,_expressions_typeAnnotations,_expressions_unboundNames,_newUnique)
sem_Expression_Literal :: (T_Range) ->
                          (T_Literal) ->
                          (T_Expression)
sem_Expression_Literal (_range) (_literal) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Literal _range_self _literal_self
        (_constraints) =
            unitTree ((_literal_literalType .==. _beta) _cinfo)
        (_beta) =
            TVar _lhs_betaUnique
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTExpression, AltLiteral, 0, "")
                  , location   = "literal"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , HighlyTrusted
                                 , IsLiteral _literal_self
                                 ]
                  }
        (_oneLineTree) =
            OneLineNode [_literal_oneLineTree]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        (((),_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match0 _localInfo _lhs_uniqueSecondRound
                   (match_Expression_Literal _literal_self)
                   _lhs_tryPatterns _lhs_allPatterns
                   []
        ( _range_self) =
            (_range )
        ( _literal_elements,_literal_literalType,_literal_oneLineTree,_literal_self) =
            (_literal )
    in  ( noAssumptions,_beta,_lhs_betaUnique + 1,_lhs_collectednotypedef,_newConstraintSet,_lhs_localTypes,_lhs_matchIO >> _ioMatch,_matches,_oneLineTree,_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,[],_newUnique)
sem_Expression_Negate :: (T_Range) ->
                         (T_Expression) ->
                         (T_Expression)
sem_Expression_Negate (_range) (_expression) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Negate _range_self _expression_self
        (_constraints) =
            _newcon .>. Node [ _expression_constraints ]
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            [ (intType .->. intType .==. _expression_beta .->. _beta) _cinfo]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTExpression, AltNegate, 0, "")
                  , location   = "negation"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceOperator (OneLineText "-") ]
                  , typepair   = tppair
                  , properties = [ Negation True ]
                  }
        (_oneLineTree) =
            OneLineNode [ OneLineText "-", OneLineNode [_expression_oneLineTree] ]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        ((_t1,_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match1 _localInfo _expression_uniqueSecondRound
                   match_Expression_Negate
                   _lhs_tryPatterns _lhs_allPatterns
                   [_expression_matches]
        ( _range_self) =
            (_range )
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_localTypes,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,_expression_self,_expression_typeAnnotations,_expression_unboundNames,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_t1) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _expression_assumptions,_beta,_expression_betaUnique,_expression_collectednotypedef,_newConstraintSet,_expression_localTypes,_expression_matchIO >> _ioMatch,_matches,_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,_self,_expression_typeAnnotations,_expression_unboundNames,_newUnique)
sem_Expression_NegateFloat :: (T_Range) ->
                              (T_Expression) ->
                              (T_Expression)
sem_Expression_NegateFloat (_range) (_expression) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_NegateFloat _range_self _expression_self
        (_constraints) =
            _newcon .>. Node [ _expression_constraints ]
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            [ (floatType .->. floatType .==. _expression_beta .->. _beta) _cinfo]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTExpression, AltNegateFloat, 0, "")
                  , location   = "negation"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceOperator (OneLineText "-.") ]
                  , typepair   = tppair
                  , properties = [ Negation False ]
                  }
        (_oneLineTree) =
            OneLineNode [ OneLineText "-.", OneLineNode [_expression_oneLineTree] ]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        ((_t1,_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match1 _localInfo _expression_uniqueSecondRound
                   match_Expression_NegateFloat
                   _lhs_tryPatterns _lhs_allPatterns
                   [_expression_matches]
        ( _range_self) =
            (_range )
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_localTypes,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,_expression_self,_expression_typeAnnotations,_expression_unboundNames,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_t1) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _expression_assumptions,_beta,_expression_betaUnique,_expression_collectednotypedef,_newConstraintSet,_expression_localTypes,_expression_matchIO >> _ioMatch,_matches,_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,_self,_expression_typeAnnotations,_expression_unboundNames,_newUnique)
sem_Expression_NormalApplication :: (T_Range) ->
                                    (T_Expression) ->
                                    (T_Expressions) ->
                                    (T_Expression)
sem_Expression_NormalApplication (_range) (_function) (_arguments) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_NormalApplication _range_self _function_self _arguments_self
        (_constraints) =
            _newcon .>.
            Node [ _function_constraints
                 , Node _arguments_constraintslist
                 ]
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            [ (_function_beta .==. foldr (.->.) _beta _arguments_betas) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTExpression, AltNormalApplication, 0, "")
                  , location   = "application"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm _function_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ ApplicationEdge False (zip3 _arguments_oneLineTree
                                                               _arguments_betas
                                                               (map getExprRange _arguments_self)
                                                         )
                                 , SubTermRange (getExprRange _function_self)
                                 ]
                  }
        (_oneLineTree) =
            punctuate " " (_function_oneLineTree : _arguments_oneLineTree)
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        (((_t1,_t2),_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match2 _localInfo _arguments_uniqueSecondRound
                   match_Expression_NormalApplication
                   _lhs_tryPatterns _lhs_allPatterns
                   [_function_matches, _arguments_matches]
        ( _range_self) =
            (_range )
        ( _function_assumptions,_function_beta,_function_betaUnique,_function_collectednotypedef,_function_constraints,_function_localTypes,_function_matchIO,_function_matches,_function_oneLineTree,_function_overloadedVars,_function_patternMatchWarnings,_function_self,_function_typeAnnotations,_function_unboundNames,_function_uniqueSecondRound) =
            (_function (_lhs_allPatterns) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_t1) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _arguments_assumptions,_arguments_betaUnique,_arguments_betas,_arguments_collectednotypedef,_arguments_constraintslist,_arguments_localTypes,_arguments_matchIO,_arguments_matches,_arguments_oneLineTree,_arguments_overloadedVars,_arguments_patternMatchWarnings,_arguments_self,_arguments_typeAnnotations,_arguments_unboundNames,_arguments_uniqueSecondRound) =
            (_arguments (_lhs_allPatterns) (_function_betaUnique) (_function_collectednotypedef) (_lhs_importEnvironment) (_function_localTypes) (_function_matchIO) (_lhs_monos) (_lhs_namesInScope) (_function_overloadedVars) (_lhs_overloads) (_function_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_t2) (_function_typeAnnotations) (_function_uniqueSecondRound))
    in  ( _function_assumptions `combine` _arguments_assumptions,_beta,_arguments_betaUnique,_arguments_collectednotypedef,_newConstraintSet,_arguments_localTypes,_arguments_matchIO >> _ioMatch,_matches,_oneLineTree,_arguments_overloadedVars,_arguments_patternMatchWarnings,_self,_arguments_typeAnnotations,_function_unboundNames ++ _arguments_unboundNames,_newUnique)
sem_Expression_Parenthesized :: (T_Range) ->
                                (T_Expression) ->
                                (T_Expression)
sem_Expression_Parenthesized (_range) (_expression) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Parenthesized _range_self _expression_self
        (_oneLineTree) =
            parens _expression_oneLineTree
        ( _range_self) =
            (_range )
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_localTypes,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,_expression_self,_expression_typeAnnotations,_expression_unboundNames,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_localTypes,_expression_matchIO,_expression_matches,_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,_self,_expression_typeAnnotations,_expression_unboundNames,_expression_uniqueSecondRound)
sem_Expression_RecordConstruction :: (T_Range) ->
                                     (T_Name) ->
                                     (T_RecordExpressionBindings) ->
                                     (T_Expression)
sem_Expression_RecordConstruction (_range) (_name) (_recordExpressionBindings) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_RecordConstruction _range_self _name_self _recordExpressionBindings_self
        ((_assumptions,_constraints,_beta)) =
            internalError "PartialSyntax.ag" "n/a" "Expression.RecordConstruction"
        (_oneLineTree) =
            intErr "Expression" "record construction"
        (_matches) =
            undefined
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _recordExpressionBindings_collectednotypedef,_recordExpressionBindings_localTypes,_recordExpressionBindings_overloadedVars,_recordExpressionBindings_patternMatchWarnings,_recordExpressionBindings_self,_recordExpressionBindings_typeAnnotations,_recordExpressionBindings_unboundNames) =
            (_recordExpressionBindings (_lhs_collectednotypedef) (_lhs_localTypes) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations))
    in  ( _assumptions,_beta,_lhs_betaUnique,_recordExpressionBindings_collectednotypedef,_constraints,_recordExpressionBindings_localTypes,_lhs_matchIO,_matches,_oneLineTree,_recordExpressionBindings_overloadedVars,_recordExpressionBindings_patternMatchWarnings,_self,_recordExpressionBindings_typeAnnotations,_recordExpressionBindings_unboundNames,_lhs_uniqueSecondRound)
sem_Expression_RecordUpdate :: (T_Range) ->
                               (T_Expression) ->
                               (T_RecordExpressionBindings) ->
                               (T_Expression)
sem_Expression_RecordUpdate (_range) (_expression) (_recordExpressionBindings) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_RecordUpdate _range_self _expression_self _recordExpressionBindings_self
        (_oneLineTree) =
            intErr "Expression" "record update"
        ( _range_self) =
            (_range )
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_localTypes,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,_expression_self,_expression_typeAnnotations,_expression_unboundNames,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _recordExpressionBindings_collectednotypedef,_recordExpressionBindings_localTypes,_recordExpressionBindings_overloadedVars,_recordExpressionBindings_patternMatchWarnings,_recordExpressionBindings_self,_recordExpressionBindings_typeAnnotations,_recordExpressionBindings_unboundNames) =
            (_recordExpressionBindings (_expression_collectednotypedef) (_expression_localTypes) (_lhs_namesInScope) (_expression_overloadedVars) (_lhs_overloads) (_expression_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_expression_typeAnnotations))
    in  ( _expression_assumptions
         ,_expression_beta
         ,_expression_betaUnique
         ,_recordExpressionBindings_collectednotypedef
         ,_expression_constraints
         ,_recordExpressionBindings_localTypes
         ,_expression_matchIO
         ,_expression_matches
         ,_oneLineTree
         ,_recordExpressionBindings_overloadedVars
         ,_recordExpressionBindings_patternMatchWarnings
         ,_self
         ,_recordExpressionBindings_typeAnnotations
         ,_expression_unboundNames ++ _recordExpressionBindings_unboundNames
         ,_expression_uniqueSecondRound
         )
sem_Expression_Tuple :: (T_Range) ->
                        (T_Expressions) ->
                        (T_Expression)
sem_Expression_Tuple (_range) (_expressions) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Tuple _range_self _expressions_self
        (_constraints) =
            _newcon .>. Node _expressions_constraintslist
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            [ (tupleType _expressions_betas .==. _beta) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTExpression, AltTuple, 0, "")
                  , location   = "tuple"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , IsTupleEdge ]
                  }
        (_oneLineTree) =
            encloseSep "(" ", " ")" _expressions_oneLineTree
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        ((_t1,_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match1 _localInfo _expressions_uniqueSecondRound
                   match_Expression_Tuple
                   _lhs_tryPatterns _lhs_allPatterns
                   [_expressions_matches]
        ( _range_self) =
            (_range )
        ( _expressions_assumptions,_expressions_betaUnique,_expressions_betas,_expressions_collectednotypedef,_expressions_constraintslist,_expressions_localTypes,_expressions_matchIO,_expressions_matches,_expressions_oneLineTree,_expressions_overloadedVars,_expressions_patternMatchWarnings,_expressions_self,_expressions_typeAnnotations,_expressions_unboundNames,_expressions_uniqueSecondRound) =
            (_expressions (_lhs_allPatterns) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_t1) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _expressions_assumptions,_beta,_expressions_betaUnique,_expressions_collectednotypedef,_newConstraintSet,_expressions_localTypes,_expressions_matchIO >> _ioMatch,_matches,_oneLineTree,_expressions_overloadedVars,_expressions_patternMatchWarnings,_self,_expressions_typeAnnotations,_expressions_unboundNames,_newUnique)
sem_Expression_Typed :: (T_Range) ->
                        (T_Expression) ->
                        (T_Type) ->
                        (T_Expression)
sem_Expression_Typed (_range) (_expression) (_type) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Typed _range_self _expression_self _type_self
        (_constraints) =
            _conResult .>.
            Node [ _conExpr .<. _expression_constraints ]
        (_beta) =
            TVar _lhs_betaUnique
        (_typeScheme) =
            makeTpSchemeFromType _type_self
        (_conResult) =
            [ (_beta            .::. _typeScheme) _cinfoResult ]
        (_conExpr) =
            [ (_expression_beta .::. _typeScheme) _cinfoExpr   ]
        (_cinfoExpr) =
            \tppair ->
            CInfo { info       = (NTExpression, AltTyped, 0, "expression")
                  , location   = "type annotation"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm _expression_oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getExprRange _expression_self) ]
                  }
        (_cinfoResult) =
            \tppair ->
            CInfo { info       = (NTExpression, AltTyped, 1, "result")
                  , location   = "type annotation"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint ]
                  }
        (_oneLineTree) =
            OneLineNode
                [ OneLineNode [_expression_oneLineTree]
                , OneLineText " :: "
                , OneLineNode [ OneLineText (show (makeTpSchemeFromType _type_self))]
                ]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        ( _range_self) =
            (_range )
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_localTypes,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,_expression_self,_expression_typeAnnotations,_expression_unboundNames,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) ([]) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _type_self) =
            (_type )
    in  ( _expression_assumptions,_beta,_expression_betaUnique,_expression_collectednotypedef,_constraints,_expression_localTypes,_expression_matchIO,matchOnlyVariable _localInfo _lhs_tryPatterns,_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,_self,((_lhs_monos,_expression_beta),_typeScheme,(_expression_oneLineTree,_range_self)) : _expression_typeAnnotations,_expression_unboundNames,_expression_uniqueSecondRound)
sem_Expression_Variable :: (T_Range) ->
                           (T_Name) ->
                           (T_Expression)
sem_Expression_Variable (_range) (_name) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Variable _range_self _name_self
        (_constraints) =
            Node [ Receive _lhs_betaUnique ]
        (_beta) =
            TVar _lhs_betaUnique
        (_oneLineTree) =
            OneLineNode [_name_oneLineTree]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        (((),_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match0 _localInfo _lhs_uniqueSecondRound
                   (match_Expression_Variable _name_self)
                   _lhs_tryPatterns _lhs_allPatterns
                   []
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( _name_self `single` _beta
         ,_beta
         ,_lhs_betaUnique + 1
         ,_lhs_collectednotypedef
         ,_newConstraintSet
         ,_lhs_localTypes
         ,_lhs_matchIO >> _ioMatch
         ,_matches
         ,_oneLineTree
         ,let mName = filter (_name_self==) _lhs_namesInScope
          in case mName of
                [name] | any (equalNames name) _lhs_overloads
                  -> let qtype = getQualifiedType (generalize [] _lhs_predicates (_lhs_substitution |-> _beta))
                     in addToFM _lhs_overloadedVars (NameWithRange _name_self) (NameWithRange name, qtype)
                _ -> _lhs_overloadedVars
         ,_lhs_patternMatchWarnings
         ,_self
         ,_lhs_typeAnnotations
         ,[ _name_self ]
         ,_newUnique
         )
-- Expressions -------------------------------------------------
-- semantic domain
type T_Expressions = ([((Expression, [String]), Core_TypingStrategy)]) ->
                     (Int) ->
                     ([(Name,Tps,Tp,Bool)]) ->
                     (ImportEnvironment) ->
                     (LocalTypes) ->
                     (IO ()) ->
                     (Tps) ->
                     (Names) ->
                     (OverloadedVariables) ->
                     (Names) ->
                     ([Warning]) ->
                     (Predicates) ->
                     (WrappedSubstitution) ->
                     ([(Expressions    , [String])]) ->
                     (TypeAnnotations) ->
                     (Int) ->
                     ( (Assumptions),(Int),(Tps),([(Name,Tps,Tp,Bool)]),(ConstraintSets),(LocalTypes),(IO ()),([Maybe (MetaVariableTable MetaVariableInfo)]),( [ OneLineTree] ),(OverloadedVariables),([Warning]),(Expressions),(TypeAnnotations),(Names),(Int))
-- cata
sem_Expressions :: (Expressions) ->
                   (T_Expressions)
sem_Expressions (list) =
    (foldr (sem_Expressions_Cons) (sem_Expressions_Nil) ((map sem_Expression list)))
sem_Expressions_Cons :: (T_Expression) ->
                        (T_Expressions) ->
                        (T_Expressions)
sem_Expressions_Cons (_hd) (_tl) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            (:) _hd_self _tl_self
        (((_t1,_t2),_matches,_,_,_)) =
            match2' match_Expressions_Cons _lhs_tryPatterns [] [_hd_matches, _tl_matches]
        ( _hd_assumptions,_hd_beta,_hd_betaUnique,_hd_collectednotypedef,_hd_constraints,_hd_localTypes,_hd_matchIO,_hd_matches,_hd_oneLineTree,_hd_overloadedVars,_hd_patternMatchWarnings,_hd_self,_hd_typeAnnotations,_hd_unboundNames,_hd_uniqueSecondRound) =
            (_hd (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_t1) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _tl_assumptions,_tl_betaUnique,_tl_betas,_tl_collectednotypedef,_tl_constraintslist,_tl_localTypes,_tl_matchIO,_tl_matches,_tl_oneLineTree,_tl_overloadedVars,_tl_patternMatchWarnings,_tl_self,_tl_typeAnnotations,_tl_unboundNames,_tl_uniqueSecondRound) =
            (_tl (_lhs_allPatterns) (_hd_betaUnique) (_hd_collectednotypedef) (_lhs_importEnvironment) (_hd_localTypes) (_hd_matchIO) (_lhs_monos) (_lhs_namesInScope) (_hd_overloadedVars) (_lhs_overloads) (_hd_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_t2) (_hd_typeAnnotations) (_hd_uniqueSecondRound))
    in  ( _hd_assumptions `combine` _tl_assumptions,_tl_betaUnique,_hd_beta : _tl_betas,_tl_collectednotypedef,_hd_constraints : _tl_constraintslist,_tl_localTypes,_tl_matchIO,_matches,_hd_oneLineTree  :  _tl_oneLineTree,_tl_overloadedVars,_tl_patternMatchWarnings,_self,_tl_typeAnnotations,_hd_unboundNames ++ _tl_unboundNames,_tl_uniqueSecondRound)
sem_Expressions_Nil :: (T_Expressions)
sem_Expressions_Nil (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            []
        (((),_matches,_,_,_)) =
            match0' match_Expressions_Nil _lhs_tryPatterns [] []
    in  ( noAssumptions,_lhs_betaUnique,[],_lhs_collectednotypedef,[],_lhs_localTypes,_lhs_matchIO,_matches,[],_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,[],_lhs_uniqueSecondRound)
-- FieldDeclaration --------------------------------------------
-- semantic domain
type T_FieldDeclaration = (Names) ->
                          ( (FieldDeclaration),(Names))
-- cata
sem_FieldDeclaration :: (FieldDeclaration) ->
                        (T_FieldDeclaration)
sem_FieldDeclaration ((FieldDeclaration_FieldDeclaration (_range) (_names) (_type))) =
    (sem_FieldDeclaration_FieldDeclaration ((sem_Range (_range))) ((sem_Names (_names))) ((sem_AnnotatedType (_type))))
sem_FieldDeclaration_FieldDeclaration :: (T_Range) ->
                                         (T_Names) ->
                                         (T_AnnotatedType) ->
                                         (T_FieldDeclaration)
sem_FieldDeclaration_FieldDeclaration (_range) (_names) (_type) (_lhs_namesInScope) =
    let (_self) =
            FieldDeclaration_FieldDeclaration _range_self _names_self _type_self
        ((_kindErrors,_tyconEnv,_constructorenv,_importEnvironment,_valueConstructors,_allValueConstructors,_typeConstructors,_allTypeConstructors)) =
            internalError "PartialSyntax.ag" "n/a" "FieldDeclaration.FieldDeclaration"
        ( _range_self) =
            (_range )
        ( _names_isIdentifier,_names_isOperator,_names_isSpecial,_names_oneLineTree,_names_self) =
            (_names )
        ( _type_self,_type_unboundNames) =
            (_type (_lhs_namesInScope))
    in  ( _self,_type_unboundNames)
-- FieldDeclarations -------------------------------------------
-- semantic domain
type T_FieldDeclarations = (Names) ->
                           ( (FieldDeclarations),(Names))
-- cata
sem_FieldDeclarations :: (FieldDeclarations) ->
                         (T_FieldDeclarations)
sem_FieldDeclarations (list) =
    (foldr (sem_FieldDeclarations_Cons) (sem_FieldDeclarations_Nil) ((map sem_FieldDeclaration list)))
sem_FieldDeclarations_Cons :: (T_FieldDeclaration) ->
                              (T_FieldDeclarations) ->
                              (T_FieldDeclarations)
sem_FieldDeclarations_Cons (_hd) (_tl) (_lhs_namesInScope) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_self,_hd_unboundNames) =
            (_hd (_lhs_namesInScope))
        ( _tl_self,_tl_unboundNames) =
            (_tl (_lhs_namesInScope))
    in  ( _self,_hd_unboundNames ++ _tl_unboundNames)
sem_FieldDeclarations_Nil :: (T_FieldDeclarations)
sem_FieldDeclarations_Nil (_lhs_namesInScope) =
    let (_self) =
            []
    in  ( _self,[])
-- Fixity ------------------------------------------------------
-- semantic domain
type T_Fixity = ( (Fixity))
-- cata
sem_Fixity :: (Fixity) ->
              (T_Fixity)
sem_Fixity ((Fixity_Infix (_range))) =
    (sem_Fixity_Infix ((sem_Range (_range))))
sem_Fixity ((Fixity_Infixl (_range))) =
    (sem_Fixity_Infixl ((sem_Range (_range))))
sem_Fixity ((Fixity_Infixr (_range))) =
    (sem_Fixity_Infixr ((sem_Range (_range))))
sem_Fixity_Infix :: (T_Range) ->
                    (T_Fixity)
sem_Fixity_Infix (_range) =
    let (_self) =
            Fixity_Infix _range_self
        ( _range_self) =
            (_range )
    in  ( _self)
sem_Fixity_Infixl :: (T_Range) ->
                     (T_Fixity)
sem_Fixity_Infixl (_range) =
    let (_self) =
            Fixity_Infixl _range_self
        ( _range_self) =
            (_range )
    in  ( _self)
sem_Fixity_Infixr :: (T_Range) ->
                     (T_Fixity)
sem_Fixity_Infixr (_range) =
    let (_self) =
            Fixity_Infixr _range_self
        ( _range_self) =
            (_range )
    in  ( _self)
-- FunctionBinding ---------------------------------------------
-- semantic domain
type T_FunctionBinding = ([((Expression, [String]), Core_TypingStrategy)]) ->
                         (Tp) ->
                         (Int) ->
                         (Tps) ->
                         ([(Name,Tps,Tp,Bool)]) ->
                         (ImportEnvironment) ->
                         (LocalTypes) ->
                         (IO ()) ->
                         (Tps) ->
                         (Names) ->
                         (OverloadedVariables) ->
                         (Names) ->
                         ([Warning]) ->
                         (Predicates) ->
                         (WrappedSubstitution) ->
                         (TypeAnnotations) ->
                         ( (Int),(Assumptions),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),( ([PatternElement], Bool) ),(LocalTypes),(IO ()),(Name),(Int),(OneLineTree),(OverloadedVariables),([Warning]),(FunctionBinding),(TypeAnnotations),(Names),(Warning))
-- cata
sem_FunctionBinding :: (FunctionBinding) ->
                       (T_FunctionBinding)
sem_FunctionBinding ((FunctionBinding_FunctionBinding (_range) (_lefthandside) (_righthandside))) =
    (sem_FunctionBinding_FunctionBinding ((sem_Range (_range))) ((sem_LeftHandSide (_lefthandside))) ((sem_RightHandSide (_righthandside))))
sem_FunctionBinding_FunctionBinding :: (T_Range) ->
                                       (T_LeftHandSide) ->
                                       (T_RightHandSide) ->
                                       (T_FunctionBinding)
sem_FunctionBinding_FunctionBinding (_range) (_lefthandside) (_righthandside) (_lhs_allPatterns) (_lhs_betaRight) (_lhs_betaUnique) (_lhs_betasLeft) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) =
    let (_self) =
            FunctionBinding_FunctionBinding _range_self _lefthandside_self _righthandside_self
        ((_csetBinds,_assumptions')) =
            (_lefthandside_environment .===. _righthandside_assumptions) _cinfoBind
        (_conLeft) =
            zipWith4 (\t1 t2 txt nr -> (t1 .==. t2) (_cinfoLeft nr txt)) _lefthandside_betas _lhs_betasLeft _lefthandside_patternTrees [0..]
        (_conRight) =
            [ (_righthandside_beta .==. _lhs_betaRight) _cinfoRight ]
        (_cinfoLeft) =
            \num txt tppair ->
            CInfo { info       = (NTFunctionBinding, AltFunctionBinding, 0, "left "++show num)
                  , location   = "pattern of function binding"
                  , errorrange = _range_self
                  , sources    = [ sourcePattern txt ]
                  , typepair   = tppair
                  , properties = [ ]
                  }
        (_cinfoRight) =
            \tppair ->
            CInfo { info       = (NTFunctionBinding, AltFunctionBinding, 1, "right")
                  , location   = "right hand side"
                  , errorrange = _range_self
                  , sources    = [ sourceTerm (_righthandside_oneLineTree "") ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getRHSRange _righthandside_self) ]
                  }
        (_cinfoBind) =
            variableBindingCInfo (NTFunctionBinding, AltFunctionBinding, 2)
        (_oneLineTree) =
            OneLineNode [_lefthandside_oneLineTree, _righthandside_oneLineTree " = " ]
        ((_namesInScope,_unboundNames,_scopeInfo)) =
            changeOfScope _lefthandside_patVarNames _righthandside_unboundNames _lhs_namesInScope
        ( _range_self) =
            (_range )
        ( _lefthandside_argcount,_lefthandside_betaUnique,_lefthandside_betas,_lefthandside_constraints,_lefthandside_elements,_lefthandside_environment,_lefthandside_name,_lefthandside_numberOfPatterns,_lefthandside_oneLineTree,_lefthandside_patVarNames,_lefthandside_patternMatchWarnings,_lefthandside_patternTrees,_lefthandside_self,_lefthandside_unboundNames) =
            (_lefthandside (_lhs_betaUnique) (_lhs_importEnvironment) (_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution))
        ( _righthandside_assumptions,_righthandside_beta,_righthandside_betaUnique,_righthandside_collectednotypedef,_righthandside_constraints,_righthandside_fallthrough,_righthandside_localTypes,_righthandside_matchIO,_righthandside_oneLineTree,_righthandside_overloadedVars,_righthandside_patternMatchWarnings,_righthandside_self,_righthandside_typeAnnotations,_righthandside_unboundNames) =
            (_righthandside (_lhs_allPatterns) (_lefthandside_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (eltsFM _lefthandside_environment ++ getMonos _csetBinds ++ _lhs_monos) (_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lefthandside_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations))
    in  ( _lefthandside_argcount
         ,_assumptions'
         ,_righthandside_betaUnique
         ,_righthandside_collectednotypedef
         ,_csetBinds .>>.
          Node [ _conLeft  .<. _lefthandside_constraints
               , _conRight .<. _righthandside_constraints
               ]
         ,(_lefthandside_elements, _righthandside_fallthrough)
         ,_righthandside_localTypes
         ,_righthandside_matchIO
         ,_lefthandside_name
         ,_lefthandside_numberOfPatterns
         ,_oneLineTree
         ,_righthandside_overloadedVars
         ,_righthandside_patternMatchWarnings
         ,_self
         ,_righthandside_typeAnnotations
         ,_unboundNames
         ,UnreachablePatternLHS _lefthandside_self
         )
-- FunctionBindings --------------------------------------------
-- semantic domain
type T_FunctionBindings = ([((Expression, [String]), Core_TypingStrategy)]) ->
                          (Tp) ->
                          (Int) ->
                          (Tps) ->
                          ([(Name,Tps,Tp,Bool)]) ->
                          (ImportEnvironment) ->
                          (LocalTypes) ->
                          (IO ()) ->
                          (Tps) ->
                          (Names) ->
                          (OverloadedVariables) ->
                          (Names) ->
                          ([Warning]) ->
                          (Predicates) ->
                          (WrappedSubstitution) ->
                          (TypeAnnotations) ->
                          ( (Int),(Assumptions),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSets),([([PatternElement], Bool)]),(LocalTypes),(IO ()),(Name),(Int),( [ OneLineTree] ),(OverloadedVariables),([Warning]),(FunctionBindings),(TypeAnnotations),(Names),([Warning]))
-- cata
sem_FunctionBindings :: (FunctionBindings) ->
                        (T_FunctionBindings)
sem_FunctionBindings (list) =
    (foldr (sem_FunctionBindings_Cons) (sem_FunctionBindings_Nil) ((map sem_FunctionBinding list)))
sem_FunctionBindings_Cons :: (T_FunctionBinding) ->
                             (T_FunctionBindings) ->
                             (T_FunctionBindings)
sem_FunctionBindings_Cons (_hd) (_tl) (_lhs_allPatterns) (_lhs_betaRight) (_lhs_betaUnique) (_lhs_betasLeft) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_argcount,_hd_assumptions,_hd_betaUnique,_hd_collectednotypedef,_hd_constraints,_hd_elements,_hd_localTypes,_hd_matchIO,_hd_name,_hd_numberOfPatterns,_hd_oneLineTree,_hd_overloadedVars,_hd_patternMatchWarnings,_hd_self,_hd_typeAnnotations,_hd_unboundNames,_hd_unrwar) =
            (_hd (_lhs_allPatterns) (_lhs_betaRight) (_lhs_betaUnique) (_lhs_betasLeft) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations))
        ( _tl_argcount,_tl_assumptions,_tl_betaUnique,_tl_collectednotypedef,_tl_constraintslist,_tl_elementss,_tl_localTypes,_tl_matchIO,_tl_name,_tl_numberOfPatterns,_tl_oneLineTree,_tl_overloadedVars,_tl_patternMatchWarnings,_tl_self,_tl_typeAnnotations,_tl_unboundNames,_tl_unrwars) =
            (_tl (_lhs_allPatterns) (_lhs_betaRight) (_hd_betaUnique) (_lhs_betasLeft) (_hd_collectednotypedef) (_lhs_importEnvironment) (_hd_localTypes) (_hd_matchIO) (_lhs_monos) (_lhs_namesInScope) (_hd_overloadedVars) (_lhs_overloads) (_hd_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_hd_typeAnnotations))
    in  ( _hd_argcount,_hd_assumptions `combine` _tl_assumptions,_tl_betaUnique,_tl_collectednotypedef,_hd_constraints : _tl_constraintslist,_hd_elements : _tl_elementss,_tl_localTypes,_tl_matchIO,_hd_name,_hd_numberOfPatterns,_hd_oneLineTree  :  _tl_oneLineTree,_tl_overloadedVars,_tl_patternMatchWarnings,_self,_tl_typeAnnotations,_hd_unboundNames ++ _tl_unboundNames,_hd_unrwar   : _tl_unrwars)
sem_FunctionBindings_Nil :: (T_FunctionBindings)
sem_FunctionBindings_Nil (_lhs_allPatterns) (_lhs_betaRight) (_lhs_betaUnique) (_lhs_betasLeft) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) =
    let (_self) =
            []
    in  ( pmError "FunctionBindings_Nil.argcount" "?empty list of function bindings?",noAssumptions,_lhs_betaUnique,_lhs_collectednotypedef,[],[],_lhs_localTypes,_lhs_matchIO,internalError "TypeInferencing.ag" "n/a" "FunctionBindings(2)",internalError "TypeInferencing.ag" "n/a" "FunctionBindings(1)",[],_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,[],[])
-- GuardedExpression -------------------------------------------
-- semantic domain
type T_GuardedExpression = ([((Expression, [String]), Core_TypingStrategy)]) ->
                           (Int) ->
                           ([(Name,Tps,Tp,Bool)]) ->
                           (ImportEnvironment) ->
                           (LocalTypes) ->
                           (IO ()) ->
                           (Tps) ->
                           (Names) ->
                           (Int) ->
                           (OverloadedVariables) ->
                           (Names) ->
                           ([Warning]) ->
                           (Predicates) ->
                           (Tp) ->
                           (WrappedSubstitution) ->
                           (TypeAnnotations) ->
                           (Int) ->
                           ( (Assumptions),(Tp),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(Bool),(LocalTypes),(IO ()),( String -> OneLineTree ),(OverloadedVariables),([Warning]),(Range),(GuardedExpression),(TypeAnnotations),(Names),(Int),(Warning))
-- cata
sem_GuardedExpression :: (GuardedExpression) ->
                         (T_GuardedExpression)
sem_GuardedExpression ((GuardedExpression_GuardedExpression (_range) (_guard) (_expression))) =
    (sem_GuardedExpression_GuardedExpression ((sem_Range (_range))) ((sem_Expression (_guard))) ((sem_Expression (_expression))))
sem_GuardedExpression_GuardedExpression :: (T_Range) ->
                                           (T_Expression) ->
                                           (T_Expression) ->
                                           (T_GuardedExpression)
sem_GuardedExpression_GuardedExpression (_range) (_guard) (_expression) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_numberOfGuards) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_rightBeta) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            GuardedExpression_GuardedExpression _range_self _guard_self _expression_self
        (_newconGuard) =
            [ (_guard_beta .==. boolType) _cinfoGuard ]
        (_newconExpr) =
            [ (_expression_beta .==. _lhs_rightBeta) _cinfoExpr ]
        (_cinfoGuard) =
            \tppair ->
            CInfo { info       = (NTGuardedExpression, AltGuardedExpression, 0, "guard")
                  , location   = "guard"
                  , errorrange = getExprRange _guard_self
                  , sources    = [ sourceExpression _guard_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ ]
                  }
        (_cinfoExpr) =
            \tppair ->
            CInfo { info       = (NTGuardedExpression, AltGuardedExpression, 1, "expression")
                  , location   = "guarded expression"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _expression_oneLineTree ]
                  , typepair   = tppair
                  , properties = if _lhs_numberOfGuards > 1 then [] else [ HighlyTrusted ]
                  }
        (_oneLineTree) =
            \assign -> OneLineNode [ _guard_oneLineTree, OneLineText assign, _expression_oneLineTree ]
        ( _range_self) =
            (_range )
        ( _guard_assumptions,_guard_beta,_guard_betaUnique,_guard_collectednotypedef,_guard_constraints,_guard_localTypes,_guard_matchIO,_guard_matches,_guard_oneLineTree,_guard_overloadedVars,_guard_patternMatchWarnings,_guard_self,_guard_typeAnnotations,_guard_unboundNames,_guard_uniqueSecondRound) =
            (_guard (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) ([]) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_localTypes,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,_expression_self,_expression_typeAnnotations,_expression_unboundNames,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_guard_betaUnique) (_guard_collectednotypedef) (_lhs_importEnvironment) (_guard_localTypes) (_guard_matchIO) (_lhs_monos) (_lhs_namesInScope) (_guard_overloadedVars) (_lhs_overloads) (_guard_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) ([]) (_guard_typeAnnotations) (_guard_uniqueSecondRound))
    in  ( _guard_assumptions `combine` _expression_assumptions
         ,_expression_beta
         ,_expression_betaUnique
         ,_expression_collectednotypedef
         ,Node [ _newconGuard .<. _guard_constraints
               , _newconExpr  .<. _expression_constraints
               ]
         ,case _guard_self
          of Expression_Variable    _ (Name_Identifier _ _ "otherwise") -> False
             Expression_Constructor _ (Name_Identifier _ _ "True"     ) -> False
             _                                                          -> True
         ,_expression_localTypes
         ,_expression_matchIO
         ,_oneLineTree
         ,_expression_overloadedVars
         ,_expression_patternMatchWarnings
         ,_range
         ,_self
         ,_expression_typeAnnotations
         ,_guard_unboundNames ++ _expression_unboundNames
         ,_expression_uniqueSecondRound
         ,UnreachableGuard _range _guard_self
         )
-- GuardedExpressions ------------------------------------------
-- semantic domain
type T_GuardedExpressions = ([((Expression, [String]), Core_TypingStrategy)]) ->
                            (Int) ->
                            ([(Name,Tps,Tp,Bool)]) ->
                            (ImportEnvironment) ->
                            (LocalTypes) ->
                            (IO ()) ->
                            (Tps) ->
                            (Names) ->
                            (Int) ->
                            (Bool) ->
                            (OverloadedVariables) ->
                            (Names) ->
                            ([Warning]) ->
                            (Predicates) ->
                            (Tp) ->
                            (WrappedSubstitution) ->
                            (TypeAnnotations) ->
                            (Int) ->
                            ( (Assumptions),(Int),(Tps),([(Name,Tps,Tp,Bool)]),(ConstraintSets),(Bool),(LocalTypes),(IO ()),( [ String -> OneLineTree ] ),(OverloadedVariables),([Warning]),(GuardedExpressions),(TypeAnnotations),(Names),(Int))
-- cata
sem_GuardedExpressions :: (GuardedExpressions) ->
                          (T_GuardedExpressions)
sem_GuardedExpressions (list) =
    (foldr (sem_GuardedExpressions_Cons) (sem_GuardedExpressions_Nil) ((map sem_GuardedExpression list)))
sem_GuardedExpressions_Cons :: (T_GuardedExpression) ->
                               (T_GuardedExpressions) ->
                               (T_GuardedExpressions)
sem_GuardedExpressions_Cons (_hd) (_tl) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_numberOfGuards) (_lhs_open) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_rightBeta) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_assumptions,_hd_beta,_hd_betaUnique,_hd_collectednotypedef,_hd_constraints,_hd_fallthrough,_hd_localTypes,_hd_matchIO,_hd_oneLineTree,_hd_overloadedVars,_hd_patternMatchWarnings,_hd_range,_hd_self,_hd_typeAnnotations,_hd_unboundNames,_hd_uniqueSecondRound,_hd_unrwar) =
            (_hd (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_numberOfGuards) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_rightBeta) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _tl_assumptions,_tl_betaUnique,_tl_betas,_tl_collectednotypedef,_tl_constraintslist,_tl_fallthrough,_tl_localTypes,_tl_matchIO,_tl_oneLineTree,_tl_overloadedVars,_tl_patternMatchWarnings,_tl_self,_tl_typeAnnotations,_tl_unboundNames,_tl_uniqueSecondRound) =
            (_tl (_lhs_allPatterns) (_hd_betaUnique) (_hd_collectednotypedef) (_lhs_importEnvironment) (_hd_localTypes) (_hd_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_numberOfGuards) (_hd_fallthrough && _lhs_open) (_hd_overloadedVars) (_lhs_overloads) (_hd_patternMatchWarnings) (_lhs_predicates) (_lhs_rightBeta) (_lhs_substitution) (_hd_typeAnnotations) (_hd_uniqueSecondRound))
    in  ( _hd_assumptions `combine` _tl_assumptions
         ,_tl_betaUnique
         ,_hd_beta : _tl_betas
         ,_tl_collectednotypedef
         ,_hd_constraints : _tl_constraintslist
         ,_hd_fallthrough && _tl_fallthrough
         ,_tl_localTypes
         ,_tl_matchIO
         ,_hd_oneLineTree  :  _tl_oneLineTree
         ,_tl_overloadedVars
         ,(if not _lhs_open then [_hd_unrwar] else [])
          ++ _tl_patternMatchWarnings
         ,_self
         ,_tl_typeAnnotations
         ,_hd_unboundNames ++ _tl_unboundNames
         ,_tl_uniqueSecondRound
         )
sem_GuardedExpressions_Nil :: (T_GuardedExpressions)
sem_GuardedExpressions_Nil (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_numberOfGuards) (_lhs_open) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_rightBeta) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            []
    in  ( noAssumptions,_lhs_betaUnique,[],_lhs_collectednotypedef,[],True,_lhs_localTypes,_lhs_matchIO,[],_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,[],_lhs_uniqueSecondRound)
-- Import ------------------------------------------------------
-- semantic domain
type T_Import = ( (Import))
-- cata
sem_Import :: (Import) ->
              (T_Import)
sem_Import ((Import_TypeOrClass (_range) (_name) (_names))) =
    (sem_Import_TypeOrClass ((sem_Range (_range))) ((sem_Name (_name))) ((sem_MaybeNames (_names))))
sem_Import ((Import_TypeOrClassComplete (_range) (_name))) =
    (sem_Import_TypeOrClassComplete ((sem_Range (_range))) ((sem_Name (_name))))
sem_Import ((Import_Variable (_range) (_name))) =
    (sem_Import_Variable ((sem_Range (_range))) ((sem_Name (_name))))
sem_Import_TypeOrClass :: (T_Range) ->
                          (T_Name) ->
                          (T_MaybeNames) ->
                          (T_Import)
sem_Import_TypeOrClass (_range) (_name) (_names) =
    let (_self) =
            Import_TypeOrClass _range_self _name_self _names_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _names_self) =
            (_names )
    in  ( _self)
sem_Import_TypeOrClassComplete :: (T_Range) ->
                                  (T_Name) ->
                                  (T_Import)
sem_Import_TypeOrClassComplete (_range) (_name) =
    let (_self) =
            Import_TypeOrClassComplete _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( _self)
sem_Import_Variable :: (T_Range) ->
                       (T_Name) ->
                       (T_Import)
sem_Import_Variable (_range) (_name) =
    let (_self) =
            Import_Variable _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( _self)
-- ImportDeclaration -------------------------------------------
-- semantic domain
type T_ImportDeclaration = ( (ImportDeclaration))
-- cata
sem_ImportDeclaration :: (ImportDeclaration) ->
                         (T_ImportDeclaration)
sem_ImportDeclaration ((ImportDeclaration_Empty (_range))) =
    (sem_ImportDeclaration_Empty ((sem_Range (_range))))
sem_ImportDeclaration ((ImportDeclaration_Import (_range) (_qualified) (_name) (_asname) (_importspecification))) =
    (sem_ImportDeclaration_Import ((sem_Range (_range))) (_qualified) ((sem_Name (_name))) ((sem_MaybeName (_asname))) ((sem_MaybeImportSpecification (_importspecification))))
sem_ImportDeclaration_Empty :: (T_Range) ->
                               (T_ImportDeclaration)
sem_ImportDeclaration_Empty (_range) =
    let (_self) =
            ImportDeclaration_Empty _range_self
        ( _range_self) =
            (_range )
    in  ( _self)
sem_ImportDeclaration_Import :: (T_Range) ->
                                (Bool) ->
                                (T_Name) ->
                                (T_MaybeName) ->
                                (T_MaybeImportSpecification) ->
                                (T_ImportDeclaration)
sem_ImportDeclaration_Import (_range) (_qualified) (_name) (_asname) (_importspecification) =
    let (_self) =
            ImportDeclaration_Import _range_self _qualified _name_self _asname_self _importspecification_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _asname_self) =
            (_asname )
        ( _importspecification_self) =
            (_importspecification )
    in  ( _self)
-- ImportDeclarations ------------------------------------------
-- semantic domain
type T_ImportDeclarations = ( (ImportDeclarations))
-- cata
sem_ImportDeclarations :: (ImportDeclarations) ->
                          (T_ImportDeclarations)
sem_ImportDeclarations (list) =
    (foldr (sem_ImportDeclarations_Cons) (sem_ImportDeclarations_Nil) ((map sem_ImportDeclaration list)))
sem_ImportDeclarations_Cons :: (T_ImportDeclaration) ->
                               (T_ImportDeclarations) ->
                               (T_ImportDeclarations)
sem_ImportDeclarations_Cons (_hd) (_tl) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  ( _self)
sem_ImportDeclarations_Nil :: (T_ImportDeclarations)
sem_ImportDeclarations_Nil  =
    let (_self) =
            []
    in  ( _self)
-- ImportSpecification -----------------------------------------
-- semantic domain
type T_ImportSpecification = ( (ImportSpecification))
-- cata
sem_ImportSpecification :: (ImportSpecification) ->
                           (T_ImportSpecification)
sem_ImportSpecification ((ImportSpecification_Import (_range) (_hiding) (_imports))) =
    (sem_ImportSpecification_Import ((sem_Range (_range))) (_hiding) ((sem_Imports (_imports))))
sem_ImportSpecification_Import :: (T_Range) ->
                                  (Bool) ->
                                  (T_Imports) ->
                                  (T_ImportSpecification)
sem_ImportSpecification_Import (_range) (_hiding) (_imports) =
    let (_self) =
            ImportSpecification_Import _range_self _hiding _imports_self
        ( _range_self) =
            (_range )
        ( _imports_self) =
            (_imports )
    in  ( _self)
-- Imports -----------------------------------------------------
-- semantic domain
type T_Imports = ( (Imports))
-- cata
sem_Imports :: (Imports) ->
               (T_Imports)
sem_Imports (list) =
    (foldr (sem_Imports_Cons) (sem_Imports_Nil) ((map sem_Import list)))
sem_Imports_Cons :: (T_Import) ->
                    (T_Imports) ->
                    (T_Imports)
sem_Imports_Cons (_hd) (_tl) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  ( _self)
sem_Imports_Nil :: (T_Imports)
sem_Imports_Nil  =
    let (_self) =
            []
    in  ( _self)
-- LeftHandSide ------------------------------------------------
-- semantic domain
type T_LeftHandSide = (Int) ->
                      (ImportEnvironment) ->
                      (Names) ->
                      ([Warning]) ->
                      (WrappedSubstitution) ->
                      ( (Int),(Int),(Tps),(ConstraintSet),(  [PatternElement]        ),(PatternAssumptions),(Name),(Int),(OneLineTree),(Names),([Warning]),([OneLineTree]),(LeftHandSide),(Names))
-- cata
sem_LeftHandSide :: (LeftHandSide) ->
                    (T_LeftHandSide)
sem_LeftHandSide ((LeftHandSide_Function (_range) (_name) (_patterns))) =
    (sem_LeftHandSide_Function ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Patterns (_patterns))))
sem_LeftHandSide ((LeftHandSide_Infix (_range) (_leftPattern) (_operator) (_rightPattern))) =
    (sem_LeftHandSide_Infix ((sem_Range (_range))) ((sem_Pattern (_leftPattern))) ((sem_Name (_operator))) ((sem_Pattern (_rightPattern))))
sem_LeftHandSide ((LeftHandSide_Parenthesized (_range) (_lefthandside) (_patterns))) =
    (sem_LeftHandSide_Parenthesized ((sem_Range (_range))) ((sem_LeftHandSide (_lefthandside))) ((sem_Patterns (_patterns))))
sem_LeftHandSide_Function :: (T_Range) ->
                             (T_Name) ->
                             (T_Patterns) ->
                             (T_LeftHandSide)
sem_LeftHandSide_Function (_range) (_name) (_patterns) (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            LeftHandSide_Function _range_self _name_self _patterns_self
        (_oneLineTree) =
            punctuate " " (_name_oneLineTree : _patterns_oneLineTree)
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _patterns_betaUnique,_patterns_betas,_patterns_constraintslist,_patterns_elementss,_patterns_environment,_patterns_numberOfPatterns,_patterns_oneLineTree,_patterns_patVarNames,_patterns_patternMatchWarnings,_patterns_self,_patterns_unboundNames) =
            (_patterns (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution))
    in  ( length _patterns_self,_patterns_betaUnique,_patterns_betas,Node _patterns_constraintslist,concat _patterns_elementss,_patterns_environment,_name_self,_patterns_numberOfPatterns,_oneLineTree,_patterns_patVarNames,_patterns_patternMatchWarnings,_patterns_oneLineTree,_self,_patterns_unboundNames)
sem_LeftHandSide_Infix :: (T_Range) ->
                          (T_Pattern) ->
                          (T_Name) ->
                          (T_Pattern) ->
                          (T_LeftHandSide)
sem_LeftHandSide_Infix (_range) (_leftPattern) (_operator) (_rightPattern) (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            LeftHandSide_Infix _range_self _leftPattern_self _operator_self _rightPattern_self
        (_operatorName) =
            oneLineTreeAsOperator _operator_oneLineTree
        (_oneLineTree) =
            punctuate " " [_leftPattern_oneLineTree, _operatorName, _rightPattern_oneLineTree]
        ( _range_self) =
            (_range )
        ( _leftPattern_beta,_leftPattern_betaUnique,_leftPattern_constraints,_leftPattern_elements,_leftPattern_environment,_leftPattern_oneLineTree,_leftPattern_patVarNames,_leftPattern_patternMatchWarnings,_leftPattern_self,_leftPattern_unboundNames) =
            (_leftPattern (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution))
        ( _operator_isIdentifier,_operator_isOperator,_operator_isSpecial,_operator_oneLineTree,_operator_self) =
            (_operator )
        ( _rightPattern_beta,_rightPattern_betaUnique,_rightPattern_constraints,_rightPattern_elements,_rightPattern_environment,_rightPattern_oneLineTree,_rightPattern_patVarNames,_rightPattern_patternMatchWarnings,_rightPattern_self,_rightPattern_unboundNames) =
            (_rightPattern (_leftPattern_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_leftPattern_patternMatchWarnings) (_lhs_substitution))
    in  ( 2
         ,_rightPattern_betaUnique
         ,[_leftPattern_beta,_rightPattern_beta]
         ,Node [ _leftPattern_constraints
               , _rightPattern_constraints
               ]
         ,_leftPattern_elements ++ _rightPattern_elements
         ,_leftPattern_environment `plusFM` _rightPattern_environment
         ,_operator_self
         ,2
         ,_oneLineTree
         ,_leftPattern_patVarNames ++ _rightPattern_patVarNames
         ,_rightPattern_patternMatchWarnings
         ,[_leftPattern_oneLineTree, _rightPattern_oneLineTree]
         ,_self
         ,_leftPattern_unboundNames ++ _rightPattern_unboundNames
         )
sem_LeftHandSide_Parenthesized :: (T_Range) ->
                                  (T_LeftHandSide) ->
                                  (T_Patterns) ->
                                  (T_LeftHandSide)
sem_LeftHandSide_Parenthesized (_range) (_lefthandside) (_patterns) (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            LeftHandSide_Parenthesized _range_self _lefthandside_self _patterns_self
        (_oneLineTree) =
            punctuate " " ( parens _lefthandside_oneLineTree : _patterns_oneLineTree )
        ( _range_self) =
            (_range )
        ( _lefthandside_argcount,_lefthandside_betaUnique,_lefthandside_betas,_lefthandside_constraints,_lefthandside_elements,_lefthandside_environment,_lefthandside_name,_lefthandside_numberOfPatterns,_lefthandside_oneLineTree,_lefthandside_patVarNames,_lefthandside_patternMatchWarnings,_lefthandside_patternTrees,_lefthandside_self,_lefthandside_unboundNames) =
            (_lefthandside (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution))
        ( _patterns_betaUnique,_patterns_betas,_patterns_constraintslist,_patterns_elementss,_patterns_environment,_patterns_numberOfPatterns,_patterns_oneLineTree,_patterns_patVarNames,_patterns_patternMatchWarnings,_patterns_self,_patterns_unboundNames) =
            (_patterns (_lefthandside_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lefthandside_patternMatchWarnings) (_lhs_substitution))
    in  ( _lefthandside_argcount
         ,_patterns_betaUnique
         ,_lefthandside_betas ++ _patterns_betas
         ,Node ( _lefthandside_constraints : _patterns_constraintslist )
         ,_lefthandside_elements
         ,_lefthandside_environment `plusFM` _patterns_environment
         ,_lefthandside_name
         ,_lefthandside_numberOfPatterns + _patterns_numberOfPatterns
         ,_oneLineTree
         ,_lefthandside_patVarNames ++ _patterns_patVarNames
         ,_patterns_patternMatchWarnings
         ,_lefthandside_patternTrees ++ _patterns_oneLineTree
         ,_self
         ,_lefthandside_unboundNames ++ _patterns_unboundNames
         )
-- Literal -----------------------------------------------------
-- semantic domain
type T_Literal = ( (  [PatternElement]        ),(Tp),(OneLineTree),(Literal))
-- cata
sem_Literal :: (Literal) ->
               (T_Literal)
sem_Literal ((Literal_Char (_range) (_value))) =
    (sem_Literal_Char ((sem_Range (_range))) (_value))
sem_Literal ((Literal_Float (_range) (_value))) =
    (sem_Literal_Float ((sem_Range (_range))) (_value))
sem_Literal ((Literal_Int (_range) (_value))) =
    (sem_Literal_Int ((sem_Range (_range))) (_value))
sem_Literal ((Literal_String (_range) (_value))) =
    (sem_Literal_String ((sem_Range (_range))) (_value))
sem_Literal_Char :: (T_Range) ->
                    (String) ->
                    (T_Literal)
sem_Literal_Char (_range) (_value) =
    let (_self) =
            Literal_Char _range_self _value
        (_oneLineTree) =
            OneLineText ("'" ++ _value ++ "'")
        ( _range_self) =
            (_range )
    in  ( [InfiniteElement _value],charType,_oneLineTree,_self)
sem_Literal_Float :: (T_Range) ->
                     (String) ->
                     (T_Literal)
sem_Literal_Float (_range) (_value) =
    let (_self) =
            Literal_Float _range_self _value
        (_oneLineTree) =
            OneLineText _value
        ( _range_self) =
            (_range )
    in  ( [InfiniteElement _value],floatType,_oneLineTree,_self)
sem_Literal_Int :: (T_Range) ->
                   (String) ->
                   (T_Literal)
sem_Literal_Int (_range) (_value) =
    let (_self) =
            Literal_Int _range_self _value
        (_oneLineTree) =
            OneLineText _value
        ( _range_self) =
            (_range )
    in  ( [InfiniteElement _value],intType,_oneLineTree,_self)
sem_Literal_String :: (T_Range) ->
                      (String) ->
                      (T_Literal)
sem_Literal_String (_range) (_value) =
    let (_self) =
            Literal_String _range_self _value
        (_oneLineTree) =
            OneLineText ("\"" ++ _value ++ "\"")
        ( _range_self) =
            (_range )
    in  ( stringPat _value,stringType,_oneLineTree,_self)
-- MaybeDeclarations -------------------------------------------
-- semantic domain
type T_MaybeDeclarations = ([((Expression, [String]), Core_TypingStrategy)]) ->
                           (Assumptions) ->
                           (Int) ->
                           ([(Name,Tps,Tp,Bool)]) ->
                           (ConstraintSet) ->
                           (ImportEnvironment) ->
                           (LocalTypes) ->
                           (IO ()) ->
                           (Tps) ->
                           (Names) ->
                           (OverloadedVariables) ->
                           (Names) ->
                           ([Warning]) ->
                           (Predicates) ->
                           (WrappedSubstitution) ->
                           (TypeAnnotations) ->
                           (Names) ->
                           ( (Assumptions),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(LocalTypes),(IO ()),(Names),( Maybe [OneLineTree] ),(OverloadedVariables),([Warning]),(MaybeDeclarations),(TypeAnnotations),(Names))
-- cata
sem_MaybeDeclarations :: (MaybeDeclarations) ->
                         (T_MaybeDeclarations)
sem_MaybeDeclarations ((MaybeDeclarations_Just (_declarations))) =
    (sem_MaybeDeclarations_Just ((sem_Declarations (_declarations))))
sem_MaybeDeclarations ((MaybeDeclarations_Nothing )) =
    (sem_MaybeDeclarations_Nothing )
sem_MaybeDeclarations_Just :: (T_Declarations) ->
                              (T_MaybeDeclarations)
sem_MaybeDeclarations_Just (_declarations) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_unboundNames) =
    let (_self) =
            MaybeDeclarations_Just _declarations_self
        ((_aset,_cset,_monoTable)) =
            performBindingGroup _lhs_monos _declarations_typeSignatures (_mybdggroup : _declarations_bindingGroups)
        (_mybdggroup) =
            (emptyFM,_lhs_assumptions,[_lhs_constraints])
        ((_anns,_notypedefs)) =
            findTypeAnnotations False _lhs_monos _declarations_typeSignatures (_mybdggroup : _declarations_bindingGroups)
        ((_collectTypeConstructors,_collectValueConstructors,_collectTypeSynonyms,_collectConstructorEnv,_derivedFunctions,_operatorFixities)) =
            internalError "PartialSyntax.ag" "n/a" "toplevel MaybeDeclaration"
        (_oneLineTree) =
            Just _declarations_oneLineTree
        ((_namesInScope,_unboundNames,_scopeInfo)) =
            changeOfScope _declarations_declVarNames (_declarations_unboundNames ++ _lhs_unboundNames) _lhs_namesInScope
        ( _declarations_betaUnique,_declarations_bindingGroups,_declarations_collectednotypedef,_declarations_declVarNames,_declarations_localTypes,_declarations_matchIO,_declarations_oneLineTree,_declarations_overloadedVars,_declarations_patternMatchWarnings,_declarations_self,_declarations_typeAnnotations,_declarations_typeSignatures,_declarations_unboundNames) =
            (_declarations (_lhs_allPatterns) (_lhs_betaUnique) ([]) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_monoTable) (_lhs_monos) (_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (emptyFM))
    in  ( _aset
         ,_declarations_betaUnique
         ,_notypedefs ++ _declarations_collectednotypedef
         ,_cset
         ,convertLocal _lhs_substitution _lhs_predicates _notypedefs
          `plusFM` foldFM (\n ts fm -> addToFM fm (NameWithRange n) ts) emptyFM _declarations_typeSignatures
          `plusFM` _declarations_localTypes
         ,_declarations_matchIO
         ,_namesInScope
         ,_oneLineTree
         ,_declarations_overloadedVars
         ,_declarations_patternMatchWarnings
         ,_self
         ,_anns ++ _declarations_typeAnnotations
         ,_unboundNames
         )
sem_MaybeDeclarations_Nothing :: (T_MaybeDeclarations)
sem_MaybeDeclarations_Nothing (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_unboundNames) =
    let (_self) =
            MaybeDeclarations_Nothing
        (_oneLineTree) =
            Nothing
    in  ( _lhs_assumptions,_lhs_betaUnique,_lhs_collectednotypedef,_lhs_constraints,_lhs_localTypes,_lhs_matchIO,_lhs_namesInScope,_oneLineTree,_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,_lhs_unboundNames)
-- MaybeExports ------------------------------------------------
-- semantic domain
type T_MaybeExports = ( (MaybeExports))
-- cata
sem_MaybeExports :: (MaybeExports) ->
                    (T_MaybeExports)
sem_MaybeExports ((MaybeExports_Just (_exports))) =
    (sem_MaybeExports_Just ((sem_Exports (_exports))))
sem_MaybeExports ((MaybeExports_Nothing )) =
    (sem_MaybeExports_Nothing )
sem_MaybeExports_Just :: (T_Exports) ->
                         (T_MaybeExports)
sem_MaybeExports_Just (_exports) =
    let (_self) =
            MaybeExports_Just _exports_self
        ( _exports_self) =
            (_exports )
    in  ( _self)
sem_MaybeExports_Nothing :: (T_MaybeExports)
sem_MaybeExports_Nothing  =
    let (_self) =
            MaybeExports_Nothing
    in  ( _self)
-- MaybeExpression ---------------------------------------------
-- semantic domain
type T_MaybeExpression = ([((Expression, [String]), Core_TypingStrategy)]) ->
                         (Int) ->
                         ([(Name,Tps,Tp,Bool)]) ->
                         (ImportEnvironment) ->
                         (LocalTypes) ->
                         (IO ()) ->
                         (Tps) ->
                         (Names) ->
                         (OverloadedVariables) ->
                         (Names) ->
                         ([Warning]) ->
                         (Predicates) ->
                         (WrappedSubstitution) ->
                         ([(MaybeExpression, [String])]) ->
                         (TypeAnnotations) ->
                         (Int) ->
                         ( (Assumptions),(Tp),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(LocalTypes),(IO ()),([Maybe (MetaVariableTable MetaVariableInfo)]),( Maybe OneLineTree ),(OverloadedVariables),([Warning]),(Bool),(MaybeExpression),(TypeAnnotations),(Names),(Int))
-- cata
sem_MaybeExpression :: (MaybeExpression) ->
                       (T_MaybeExpression)
sem_MaybeExpression ((MaybeExpression_Just (_expression))) =
    (sem_MaybeExpression_Just ((sem_Expression (_expression))))
sem_MaybeExpression ((MaybeExpression_Nothing )) =
    (sem_MaybeExpression_Nothing )
sem_MaybeExpression_Just :: (T_Expression) ->
                            (T_MaybeExpression)
sem_MaybeExpression_Just (_expression) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            MaybeExpression_Just _expression_self
        (_oneLineTree) =
            Just _expression_oneLineTree
        ((_t1,_matches,_,_,_)) =
            match1' match_MaybeExpression_Just _lhs_tryPatterns [] [_expression_matches]
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_localTypes,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,_expression_self,_expression_typeAnnotations,_expression_unboundNames,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_t1) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_localTypes,_expression_matchIO,_matches,_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,False,_self,_expression_typeAnnotations,_expression_unboundNames,_expression_uniqueSecondRound)
sem_MaybeExpression_Nothing :: (T_MaybeExpression)
sem_MaybeExpression_Nothing (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            MaybeExpression_Nothing
        (_beta) =
            TVar _lhs_betaUnique
        (_oneLineTree) =
            Nothing
        (((),_matches,_,_,_)) =
            match0' match_MaybeExpression_Nothing _lhs_tryPatterns [] []
    in  ( noAssumptions,_beta,_lhs_betaUnique + 1,_lhs_collectednotypedef,emptyTree,_lhs_localTypes,_lhs_matchIO,_matches,_oneLineTree,_lhs_overloadedVars,_lhs_patternMatchWarnings,True,_self,_lhs_typeAnnotations,[],_lhs_uniqueSecondRound)
-- MaybeImportSpecification ------------------------------------
-- semantic domain
type T_MaybeImportSpecification = ( (MaybeImportSpecification))
-- cata
sem_MaybeImportSpecification :: (MaybeImportSpecification) ->
                                (T_MaybeImportSpecification)
sem_MaybeImportSpecification ((MaybeImportSpecification_Just (_importspecification))) =
    (sem_MaybeImportSpecification_Just ((sem_ImportSpecification (_importspecification))))
sem_MaybeImportSpecification ((MaybeImportSpecification_Nothing )) =
    (sem_MaybeImportSpecification_Nothing )
sem_MaybeImportSpecification_Just :: (T_ImportSpecification) ->
                                     (T_MaybeImportSpecification)
sem_MaybeImportSpecification_Just (_importspecification) =
    let (_self) =
            MaybeImportSpecification_Just _importspecification_self
        ( _importspecification_self) =
            (_importspecification )
    in  ( _self)
sem_MaybeImportSpecification_Nothing :: (T_MaybeImportSpecification)
sem_MaybeImportSpecification_Nothing  =
    let (_self) =
            MaybeImportSpecification_Nothing
    in  ( _self)
-- MaybeInt ----------------------------------------------------
-- semantic domain
type T_MaybeInt = ( (MaybeInt))
-- cata
sem_MaybeInt :: (MaybeInt) ->
                (T_MaybeInt)
sem_MaybeInt ((MaybeInt_Just (_int))) =
    (sem_MaybeInt_Just (_int))
sem_MaybeInt ((MaybeInt_Nothing )) =
    (sem_MaybeInt_Nothing )
sem_MaybeInt_Just :: (Int) ->
                     (T_MaybeInt)
sem_MaybeInt_Just (_int) =
    let (_self) =
            MaybeInt_Just _int
    in  ( _self)
sem_MaybeInt_Nothing :: (T_MaybeInt)
sem_MaybeInt_Nothing  =
    let (_self) =
            MaybeInt_Nothing
    in  ( _self)
-- MaybeName ---------------------------------------------------
-- semantic domain
type T_MaybeName = ( (MaybeName))
-- cata
sem_MaybeName :: (MaybeName) ->
                 (T_MaybeName)
sem_MaybeName ((MaybeName_Just (_name))) =
    (sem_MaybeName_Just ((sem_Name (_name))))
sem_MaybeName ((MaybeName_Nothing )) =
    (sem_MaybeName_Nothing )
sem_MaybeName_Just :: (T_Name) ->
                      (T_MaybeName)
sem_MaybeName_Just (_name) =
    let (_self) =
            MaybeName_Just _name_self
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( _self)
sem_MaybeName_Nothing :: (T_MaybeName)
sem_MaybeName_Nothing  =
    let (_self) =
            MaybeName_Nothing
    in  ( _self)
-- MaybeNames --------------------------------------------------
-- semantic domain
type T_MaybeNames = ( (MaybeNames))
-- cata
sem_MaybeNames :: (MaybeNames) ->
                  (T_MaybeNames)
sem_MaybeNames ((MaybeNames_Just (_names))) =
    (sem_MaybeNames_Just ((sem_Names (_names))))
sem_MaybeNames ((MaybeNames_Nothing )) =
    (sem_MaybeNames_Nothing )
sem_MaybeNames_Just :: (T_Names) ->
                       (T_MaybeNames)
sem_MaybeNames_Just (_names) =
    let (_self) =
            MaybeNames_Just _names_self
        ( _names_isIdentifier,_names_isOperator,_names_isSpecial,_names_oneLineTree,_names_self) =
            (_names )
    in  ( _self)
sem_MaybeNames_Nothing :: (T_MaybeNames)
sem_MaybeNames_Nothing  =
    let (_self) =
            MaybeNames_Nothing
    in  ( _self)
-- Module ------------------------------------------------------
-- semantic domain
type T_Module = (Flattening) ->
                (ImportEnvironment) ->
                (Bool) ->
                ( (IO ()),(LocalTypes),(OverloadedVariables),(Module),(TypeEnvironment),(TypeErrors),(Warnings))
-- cata
sem_Module :: (Module) ->
              (T_Module)
sem_Module ((Module_Module (_range) (_name) (_exports) (_body))) =
    (sem_Module_Module ((sem_Range (_range))) ((sem_MaybeName (_name))) ((sem_MaybeExports (_exports))) ((sem_Body (_body))))
sem_Module_Module :: (T_Range) ->
                     (T_MaybeName) ->
                     (T_MaybeExports) ->
                     (T_Body) ->
                     (T_Module)
sem_Module_Module (_range) (_name) (_exports) (_body) (_lhs_flattening) (_lhs_importEnvironment) (_lhs_useTypeGraph) =
    let (_self) =
            Module_Module _range_self _name_self _exports_self _body_self
        (_debugIO) =
            do putStrLn "--- Debug Info ---"
               putStrLn $ unlines $ map show _constraints
               putStrLn $ "type variables in constraint set: "++show _body_betaUnique
               putStrLn $ "type variables used while solving: "++show _betaUniqueAtTheEnd
               putStrLn $ "constraints in set: "++show (length _constraints)
               _solveDebug
        (_constraints) =
            zipWith setPosition [0..] (flatten _lhs_flattening _body_constraints)
        (_orderedTypeSynonyms) =
            getOrderedTypeSynonyms _lhs_importEnvironment
        ((_betaUniqueAtTheEnd,_substitution,_predicates,_solveErrors,_solveDebug)) =
            (if _lhs_useTypeGraph
               then solveTypeGraph (_orderedTypeSynonyms , _siblings)
               else solveGreedy _orderedTypeSynonyms)
               _body_betaUnique
               _constraints
        (_siblings) =
            let f s = [ (s, ts) | ts <- findTpScheme (nameFromString s) ]
                findTpScheme n = catMaybes
                                    [ lookupFM (valueConstructors _lhs_importEnvironment) n
                                    , lookupFM (typeEnvironment   _lhs_importEnvironment) n
                                    ]
            in map (concatMap f) (similarFunctionTable ++ [ xs | Siblings xs <- typingStrategies _lhs_importEnvironment ])
        (_monomorphics) =
            ftv (  (eltsFM $ valueConstructors _lhs_importEnvironment)
                ++ (eltsFM $ typeEnvironment _lhs_importEnvironment)
                )
        (_monos) =
            map TVar _monomorphics
        (_checkedSolveErrors) =
            catMaybes (map (checkTypeError _orderedTypeSynonyms . (_substitution |->) . makeTypeError) _solveErrors)
        (_typeErrors) =
            if not (null _checkedSolveErrors)
              then _checkedSolveErrors
              else
                   let f ((m,t),s2,(tree,range)) =
                          let m' = _substitution |-> m
                              t' = _substitution |-> t
                              s1 = generalize (ftv m') _predicates t'
                          in
                             if not (genericInstanceOf _orderedTypeSynonyms standardClasses s2 s1)
                               then [makeNotGeneralEnoughTypeError range tree s1 s2]
                               else []
                   in concatMap f _body_typeAnnotations
        (_warnings) =
            let f (n,ms,t,isToplevel) =
                               let ms'    = _substitution |-> ms
                                   t'     = _substitution |-> t
                                   scheme = generalize (ftv ms') _predicates t'
                               in if null (ftv scheme) && isToplevel
                                    then [NoTypeDef n scheme isToplevel]
                                    else []
            in concatMap f _body_collectednotypedef
        (_initialScope) =
            keysFM (typeEnvironment _lhs_importEnvironment)
        ((_namesInScope,_unboundNames,_scopeInfo)) =
            changeOfScope (_initialScope ++ _body_declVarNames) _body_unboundNames []
        ( _range_self) =
            (_range )
        ( _name_self) =
            (_name )
        ( _exports_self) =
            (_exports )
        ( _body_assumptions,_body_betaUnique,_body_collectednotypedef,_body_constraints,_body_declVarNames,_body_localTypes,_body_matchIO,_body_namesWithoutTypeDef,_body_overloadedVars,_body_patternMatchWarnings,_body_self,_body_toplevelTypes,_body_typeAnnotations,_body_unboundNames) =
            (_body ([ (matchInfo, typingStrategy)
                    | typingStrategy <- typingStrategies _lhs_importEnvironment
                    , matchInfo      <- matchInformation
                                         _lhs_importEnvironment
                                         typingStrategy
                    ])
                   (maximum (0 : _monomorphics) + 1)
                   ([])
                   (_lhs_importEnvironment)
                   (emptyFM)
                   (return ())
                   (_monos)
                   (_namesInScope)
                   (emptyFM)
                   ([ n
                    | (n, ts) <- fmToList _body_toplevelTypes ++ fmToList (typeEnvironment _lhs_importEnvironment)
                    ,  isOverloaded ts
                    ] ++
                    [ nameWithRangeToName n
                    | (n, ts) <- fmToList _body_localTypes
                    , isOverloaded ts
                    ])
                   ([])
                   (_predicates)
                   (_substitution)
                   ([]))
    in  ( _debugIO >> putStrLn "Inference Strategies:" >> _body_matchIO,_body_localTypes,_body_overloadedVars,_self,_body_toplevelTypes,_typeErrors,_warnings     ++ _body_patternMatchWarnings)
-- Name --------------------------------------------------------
-- semantic domain
type T_Name = ( (Bool),(Bool),(Bool),(OneLineTree),(Name))
-- cata
sem_Name :: (Name) ->
            (T_Name)
sem_Name ((Name_Identifier (_range) (_module) (_name))) =
    (sem_Name_Identifier ((sem_Range (_range))) ((sem_Strings (_module))) (_name))
sem_Name ((Name_Operator (_range) (_module) (_name))) =
    (sem_Name_Operator ((sem_Range (_range))) ((sem_Strings (_module))) (_name))
sem_Name ((Name_Special (_range) (_module) (_name))) =
    (sem_Name_Special ((sem_Range (_range))) ((sem_Strings (_module))) (_name))
sem_Name_Identifier :: (T_Range) ->
                       (T_Strings) ->
                       (String) ->
                       (T_Name)
sem_Name_Identifier (_range) (_module) (_name) =
    let (_self) =
            Name_Identifier _range_self _module_self _name
        (_oneLineTree) =
            OneLineText _name
        ( _range_self) =
            (_range )
        ( _module_oneLineTree,_module_self) =
            (_module )
    in  ( True,False,False,_oneLineTree,_self)
sem_Name_Operator :: (T_Range) ->
                     (T_Strings) ->
                     (String) ->
                     (T_Name)
sem_Name_Operator (_range) (_module) (_name) =
    let (_self) =
            Name_Operator _range_self _module_self _name
        (_oneLineTree) =
            OneLineText _name
        ( _range_self) =
            (_range )
        ( _module_oneLineTree,_module_self) =
            (_module )
    in  ( False,True,False,_oneLineTree,_self)
sem_Name_Special :: (T_Range) ->
                    (T_Strings) ->
                    (String) ->
                    (T_Name)
sem_Name_Special (_range) (_module) (_name) =
    let (_self) =
            Name_Special _range_self _module_self _name
        (_oneLineTree) =
            OneLineText _name
        ( _range_self) =
            (_range )
        ( _module_oneLineTree,_module_self) =
            (_module )
    in  ( False,False,True,_oneLineTree,_self)
-- Names -------------------------------------------------------
-- semantic domain
type T_Names = ( ( [Bool] ),( [Bool] ),( [Bool] ),( [ OneLineTree] ),(Names))
-- cata
sem_Names :: (Names) ->
             (T_Names)
sem_Names (list) =
    (foldr (sem_Names_Cons) (sem_Names_Nil) ((map sem_Name list)))
sem_Names_Cons :: (T_Name) ->
                  (T_Names) ->
                  (T_Names)
sem_Names_Cons (_hd) (_tl) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_isIdentifier,_hd_isOperator,_hd_isSpecial,_hd_oneLineTree,_hd_self) =
            (_hd )
        ( _tl_isIdentifier,_tl_isOperator,_tl_isSpecial,_tl_oneLineTree,_tl_self) =
            (_tl )
    in  ( _hd_isIdentifier  :  _tl_isIdentifier,_hd_isOperator  :  _tl_isOperator,_hd_isSpecial  :  _tl_isSpecial,_hd_oneLineTree  :  _tl_oneLineTree,_self)
sem_Names_Nil :: (T_Names)
sem_Names_Nil  =
    let (_self) =
            []
    in  ( [],[],[],[],_self)
-- Pattern -----------------------------------------------------
-- semantic domain
type T_Pattern = (Int) ->
                 (ImportEnvironment) ->
                 (Names) ->
                 ([Warning]) ->
                 (WrappedSubstitution) ->
                 ( (Tp),(Int),(ConstraintSet),(  [PatternElement]        ),(PatternAssumptions),(OneLineTree),(Names),([Warning]),(Pattern),(Names))
-- cata
sem_Pattern :: (Pattern) ->
               (T_Pattern)
sem_Pattern ((Pattern_As (_range) (_name) (_pattern))) =
    (sem_Pattern_As ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Pattern (_pattern))))
sem_Pattern ((Pattern_Constructor (_range) (_name) (_patterns))) =
    (sem_Pattern_Constructor ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Patterns (_patterns))))
sem_Pattern ((Pattern_InfixConstructor (_range) (_leftPattern) (_constructorOperator) (_rightPattern))) =
    (sem_Pattern_InfixConstructor ((sem_Range (_range))) ((sem_Pattern (_leftPattern))) ((sem_Name (_constructorOperator))) ((sem_Pattern (_rightPattern))))
sem_Pattern ((Pattern_Irrefutable (_range) (_pattern))) =
    (sem_Pattern_Irrefutable ((sem_Range (_range))) ((sem_Pattern (_pattern))))
sem_Pattern ((Pattern_List (_range) (_patterns))) =
    (sem_Pattern_List ((sem_Range (_range))) ((sem_Patterns (_patterns))))
sem_Pattern ((Pattern_Literal (_range) (_literal))) =
    (sem_Pattern_Literal ((sem_Range (_range))) ((sem_Literal (_literal))))
sem_Pattern ((Pattern_Negate (_range) (_literal))) =
    (sem_Pattern_Negate ((sem_Range (_range))) ((sem_Literal (_literal))))
sem_Pattern ((Pattern_NegateFloat (_range) (_literal))) =
    (sem_Pattern_NegateFloat ((sem_Range (_range))) ((sem_Literal (_literal))))
sem_Pattern ((Pattern_Parenthesized (_range) (_pattern))) =
    (sem_Pattern_Parenthesized ((sem_Range (_range))) ((sem_Pattern (_pattern))))
sem_Pattern ((Pattern_Record (_range) (_name) (_recordPatternBindings))) =
    (sem_Pattern_Record ((sem_Range (_range))) ((sem_Name (_name))) ((sem_RecordPatternBindings (_recordPatternBindings))))
sem_Pattern ((Pattern_Successor (_range) (_name) (_literal))) =
    (sem_Pattern_Successor ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Literal (_literal))))
sem_Pattern ((Pattern_Tuple (_range) (_patterns))) =
    (sem_Pattern_Tuple ((sem_Range (_range))) ((sem_Patterns (_patterns))))
sem_Pattern ((Pattern_Variable (_range) (_name))) =
    (sem_Pattern_Variable ((sem_Range (_range))) ((sem_Name (_name))))
sem_Pattern ((Pattern_Wildcard (_range))) =
    (sem_Pattern_Wildcard ((sem_Range (_range))))
sem_Pattern_As :: (T_Range) ->
                  (T_Name) ->
                  (T_Pattern) ->
                  (T_Pattern)
sem_Pattern_As (_range) (_name) (_pattern) (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            Pattern_As _range_self _name_self _pattern_self
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            [ (_beta .==. _pattern_beta) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTPattern, AltAs, 0, "")
                  , location   = "as pattern"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm (OneLineText (show _name_self)) ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getNameRange _name_self) ]
                  }
        (_oneLineTree) =
            OneLineNode
                [ OneLineNode [_name_oneLineTree]
                , OneLineText "@"
                , OneLineNode [_pattern_oneLineTree]
                ]
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _pattern_beta,_pattern_betaUnique,_pattern_constraints,_pattern_elements,_pattern_environment,_pattern_oneLineTree,_pattern_patVarNames,_pattern_patternMatchWarnings,_pattern_self,_pattern_unboundNames) =
            (_pattern (_lhs_betaUnique + 1) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution))
    in  ( _beta
         ,_pattern_betaUnique
         ,_newcon .>.
          Node [ Receive _lhs_betaUnique
               , _pattern_constraints
               ]
         ,_pattern_elements
         ,addToFM _pattern_environment _name_self _beta
         ,_oneLineTree
         ,_name_self : _pattern_patVarNames
         ,_pattern_patternMatchWarnings
         ,_self
         ,_pattern_unboundNames
         )
sem_Pattern_Constructor :: (T_Range) ->
                           (T_Name) ->
                           (T_Patterns) ->
                           (T_Pattern)
sem_Pattern_Constructor (_range) (_name) (_patterns) (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            Pattern_Constructor _range_self _name_self _patterns_self
        (_beta) =
            TVar (_lhs_betaUnique)
        (_betaCon) =
            TVar (_lhs_betaUnique + 1)
        (_conApply) =
            [ (_betaCon .==. foldr (.->.) _beta _patterns_betas) _cinfoApply ]
        (_conConstructor) =
            case lookupFM (valueConstructors _lhs_importEnvironment) _name_self of
               Nothing  -> []
               Just ctp -> [ (_betaCon .::. ctp) _cinfoConstructor ]
        (_cinfoConstructor) =
            \tppair ->
            CInfo { info       = (NTPattern, AltConstructor, 0, "")
                  , location   = "pattern constructor"
                  , errorrange = getNameRange _name_self
                  , sources    = [ sourcePattern _oneLineTree ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , HighlyTrusted
                                 ]
                  }
        (_cinfoApply) =
            \tppair ->
            CInfo { info       = (NTPattern, AltConstructor, 1, "apply")
                  , location   = if _patterns_numberOfPatterns == 0
                                   then "pattern constructor"
                                   else "pattern application"
                  , errorrange = _range_self
                  , sources    = if _patterns_numberOfPatterns == 0
                                   then [ sourcePattern _oneLineTree                            ]
                                   else [ sourcePattern _oneLineTree, sourceConstructor _name_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getNameRange _name_self) ] ++
                                 if _patterns_numberOfPatterns == 0
                                   then [HighlyTrusted]
                                   else [ ApplicationEdge False (zip3 _patterns_oneLineTree
                                                                      _patterns_betas
                                                                      (map getPatRange (_patterns_self))
                                                                )]
                  }
        (_operatorName) =
            if _name_isOperator
              then OneLineNode [OneLineText "(", _name_oneLineTree, OneLineText ")"]
              else _name_oneLineTree
        (_oneLineTree) =
            OneLineNode (sepBy (OneLineText " ") (_operatorName : _patterns_oneLineTree))
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _patterns_betaUnique,_patterns_betas,_patterns_constraintslist,_patterns_elementss,_patterns_environment,_patterns_numberOfPatterns,_patterns_oneLineTree,_patterns_patVarNames,_patterns_patternMatchWarnings,_patterns_self,_patterns_unboundNames) =
            (_patterns (_lhs_betaUnique + 2) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution))
    in  ( _beta
         ,_patterns_betaUnique
         ,_conApply .>.
          Node [ listTree _conConstructor
               , Node _patterns_constraintslist
               ]
         ,FiniteElement (getNameName _name_self) : concat _patterns_elementss
         ,_patterns_environment
         ,_oneLineTree
         ,_patterns_patVarNames
         ,_patterns_patternMatchWarnings
         ,_self
         ,_patterns_unboundNames
         )
sem_Pattern_InfixConstructor :: (T_Range) ->
                                (T_Pattern) ->
                                (T_Name) ->
                                (T_Pattern) ->
                                (T_Pattern)
sem_Pattern_InfixConstructor (_range) (_leftPattern) (_constructorOperator) (_rightPattern) (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            Pattern_InfixConstructor _range_self _leftPattern_self _constructorOperator_self _rightPattern_self
        (_beta) =
            TVar _lhs_betaUnique
        (_betaCon) =
            TVar (_lhs_betaUnique + 1)
        (_conApply) =
            [ (_betaCon .==. _leftPattern_beta .->. _rightPattern_beta .->. _beta) _cinfoApply ]
        (_conConstructor) =
            case lookupFM (valueConstructors _lhs_importEnvironment) _constructorOperator_self  of
               Nothing  -> []
               Just ctp -> [ (_betaCon .::. ctp) _cinfoConstructor ]
        (_cinfoConstructor) =
            \tppair ->
            CInfo { info       = (NTPattern, AltInfixConstructor, 0, "")
                  , location   = "pattern constructor"
                  , errorrange = getNameRange _constructorOperator_self
                  , sources    = [ sourceOperator _constructorOperator_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , HighlyTrusted
                                 , SubTermRange (getNameRange _constructorOperator_self)
                                 ]
                  }
        (_cinfoApply) =
            \tppair ->
            CInfo { info       = (NTPattern, AltInfixConstructor, 1, "apply")
                  , location   = "infix pattern application"
                  , errorrange = _range_self
                  , sources    = [ sourcePattern _oneLineTree, sourceConstructor (OneLineText (showNameAsOperator _constructorOperator_self))]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getNameRange _constructorOperator_self)
                                 , ApplicationEdge True
                                                   [ (_leftPattern_oneLineTree ,_leftPattern_beta ,getPatRange (_leftPattern_self))
                                                   , (_rightPattern_oneLineTree,_rightPattern_beta,getPatRange (_rightPattern_self))
                                                   ]
                                 ]
                  }
        (_operatorName) =
            OneLineText (showNameAsOperator _constructorOperator_self)
        (_oneLineTree) =
            OneLineNode
                [ OneLineNode [_leftPattern_oneLineTree]
                , OneLineText " "
                , OneLineNode [_operatorName]
                , OneLineText " "
                , OneLineNode [_rightPattern_oneLineTree]
                ]
        ( _range_self) =
            (_range )
        ( _leftPattern_beta,_leftPattern_betaUnique,_leftPattern_constraints,_leftPattern_elements,_leftPattern_environment,_leftPattern_oneLineTree,_leftPattern_patVarNames,_leftPattern_patternMatchWarnings,_leftPattern_self,_leftPattern_unboundNames) =
            (_leftPattern (_lhs_betaUnique + 2) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution))
        ( _constructorOperator_isIdentifier,_constructorOperator_isOperator,_constructorOperator_isSpecial,_constructorOperator_oneLineTree,_constructorOperator_self) =
            (_constructorOperator )
        ( _rightPattern_beta,_rightPattern_betaUnique,_rightPattern_constraints,_rightPattern_elements,_rightPattern_environment,_rightPattern_oneLineTree,_rightPattern_patVarNames,_rightPattern_patternMatchWarnings,_rightPattern_self,_rightPattern_unboundNames) =
            (_rightPattern (_leftPattern_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_leftPattern_patternMatchWarnings) (_lhs_substitution))
    in  ( _beta
         ,_rightPattern_betaUnique
         ,_conApply .>.
          Node [ listTree _conConstructor
               , _leftPattern_constraints
               , _rightPattern_constraints
               ]
         ,FiniteElement (getNameName _constructorOperator_self) : _leftPattern_elements ++ _rightPattern_elements
         ,_leftPattern_environment `plusFM` _rightPattern_environment
         ,_oneLineTree
         ,_leftPattern_patVarNames ++ _rightPattern_patVarNames
         ,_rightPattern_patternMatchWarnings
         ,_self
         ,_leftPattern_unboundNames ++ _rightPattern_unboundNames
         )
sem_Pattern_Irrefutable :: (T_Range) ->
                           (T_Pattern) ->
                           (T_Pattern)
sem_Pattern_Irrefutable (_range) (_pattern) (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            Pattern_Irrefutable _range_self _pattern_self
        (_oneLineTree) =
            intErr "pattern" "irrefutable"
        ( _range_self) =
            (_range )
        ( _pattern_beta,_pattern_betaUnique,_pattern_constraints,_pattern_elements,_pattern_environment,_pattern_oneLineTree,_pattern_patVarNames,_pattern_patternMatchWarnings,_pattern_self,_pattern_unboundNames) =
            (_pattern (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution))
    in  ( _pattern_beta,_pattern_betaUnique,_pattern_constraints,_pattern_elements,_pattern_environment,_oneLineTree,_pattern_patVarNames,_pattern_patternMatchWarnings,_self,_pattern_unboundNames)
sem_Pattern_List :: (T_Range) ->
                    (T_Patterns) ->
                    (T_Pattern)
sem_Pattern_List (_range) (_patterns) (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            Pattern_List _range_self _patterns_self
        (_beta) =
            TVar _lhs_betaUnique
        (_beta') =
            TVar (_lhs_betaUnique + 1)
        (_newcon) =
            [ (listType _beta' .==. _beta) _cinfoResult ]
        (_childrenInfo) =
            zip _patterns_oneLineTree (map getPatRange _patterns_self)
        (_zipf) =
            \tp pair ctree -> [ (tp .==. _beta') (_cinfoElem pair) ] .<. ctree
        (_cinfoElem) =
            \(elemtext, elemrange) tppair ->
            CInfo { info       = (NTPattern, AltList, 0, "element")
                  , location   = "element of pattern list"
                  , errorrange = _range_self
                  , sources    = [ sourcePattern _oneLineTree, sourceTerm elemtext ]
                  , typepair   = tppair
                  , properties = [ SubTermRange elemrange ] ++
                                 if length _patterns_constraintslist > 1 then [] else [ HighlyTrusted  ]
                  }
        (_cinfoResult) =
            \tppair ->
            CInfo { info       = (NTPattern, AltList, 1, "result")
                  , location   = "pattern list"
                  , errorrange = _range_self
                  , sources    = [ sourcePattern _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint ]
                  }
        (_oneLineTree) =
            encloseSep "[" ", " "]" _patterns_oneLineTree
        ( _range_self) =
            (_range )
        ( _patterns_betaUnique,_patterns_betas,_patterns_constraintslist,_patterns_elementss,_patterns_environment,_patterns_numberOfPatterns,_patterns_oneLineTree,_patterns_patVarNames,_patterns_patternMatchWarnings,_patterns_self,_patterns_unboundNames) =
            (_patterns (_lhs_betaUnique + 2) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution))
    in  ( _beta
         ,_patterns_betaUnique
         ,_newcon .>.
          Node (zipWith3 _zipf _patterns_betas _childrenInfo _patterns_constraintslist)
         ,listPat _patterns_elementss
         ,_patterns_environment
         ,_oneLineTree
         ,_patterns_patVarNames
         ,_patterns_patternMatchWarnings
         ,_self
         ,_patterns_unboundNames
         )
sem_Pattern_Literal :: (T_Range) ->
                       (T_Literal) ->
                       (T_Pattern)
sem_Pattern_Literal (_range) (_literal) (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            Pattern_Literal _range_self _literal_self
        (_beta) =
            TVar _lhs_betaUnique
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTPattern, AltLiteral, 0, "")
                  , location   = "literal pattern"
                  , errorrange = _range_self
                  , sources    = [ sourcePattern _oneLineTree ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , HighlyTrusted
                                 , IsLiteral _literal_self
                                 ]
                  }
        (_oneLineTree) =
            _literal_oneLineTree
        ( _range_self) =
            (_range )
        ( _literal_elements,_literal_literalType,_literal_oneLineTree,_literal_self) =
            (_literal )
    in  ( _beta,_lhs_betaUnique + 1,unitTree ((_literal_literalType .==. _beta) _cinfo),_literal_elements,noAssumptions,_oneLineTree,[],_lhs_patternMatchWarnings,_self,[])
sem_Pattern_Negate :: (T_Range) ->
                      (T_Literal) ->
                      (T_Pattern)
sem_Pattern_Negate (_range) (_literal) (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            Pattern_Negate _range_self _literal_self
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            [ (intType .==. _beta) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTPattern, AltNegate, 0, "")
                  , location   = "pattern negation"
                  , errorrange = _range_self
                  , sources    = [ sourcePattern _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint ]
                  }
        (_oneLineTree) =
            OneLineNode [ OneLineText "-", _literal_oneLineTree ]
        ( _range_self) =
            (_range )
        ( _literal_elements,_literal_literalType,_literal_oneLineTree,_literal_self) =
            (_literal )
    in  ( _beta,_lhs_betaUnique + 1,listTree _newcon,_literal_elements,noAssumptions,_oneLineTree,[],_lhs_patternMatchWarnings,_self,[])
sem_Pattern_NegateFloat :: (T_Range) ->
                           (T_Literal) ->
                           (T_Pattern)
sem_Pattern_NegateFloat (_range) (_literal) (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            Pattern_NegateFloat _range_self _literal_self
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            [ (floatType .==. _beta) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTPattern, AltNegateFloat, 0, "")
                  , location   = "pattern negation"
                  , errorrange = _range_self
                  , sources    = [ sourcePattern _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , NegationResult
                                 ]
                  }
        (_oneLineTree) =
            OneLineNode [ OneLineText "-." , _literal_oneLineTree ]
        ( _range_self) =
            (_range )
        ( _literal_elements,_literal_literalType,_literal_oneLineTree,_literal_self) =
            (_literal )
    in  ( _beta,_lhs_betaUnique + 1,listTree _newcon,_literal_elements,noAssumptions,_oneLineTree,[],_lhs_patternMatchWarnings,_self,[])
sem_Pattern_Parenthesized :: (T_Range) ->
                             (T_Pattern) ->
                             (T_Pattern)
sem_Pattern_Parenthesized (_range) (_pattern) (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            Pattern_Parenthesized _range_self _pattern_self
        (_oneLineTree) =
            parens _pattern_oneLineTree
        ( _range_self) =
            (_range )
        ( _pattern_beta,_pattern_betaUnique,_pattern_constraints,_pattern_elements,_pattern_environment,_pattern_oneLineTree,_pattern_patVarNames,_pattern_patternMatchWarnings,_pattern_self,_pattern_unboundNames) =
            (_pattern (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution))
    in  ( _pattern_beta,_pattern_betaUnique,_pattern_constraints,_pattern_elements,_pattern_environment,_oneLineTree,_pattern_patVarNames,_pattern_patternMatchWarnings,_self,_pattern_unboundNames)
sem_Pattern_Record :: (T_Range) ->
                      (T_Name) ->
                      (T_RecordPatternBindings) ->
                      (T_Pattern)
sem_Pattern_Record (_range) (_name) (_recordPatternBindings) (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            Pattern_Record _range_self _name_self _recordPatternBindings_self
        ((_beta,_constraints,_environment)) =
            internalError "PartialSyntax.ag" "n/a" "Pattern.Record"
        (_oneLineTree) =
            intErr "pattern" "record"
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _recordPatternBindings_patternMatchWarnings,_recordPatternBindings_self,_recordPatternBindings_unboundNames) =
            (_recordPatternBindings (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution))
    in  ( _beta,_lhs_betaUnique,_constraints,pmError "Pattern_Record.elements" "Records are not supported",_environment,_oneLineTree,[],_recordPatternBindings_patternMatchWarnings,_self,_recordPatternBindings_unboundNames)
sem_Pattern_Successor :: (T_Range) ->
                         (T_Name) ->
                         (T_Literal) ->
                         (T_Pattern)
sem_Pattern_Successor (_range) (_name) (_literal) (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            Pattern_Successor _range_self _name_self _literal_self
        ((_beta,_constraints,_environment)) =
            internalError "PartialSyntax.ag" "n/a" "Pattern.Successor"
        (_oneLineTree) =
            intErr "pattern" "successor"
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _literal_elements,_literal_literalType,_literal_oneLineTree,_literal_self) =
            (_literal )
    in  ( _beta,_lhs_betaUnique,_constraints,pmError "Pattern_Successor.elements" "Successors are not supported",_environment,_oneLineTree,[],_lhs_patternMatchWarnings,_self,[])
sem_Pattern_Tuple :: (T_Range) ->
                     (T_Patterns) ->
                     (T_Pattern)
sem_Pattern_Tuple (_range) (_patterns) (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            Pattern_Tuple _range_self _patterns_self
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            [ (tupleType _patterns_betas .==. _beta) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTPattern, AltTuple, 0, "result")
                  , location   = "pattern tuple"
                  , errorrange = _range_self
                  , sources    = [ sourcePattern _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , IsTupleEdge
                                 ]
                  }
        (_oneLineTree) =
            encloseSep "(" ", " ")" _patterns_oneLineTree
        ( _range_self) =
            (_range )
        ( _patterns_betaUnique,_patterns_betas,_patterns_constraintslist,_patterns_elementss,_patterns_environment,_patterns_numberOfPatterns,_patterns_oneLineTree,_patterns_patVarNames,_patterns_patternMatchWarnings,_patterns_self,_patterns_unboundNames) =
            (_patterns (_lhs_betaUnique + 1) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution))
    in  ( _beta,_patterns_betaUnique,_newcon .>. Node _patterns_constraintslist,FiniteElement ("(" ++ replicate (length $ tail _patterns_self) ',' ++ ")") : concat _patterns_elementss,_patterns_environment,_oneLineTree,_patterns_patVarNames,_patterns_patternMatchWarnings,_self,_patterns_unboundNames)
sem_Pattern_Variable :: (T_Range) ->
                        (T_Name) ->
                        (T_Pattern)
sem_Pattern_Variable (_range) (_name) (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            Pattern_Variable _range_self _name_self
        (_beta) =
            TVar _lhs_betaUnique
        (_oneLineTree) =
            _name_oneLineTree
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( _beta,_lhs_betaUnique + 1,Receive _lhs_betaUnique,[WildcardElement],unitFM _name_self _beta,_oneLineTree,[ _name_self ],_lhs_patternMatchWarnings,_self,[])
sem_Pattern_Wildcard :: (T_Range) ->
                        (T_Pattern)
sem_Pattern_Wildcard (_range) (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            Pattern_Wildcard _range_self
        (_beta) =
            TVar _lhs_betaUnique
        (_oneLineTree) =
            OneLineText "_"
        ( _range_self) =
            (_range )
    in  ( _beta,_lhs_betaUnique + 1,emptyTree,[WildcardElement],noAssumptions,_oneLineTree,[],_lhs_patternMatchWarnings,_self,[])
-- Patterns ----------------------------------------------------
-- semantic domain
type T_Patterns = (Int) ->
                  (ImportEnvironment) ->
                  (Names) ->
                  ([Warning]) ->
                  (WrappedSubstitution) ->
                  ( (Int),(Tps),(ConstraintSets),([ [PatternElement]       ]),(PatternAssumptions),(Int),( [ OneLineTree] ),(Names),([Warning]),(Patterns),(Names))
-- cata
sem_Patterns :: (Patterns) ->
                (T_Patterns)
sem_Patterns (list) =
    (foldr (sem_Patterns_Cons) (sem_Patterns_Nil) ((map sem_Pattern list)))
sem_Patterns_Cons :: (T_Pattern) ->
                     (T_Patterns) ->
                     (T_Patterns)
sem_Patterns_Cons (_hd) (_tl) (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_beta,_hd_betaUnique,_hd_constraints,_hd_elements,_hd_environment,_hd_oneLineTree,_hd_patVarNames,_hd_patternMatchWarnings,_hd_self,_hd_unboundNames) =
            (_hd (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution))
        ( _tl_betaUnique,_tl_betas,_tl_constraintslist,_tl_elementss,_tl_environment,_tl_numberOfPatterns,_tl_oneLineTree,_tl_patVarNames,_tl_patternMatchWarnings,_tl_self,_tl_unboundNames) =
            (_tl (_hd_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_hd_patternMatchWarnings) (_lhs_substitution))
    in  ( _tl_betaUnique,_hd_beta : _tl_betas,_hd_constraints : _tl_constraintslist,_hd_elements : _tl_elementss,_hd_environment `plusFM` _tl_environment,1 + _tl_numberOfPatterns,_hd_oneLineTree  :  _tl_oneLineTree,_hd_patVarNames ++ _tl_patVarNames,_tl_patternMatchWarnings,_self,_hd_unboundNames ++ _tl_unboundNames)
sem_Patterns_Nil :: (T_Patterns)
sem_Patterns_Nil (_lhs_betaUnique) (_lhs_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            []
    in  ( _lhs_betaUnique,[],[],[],noAssumptions,0,[],[],_lhs_patternMatchWarnings,_self,[])
-- Position ----------------------------------------------------
-- semantic domain
type T_Position = ( (Position))
-- cata
sem_Position :: (Position) ->
                (T_Position)
sem_Position ((Position_Position (_filename) (_line) (_column))) =
    (sem_Position_Position (_filename) (_line) (_column))
sem_Position ((Position_Unknown )) =
    (sem_Position_Unknown )
sem_Position_Position :: (String) ->
                         (Int) ->
                         (Int) ->
                         (T_Position)
sem_Position_Position (_filename) (_line) (_column) =
    let (_self) =
            Position_Position _filename _line _column
    in  ( _self)
sem_Position_Unknown :: (T_Position)
sem_Position_Unknown  =
    let (_self) =
            Position_Unknown
    in  ( _self)
-- Qualifier ---------------------------------------------------
-- semantic domain
type T_Qualifier = ([((Expression, [String]), Core_TypingStrategy)]) ->
                   (Assumptions) ->
                   (Int) ->
                   ([(Name,Tps,Tp,Bool)]) ->
                   (ConstraintSet) ->
                   (ImportEnvironment) ->
                   (LocalTypes) ->
                   (IO ()) ->
                   (Tps) ->
                   (Names) ->
                   (OverloadedVariables) ->
                   (Names) ->
                   ([Warning]) ->
                   (Predicates) ->
                   (WrappedSubstitution) ->
                   (TypeAnnotations) ->
                   (Names) ->
                   (Int) ->
                   ( (Assumptions),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(LocalTypes),(IO ()),(Tps),(Names),(OneLineTree),(OverloadedVariables),([Warning]),(Qualifier),(TypeAnnotations),(Names),(Int))
-- cata
sem_Qualifier :: (Qualifier) ->
                 (T_Qualifier)
sem_Qualifier ((Qualifier_Empty (_range))) =
    (sem_Qualifier_Empty ((sem_Range (_range))))
sem_Qualifier ((Qualifier_Generator (_range) (_pattern) (_expression))) =
    (sem_Qualifier_Generator ((sem_Range (_range))) ((sem_Pattern (_pattern))) ((sem_Expression (_expression))))
sem_Qualifier ((Qualifier_Guard (_range) (_guard))) =
    (sem_Qualifier_Guard ((sem_Range (_range))) ((sem_Expression (_guard))))
sem_Qualifier ((Qualifier_Let (_range) (_declarations))) =
    (sem_Qualifier_Let ((sem_Range (_range))) ((sem_Declarations (_declarations))))
sem_Qualifier_Empty :: (T_Range) ->
                       (T_Qualifier)
sem_Qualifier_Empty (_range) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_unboundNames) (_lhs_uniqueSecondRound) =
    let (_self) =
            Qualifier_Empty _range_self
        (_oneLineTree) =
            OneLineText ""
        ( _range_self) =
            (_range )
    in  ( _lhs_assumptions,_lhs_betaUnique,_lhs_collectednotypedef,_lhs_constraints,_lhs_localTypes,_lhs_matchIO,_lhs_monos,_lhs_namesInScope,_oneLineTree,_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,_lhs_unboundNames,_lhs_uniqueSecondRound)
sem_Qualifier_Generator :: (T_Range) ->
                           (T_Pattern) ->
                           (T_Expression) ->
                           (T_Qualifier)
sem_Qualifier_Generator (_range) (_pattern) (_expression) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_unboundNames) (_lhs_uniqueSecondRound) =
    let (_self) =
            Qualifier_Generator _range_self _pattern_self _expression_self
        ((_csetBinds,_assumptions')) =
            (_pattern_environment .===. _lhs_assumptions) _cinfoBind
        (_newcon) =
            [ (_expression_beta .==. listType _pattern_beta) _cinfoResult ]
        (_cinfoResult) =
            \tppair ->
            CInfo { info       = (NTQualifier,AltGenerator,0, "result")
                  , location   = "generator"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm _expression_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getExprRange _expression_self) ]
                  }
        (_cinfoBind) =
            variableBindingCInfo (NTQualifier,AltGenerator,1 )
        (_oneLineTree) =
            OneLineNode [ _pattern_oneLineTree, OneLineText " <- ", _expression_oneLineTree ]
        ((_namesInScope,_unboundNames,_scopeInfo)) =
            changeOfScope _pattern_patVarNames (_expression_unboundNames  ++ _lhs_unboundNames)  _lhs_namesInScope
        ( _range_self) =
            (_range )
        ( _pattern_beta,_pattern_betaUnique,_pattern_constraints,_pattern_elements,_pattern_environment,_pattern_oneLineTree,_pattern_patVarNames,_pattern_patternMatchWarnings,_pattern_self,_pattern_unboundNames) =
            (_pattern (_lhs_betaUnique) (_lhs_importEnvironment) (_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution))
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_localTypes,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,_expression_self,_expression_typeAnnotations,_expression_unboundNames,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_pattern_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_pattern_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) ([]) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _assumptions' `combine` _expression_assumptions
         ,_expression_betaUnique
         ,_expression_collectednotypedef
         ,_newcon .>. _csetBinds .>>.
          Node [ _pattern_constraints
               , _expression_constraints
               , _lhs_constraints
               ]
         ,_expression_localTypes
         ,_expression_matchIO
         ,eltsFM _pattern_environment ++ getMonos _csetBinds ++ _lhs_monos
         ,_namesInScope
         ,_oneLineTree
         ,_expression_overloadedVars
         ,patternMatchWarnings _lhs_importEnvironment
                               _lhs_substitution
                               _pattern_beta
                               (:[])
                               [(_pattern_elements, False)]
                               _range
                               Nothing
                               False
                               []
                               "generator"
                               "<-"
          ++ _expression_patternMatchWarnings
         ,_self
         ,_expression_typeAnnotations
         ,_unboundNames
         ,_expression_uniqueSecondRound
         )
sem_Qualifier_Guard :: (T_Range) ->
                       (T_Expression) ->
                       (T_Qualifier)
sem_Qualifier_Guard (_range) (_guard) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_unboundNames) (_lhs_uniqueSecondRound) =
    let (_self) =
            Qualifier_Guard _range_self _guard_self
        (_newcon) =
            [ (_guard_beta .==. boolType) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTQualifier,AltGuard,0, "")
                  , location   = "boolean qualifier"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ ]
                  }
        (_oneLineTree) =
            _guard_oneLineTree
        ( _range_self) =
            (_range )
        ( _guard_assumptions,_guard_beta,_guard_betaUnique,_guard_collectednotypedef,_guard_constraints,_guard_localTypes,_guard_matchIO,_guard_matches,_guard_oneLineTree,_guard_overloadedVars,_guard_patternMatchWarnings,_guard_self,_guard_typeAnnotations,_guard_unboundNames,_guard_uniqueSecondRound) =
            (_guard (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) ([]) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _lhs_assumptions `combine` _guard_assumptions
         ,_guard_betaUnique
         ,_guard_collectednotypedef
         ,Node [ _newcon .<. _guard_constraints
               , _lhs_constraints
               ]
         ,_guard_localTypes
         ,_guard_matchIO
         ,_lhs_monos
         ,_lhs_namesInScope
         ,_oneLineTree
         ,_guard_overloadedVars
         ,_guard_patternMatchWarnings
         ,_self
         ,_guard_typeAnnotations
         ,_guard_unboundNames ++ _lhs_unboundNames
         ,_guard_uniqueSecondRound
         )
sem_Qualifier_Let :: (T_Range) ->
                     (T_Declarations) ->
                     (T_Qualifier)
sem_Qualifier_Let (_range) (_declarations) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_unboundNames) (_lhs_uniqueSecondRound) =
    let (_self) =
            Qualifier_Let _range_self _declarations_self
        ((_aset,_cset,_monoTable)) =
            performBindingGroup _lhs_monos _declarations_typeSignatures (_mybdggroup : _declarations_bindingGroups)
        (_mybdggroup) =
            (noAssumptions,_lhs_assumptions,[_lhs_constraints])
        ((_anns,_notypedefs)) =
            findTypeAnnotations False _lhs_monos _declarations_typeSignatures (_mybdggroup : _declarations_bindingGroups)
        ((_collectTypeConstructors,_collectValueConstructors,_collectTypeSynonyms,_collectConstructorEnv,_derivedFunctions,_operatorFixities)) =
            internalError "PartialSyntax.ag" "n/a" "toplevel Qualifier"
        (_oneLineTree) =
            OneLineNode [ OneLineText "let ", encloseSep "{" "; " "}" _declarations_oneLineTree ]
        ((_namesInScope,_unboundNames,_scopeInfo)) =
            changeOfScope _declarations_declVarNames (_declarations_unboundNames ++ _lhs_unboundNames) _lhs_namesInScope
        ( _range_self) =
            (_range )
        ( _declarations_betaUnique,_declarations_bindingGroups,_declarations_collectednotypedef,_declarations_declVarNames,_declarations_localTypes,_declarations_matchIO,_declarations_oneLineTree,_declarations_overloadedVars,_declarations_patternMatchWarnings,_declarations_self,_declarations_typeAnnotations,_declarations_typeSignatures,_declarations_unboundNames) =
            (_declarations (_lhs_allPatterns) (_lhs_betaUnique) ([]) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_monoTable) (_lhs_monos) (_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (emptyFM))
    in  ( _aset
         ,_declarations_betaUnique
         ,_notypedefs ++ _declarations_collectednotypedef
         ,_cset
         ,convertLocal _lhs_substitution _lhs_predicates _notypedefs
          `plusFM` foldFM (\n ts fm -> addToFM fm (NameWithRange n) ts) emptyFM  _declarations_typeSignatures
          `plusFM` _declarations_localTypes
         ,_declarations_matchIO
         ,_lhs_monos
         ,_namesInScope
         ,_oneLineTree
         ,_declarations_overloadedVars
         ,_declarations_patternMatchWarnings
         ,_self
         ,_anns ++ _declarations_typeAnnotations
         ,_unboundNames
         ,_lhs_uniqueSecondRound
         )
-- Qualifiers --------------------------------------------------
-- semantic domain
type T_Qualifiers = ([((Expression, [String]), Core_TypingStrategy)]) ->
                    (Assumptions) ->
                    (Int) ->
                    ([(Name,Tps,Tp,Bool)]) ->
                    (ConstraintSet) ->
                    (ImportEnvironment) ->
                    (LocalTypes) ->
                    (IO ()) ->
                    (Tps) ->
                    (Names) ->
                    (OverloadedVariables) ->
                    (Names) ->
                    ([Warning]) ->
                    (Predicates) ->
                    (WrappedSubstitution) ->
                    (TypeAnnotations) ->
                    (Names) ->
                    (Int) ->
                    ( (Assumptions),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(LocalTypes),(IO ()),(Tps),(Names),( [ OneLineTree] ),(OverloadedVariables),([Warning]),(Qualifiers),(TypeAnnotations),(Names),(Int))
-- cata
sem_Qualifiers :: (Qualifiers) ->
                  (T_Qualifiers)
sem_Qualifiers (list) =
    (foldr (sem_Qualifiers_Cons) (sem_Qualifiers_Nil) ((map sem_Qualifier list)))
sem_Qualifiers_Cons :: (T_Qualifier) ->
                       (T_Qualifiers) ->
                       (T_Qualifiers)
sem_Qualifiers_Cons (_hd) (_tl) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_unboundNames) (_lhs_uniqueSecondRound) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_assumptions,_hd_betaUnique,_hd_collectednotypedef,_hd_constraints,_hd_localTypes,_hd_matchIO,_hd_monos,_hd_namesInScope,_hd_oneLineTree,_hd_overloadedVars,_hd_patternMatchWarnings,_hd_self,_hd_typeAnnotations,_hd_unboundNames,_hd_uniqueSecondRound) =
            (_hd (_lhs_allPatterns) (_tl_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_tl_constraints) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_tl_unboundNames) (_lhs_uniqueSecondRound))
        ( _tl_assumptions,_tl_betaUnique,_tl_collectednotypedef,_tl_constraints,_tl_localTypes,_tl_matchIO,_tl_monos,_tl_namesInScope,_tl_oneLineTree,_tl_overloadedVars,_tl_patternMatchWarnings,_tl_self,_tl_typeAnnotations,_tl_unboundNames,_tl_uniqueSecondRound) =
            (_tl (_lhs_allPatterns) (_lhs_assumptions) (_hd_betaUnique) (_hd_collectednotypedef) (_lhs_constraints) (_lhs_importEnvironment) (_hd_localTypes) (_hd_matchIO) (_hd_monos) (_hd_namesInScope) (_hd_overloadedVars) (_lhs_overloads) (_hd_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_hd_typeAnnotations) (_lhs_unboundNames) (_hd_uniqueSecondRound))
    in  ( _hd_assumptions,_tl_betaUnique,_tl_collectednotypedef,_hd_constraints,_tl_localTypes,_tl_matchIO,_tl_monos,_tl_namesInScope,_hd_oneLineTree  :  _tl_oneLineTree,_tl_overloadedVars,_tl_patternMatchWarnings,_self,_tl_typeAnnotations,_hd_unboundNames,_tl_uniqueSecondRound)
sem_Qualifiers_Nil :: (T_Qualifiers)
sem_Qualifiers_Nil (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_unboundNames) (_lhs_uniqueSecondRound) =
    let (_self) =
            []
    in  ( _lhs_assumptions,_lhs_betaUnique,_lhs_collectednotypedef,_lhs_constraints,_lhs_localTypes,_lhs_matchIO,_lhs_monos,_lhs_namesInScope,[],_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,_lhs_unboundNames,_lhs_uniqueSecondRound)
-- Range -------------------------------------------------------
-- semantic domain
type T_Range = ( (Range))
-- cata
sem_Range :: (Range) ->
             (T_Range)
sem_Range ((Range_Range (_start) (_stop))) =
    (sem_Range_Range ((sem_Position (_start))) ((sem_Position (_stop))))
sem_Range_Range :: (T_Position) ->
                   (T_Position) ->
                   (T_Range)
sem_Range_Range (_start) (_stop) =
    let (_self) =
            Range_Range _start_self _stop_self
        ( _start_self) =
            (_start )
        ( _stop_self) =
            (_stop )
    in  ( _self)
-- RecordExpressionBinding -------------------------------------
-- semantic domain
type T_RecordExpressionBinding = ([(Name,Tps,Tp,Bool)]) ->
                                 (LocalTypes) ->
                                 (Names) ->
                                 (OverloadedVariables) ->
                                 (Names) ->
                                 ([Warning]) ->
                                 (Predicates) ->
                                 (WrappedSubstitution) ->
                                 (TypeAnnotations) ->
                                 ( ([(Name,Tps,Tp,Bool)]),(LocalTypes),(OverloadedVariables),([Warning]),(RecordExpressionBinding),(TypeAnnotations),(Names))
-- cata
sem_RecordExpressionBinding :: (RecordExpressionBinding) ->
                               (T_RecordExpressionBinding)
sem_RecordExpressionBinding ((RecordExpressionBinding_RecordExpressionBinding (_range) (_name) (_expression))) =
    (sem_RecordExpressionBinding_RecordExpressionBinding ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Expression (_expression))))
sem_RecordExpressionBinding_RecordExpressionBinding :: (T_Range) ->
                                                       (T_Name) ->
                                                       (T_Expression) ->
                                                       (T_RecordExpressionBinding)
sem_RecordExpressionBinding_RecordExpressionBinding (_range) (_name) (_expression) (_lhs_collectednotypedef) (_lhs_localTypes) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) =
    let (_self) =
            RecordExpressionBinding_RecordExpressionBinding _range_self _name_self _expression_self
        ((_monos,_constructorenv,_betaUnique,_miscerrors,_warnings,_kindErrors,_valueConstructors,_allValueConstructors,_typeConstructors,_allTypeConstructors,_importEnvironment)) =
            internalError "PartialSyntax.ag" "n/a" "RecordExpressionBinding.RecordExpressionBinding"
        ((_allPatterns,_tryPatterns,_matchIO,_uniqueSecondRound)) =
            undefined
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_localTypes,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,_expression_self,_expression_typeAnnotations,_expression_unboundNames,_expression_uniqueSecondRound) =
            (_expression (_allPatterns) (_betaUnique) (_lhs_collectednotypedef) (_importEnvironment) (_lhs_localTypes) (_matchIO) (_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_tryPatterns) (_lhs_typeAnnotations) (_uniqueSecondRound))
    in  ( _expression_collectednotypedef,_expression_localTypes,_expression_overloadedVars,_expression_patternMatchWarnings,_self,_expression_typeAnnotations,_expression_unboundNames)
-- RecordExpressionBindings ------------------------------------
-- semantic domain
type T_RecordExpressionBindings = ([(Name,Tps,Tp,Bool)]) ->
                                  (LocalTypes) ->
                                  (Names) ->
                                  (OverloadedVariables) ->
                                  (Names) ->
                                  ([Warning]) ->
                                  (Predicates) ->
                                  (WrappedSubstitution) ->
                                  (TypeAnnotations) ->
                                  ( ([(Name,Tps,Tp,Bool)]),(LocalTypes),(OverloadedVariables),([Warning]),(RecordExpressionBindings),(TypeAnnotations),(Names))
-- cata
sem_RecordExpressionBindings :: (RecordExpressionBindings) ->
                                (T_RecordExpressionBindings)
sem_RecordExpressionBindings (list) =
    (foldr (sem_RecordExpressionBindings_Cons) (sem_RecordExpressionBindings_Nil) ((map sem_RecordExpressionBinding list)))
sem_RecordExpressionBindings_Cons :: (T_RecordExpressionBinding) ->
                                     (T_RecordExpressionBindings) ->
                                     (T_RecordExpressionBindings)
sem_RecordExpressionBindings_Cons (_hd) (_tl) (_lhs_collectednotypedef) (_lhs_localTypes) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_collectednotypedef,_hd_localTypes,_hd_overloadedVars,_hd_patternMatchWarnings,_hd_self,_hd_typeAnnotations,_hd_unboundNames) =
            (_hd (_lhs_collectednotypedef) (_lhs_localTypes) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations))
        ( _tl_collectednotypedef,_tl_localTypes,_tl_overloadedVars,_tl_patternMatchWarnings,_tl_self,_tl_typeAnnotations,_tl_unboundNames) =
            (_tl (_hd_collectednotypedef) (_hd_localTypes) (_lhs_namesInScope) (_hd_overloadedVars) (_lhs_overloads) (_hd_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_hd_typeAnnotations))
    in  ( _tl_collectednotypedef,_tl_localTypes,_tl_overloadedVars,_tl_patternMatchWarnings,_self,_tl_typeAnnotations,_hd_unboundNames ++ _tl_unboundNames)
sem_RecordExpressionBindings_Nil :: (T_RecordExpressionBindings)
sem_RecordExpressionBindings_Nil (_lhs_collectednotypedef) (_lhs_localTypes) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) =
    let (_self) =
            []
    in  ( _lhs_collectednotypedef,_lhs_localTypes,_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,[])
-- RecordPatternBinding ----------------------------------------
-- semantic domain
type T_RecordPatternBinding = (Names) ->
                              ([Warning]) ->
                              (WrappedSubstitution) ->
                              ( ([Warning]),(RecordPatternBinding),(Names))
-- cata
sem_RecordPatternBinding :: (RecordPatternBinding) ->
                            (T_RecordPatternBinding)
sem_RecordPatternBinding ((RecordPatternBinding_RecordPatternBinding (_range) (_name) (_pattern))) =
    (sem_RecordPatternBinding_RecordPatternBinding ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Pattern (_pattern))))
sem_RecordPatternBinding_RecordPatternBinding :: (T_Range) ->
                                                 (T_Name) ->
                                                 (T_Pattern) ->
                                                 (T_RecordPatternBinding)
sem_RecordPatternBinding_RecordPatternBinding (_range) (_name) (_pattern) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            RecordPatternBinding_RecordPatternBinding _range_self _name_self _pattern_self
        ((_constructorenv,_betaUnique,_miscerrors,_warnings,_valueConstructors,_allValueConstructors,_typeConstructors,_allTypeConstructors,_importEnvironment)) =
            internalError "PartialSyntax.ag" "n/a" "RecordPatternBinding.RecordPatternBinding"
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _pattern_beta,_pattern_betaUnique,_pattern_constraints,_pattern_elements,_pattern_environment,_pattern_oneLineTree,_pattern_patVarNames,_pattern_patternMatchWarnings,_pattern_self,_pattern_unboundNames) =
            (_pattern (_betaUnique) (_importEnvironment) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution))
    in  ( _pattern_patternMatchWarnings,_self,_pattern_unboundNames)
-- RecordPatternBindings ---------------------------------------
-- semantic domain
type T_RecordPatternBindings = (Names) ->
                               ([Warning]) ->
                               (WrappedSubstitution) ->
                               ( ([Warning]),(RecordPatternBindings),(Names))
-- cata
sem_RecordPatternBindings :: (RecordPatternBindings) ->
                             (T_RecordPatternBindings)
sem_RecordPatternBindings (list) =
    (foldr (sem_RecordPatternBindings_Cons) (sem_RecordPatternBindings_Nil) ((map sem_RecordPatternBinding list)))
sem_RecordPatternBindings_Cons :: (T_RecordPatternBinding) ->
                                  (T_RecordPatternBindings) ->
                                  (T_RecordPatternBindings)
sem_RecordPatternBindings_Cons (_hd) (_tl) (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_patternMatchWarnings,_hd_self,_hd_unboundNames) =
            (_hd (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution))
        ( _tl_patternMatchWarnings,_tl_self,_tl_unboundNames) =
            (_tl (_lhs_namesInScope) (_hd_patternMatchWarnings) (_lhs_substitution))
    in  ( _tl_patternMatchWarnings,_self,_hd_unboundNames ++ _tl_unboundNames)
sem_RecordPatternBindings_Nil :: (T_RecordPatternBindings)
sem_RecordPatternBindings_Nil (_lhs_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution) =
    let (_self) =
            []
    in  ( _lhs_patternMatchWarnings,_self,[])
-- RightHandSide -----------------------------------------------
-- semantic domain
type T_RightHandSide = ([((Expression, [String]), Core_TypingStrategy)]) ->
                       (Int) ->
                       ([(Name,Tps,Tp,Bool)]) ->
                       (ImportEnvironment) ->
                       (LocalTypes) ->
                       (IO ()) ->
                       (Tps) ->
                       (Names) ->
                       (OverloadedVariables) ->
                       (Names) ->
                       ([Warning]) ->
                       (Predicates) ->
                       (WrappedSubstitution) ->
                       (TypeAnnotations) ->
                       ( (Assumptions),(Tp),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(Bool),(LocalTypes),(IO ()),( String -> OneLineTree ),(OverloadedVariables),([Warning]),(RightHandSide),(TypeAnnotations),(Names))
-- cata
sem_RightHandSide :: (RightHandSide) ->
                     (T_RightHandSide)
sem_RightHandSide ((RightHandSide_Expression (_range) (_expression) (_where))) =
    (sem_RightHandSide_Expression ((sem_Range (_range))) ((sem_Expression (_expression))) ((sem_MaybeDeclarations (_where))))
sem_RightHandSide ((RightHandSide_Guarded (_range) (_guardedexpressions) (_where))) =
    (sem_RightHandSide_Guarded ((sem_Range (_range))) ((sem_GuardedExpressions (_guardedexpressions))) ((sem_MaybeDeclarations (_where))))
sem_RightHandSide_Expression :: (T_Range) ->
                                (T_Expression) ->
                                (T_MaybeDeclarations) ->
                                (T_RightHandSide)
sem_RightHandSide_Expression (_range) (_expression) (_where) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) =
    let (_self) =
            RightHandSide_Expression _range_self _expression_self _where_self
        (_oneLineTree) =
            \assign -> OneLineNode
                (  [ OneLineText assign, _expression_oneLineTree ]
                ++ case _where_oneLineTree of
                    Nothing -> []
                    Just ds -> [ OneLineText " where ", encloseSep "{" "; " "}" ds ]
                )
        ( _range_self) =
            (_range )
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_localTypes,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,_expression_self,_expression_typeAnnotations,_expression_unboundNames,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_where_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) ([]) (_lhs_typeAnnotations) (_expression_betaUnique))
        ( _where_assumptions,_where_betaUnique,_where_collectednotypedef,_where_constraints,_where_localTypes,_where_matchIO,_where_namesInScope,_where_oneLineTree,_where_overloadedVars,_where_patternMatchWarnings,_where_self,_where_typeAnnotations,_where_unboundNames) =
            (_where (_lhs_allPatterns) (_expression_assumptions) (_expression_uniqueSecondRound) (_expression_collectednotypedef) (_expression_constraints) (_lhs_importEnvironment) (_expression_localTypes) (_expression_matchIO) (_lhs_monos) (_lhs_namesInScope) (_expression_overloadedVars) (_lhs_overloads) (_expression_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_expression_typeAnnotations) (_expression_unboundNames))
    in  ( _where_assumptions,_expression_beta,_where_betaUnique,_where_collectednotypedef,_where_constraints,False,_where_localTypes,_where_matchIO,_oneLineTree,_where_overloadedVars,_where_patternMatchWarnings,_self,_where_typeAnnotations,_where_unboundNames)
sem_RightHandSide_Guarded :: (T_Range) ->
                             (T_GuardedExpressions) ->
                             (T_MaybeDeclarations) ->
                             (T_RightHandSide)
sem_RightHandSide_Guarded (_range) (_guardedexpressions) (_where) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) =
    let (_self) =
            RightHandSide_Guarded _range_self _guardedexpressions_self _where_self
        (_beta) =
            TVar _lhs_betaUnique
        (_oneLineTree) =
            \assign -> OneLineNode
                (  [ punctuate " " [ ge assign | ge <- _guardedexpressions_oneLineTree ] ]
                ++ case _where_oneLineTree of
                    Nothing -> []
                    Just ds -> [ OneLineText " where ", encloseSep "{" "; " "}" ds ]
                )
        ( _range_self) =
            (_range )
        ( _guardedexpressions_assumptions
         ,_guardedexpressions_betaUnique
         ,_guardedexpressions_betas
         ,_guardedexpressions_collectednotypedef
         ,_guardedexpressions_constraintslist
         ,_guardedexpressions_fallthrough
         ,_guardedexpressions_localTypes
         ,_guardedexpressions_matchIO
         ,_guardedexpressions_oneLineTree
         ,_guardedexpressions_overloadedVars
         ,_guardedexpressions_patternMatchWarnings
         ,_guardedexpressions_self
         ,_guardedexpressions_typeAnnotations
         ,_guardedexpressions_unboundNames
         ,_guardedexpressions_uniqueSecondRound
         ) =
            (_guardedexpressions (_lhs_allPatterns) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_where_namesInScope) (length _guardedexpressions_constraintslist) (True) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_beta) (_lhs_substitution) (_lhs_typeAnnotations) (_guardedexpressions_betaUnique))
        ( _where_assumptions,_where_betaUnique,_where_collectednotypedef,_where_constraints,_where_localTypes,_where_matchIO,_where_namesInScope,_where_oneLineTree,_where_overloadedVars,_where_patternMatchWarnings,_where_self,_where_typeAnnotations,_where_unboundNames) =
            (_where (_lhs_allPatterns)
                    (_guardedexpressions_assumptions)
                    (_guardedexpressions_uniqueSecondRound)
                    (_guardedexpressions_collectednotypedef)
                    (Node _guardedexpressions_constraintslist)
                    (_lhs_importEnvironment)
                    (_guardedexpressions_localTypes)
                    (_guardedexpressions_matchIO)
                    (_lhs_monos)
                    (_lhs_namesInScope)
                    (_guardedexpressions_overloadedVars)
                    (_lhs_overloads)
                    (_guardedexpressions_patternMatchWarnings)
                    (_lhs_predicates)
                    (_lhs_substitution)
                    (_guardedexpressions_typeAnnotations)
                    (_guardedexpressions_unboundNames))
    in  ( _where_assumptions
         ,_beta
         ,_where_betaUnique
         ,_where_collectednotypedef
         ,_where_constraints
         ,_guardedexpressions_fallthrough
         ,_where_localTypes
         ,_where_matchIO
         ,_oneLineTree
         ,_where_overloadedVars
         ,(if _guardedexpressions_fallthrough then [FallThrough _range] else [])
          ++ _where_patternMatchWarnings
         ,_self
         ,_where_typeAnnotations
         ,_where_unboundNames
         )
-- SimpleType --------------------------------------------------
-- semantic domain
type T_SimpleType = ( (SimpleType))
-- cata
sem_SimpleType :: (SimpleType) ->
                  (T_SimpleType)
sem_SimpleType ((SimpleType_SimpleType (_range) (_name) (_typevariables))) =
    (sem_SimpleType_SimpleType ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Names (_typevariables))))
sem_SimpleType_SimpleType :: (T_Range) ->
                             (T_Name) ->
                             (T_Names) ->
                             (T_SimpleType)
sem_SimpleType_SimpleType (_range) (_name) (_typevariables) =
    let (_self) =
            SimpleType_SimpleType _range_self _name_self _typevariables_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _typevariables_isIdentifier,_typevariables_isOperator,_typevariables_isSpecial,_typevariables_oneLineTree,_typevariables_self) =
            (_typevariables )
    in  ( _self)
-- Statement ---------------------------------------------------
-- semantic domain
type T_Statement = ([((Expression, [String]), Core_TypingStrategy)]) ->
                   (Assumptions) ->
                   (Int) ->
                   ([(Name,Tps,Tp,Bool)]) ->
                   (ConstraintSet) ->
                   (Maybe Tp) ->
                   (ImportEnvironment) ->
                   (LocalTypes) ->
                   (IO ()) ->
                   (Tps) ->
                   (Names) ->
                   (OverloadedVariables) ->
                   (Names) ->
                   ([Warning]) ->
                   (Predicates) ->
                   (WrappedSubstitution) ->
                   (TypeAnnotations) ->
                   (Names) ->
                   (Int) ->
                   ( (Assumptions),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(Maybe Tp),(LocalTypes),(IO ()),(Tps),(Names),(OneLineTree),(OverloadedVariables),([Warning]),(Statement),(TypeAnnotations),(Names),(Int))
-- cata
sem_Statement :: (Statement) ->
                 (T_Statement)
sem_Statement ((Statement_Empty (_range))) =
    (sem_Statement_Empty ((sem_Range (_range))))
sem_Statement ((Statement_Expression (_range) (_expression))) =
    (sem_Statement_Expression ((sem_Range (_range))) ((sem_Expression (_expression))))
sem_Statement ((Statement_Generator (_range) (_pattern) (_expression))) =
    (sem_Statement_Generator ((sem_Range (_range))) ((sem_Pattern (_pattern))) ((sem_Expression (_expression))))
sem_Statement ((Statement_Let (_range) (_declarations))) =
    (sem_Statement_Let ((sem_Range (_range))) ((sem_Declarations (_declarations))))
sem_Statement_Empty :: (T_Range) ->
                       (T_Statement)
sem_Statement_Empty (_range) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_generatorBeta) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_unboundNames) (_lhs_uniqueSecondRound) =
    let (_self) =
            Statement_Empty _range_self
        (_oneLineTree) =
            OneLineText ""
        ( _range_self) =
            (_range )
    in  ( _lhs_assumptions,_lhs_betaUnique,_lhs_collectednotypedef,_lhs_constraints,_lhs_generatorBeta,_lhs_localTypes,_lhs_matchIO,_lhs_monos,_lhs_namesInScope,_oneLineTree,_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,_lhs_unboundNames,_lhs_uniqueSecondRound)
sem_Statement_Expression :: (T_Range) ->
                            (T_Expression) ->
                            (T_Statement)
sem_Statement_Expression (_range) (_expression) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_generatorBeta) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_unboundNames) (_lhs_uniqueSecondRound) =
    let (_self) =
            Statement_Expression _range_self _expression_self
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            [ (_expression_beta .==. ioType _beta) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTStatement,AltExpression,0, "")
                  , location   = "generator"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree ]
                  , typepair   = tppair
                  , properties = [ ]
                  }
        (_oneLineTree) =
            _expression_oneLineTree
        ( _range_self) =
            (_range )
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_localTypes,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,_expression_self,_expression_typeAnnotations,_expression_unboundNames,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) ([]) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _lhs_assumptions `combine` _expression_assumptions
         ,_expression_betaUnique
         ,_expression_collectednotypedef
         ,Node [ _newcon .<. _expression_constraints
               , _lhs_constraints
               ]
         ,Just _beta
         ,_expression_localTypes
         ,_expression_matchIO
         ,_lhs_monos
         ,_lhs_namesInScope
         ,_oneLineTree
         ,_expression_overloadedVars
         ,_expression_patternMatchWarnings
         ,_self
         ,_expression_typeAnnotations
         ,_expression_unboundNames ++ _lhs_unboundNames
         ,_expression_uniqueSecondRound
         )
sem_Statement_Generator :: (T_Range) ->
                           (T_Pattern) ->
                           (T_Expression) ->
                           (T_Statement)
sem_Statement_Generator (_range) (_pattern) (_expression) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_generatorBeta) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_unboundNames) (_lhs_uniqueSecondRound) =
    let (_self) =
            Statement_Generator _range_self _pattern_self _expression_self
        ((_csetBinds,_assumptions')) =
            (_pattern_environment .===. _lhs_assumptions) _cinfoBind
        (_newcon) =
            [ (_expression_beta .==. ioType _pattern_beta) _cinfoResult ]
        (_cinfoResult) =
            \tppair ->
            CInfo { info       = (NTStatement, AltGenerator, 0, "result")
                  , location   = "generator"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm _expression_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getExprRange _expression_self) ]
                  }
        (_cinfoBind) =
            variableBindingCInfo (NTStatement, AltGenerator, 1)
        (_oneLineTree) =
            OneLineNode [ _pattern_oneLineTree, OneLineText " <- ", _expression_oneLineTree ]
        ((_namesInScope,_unboundNames,_scopeInfo)) =
            changeOfScope _pattern_patVarNames (_expression_unboundNames ++ _lhs_unboundNames) _lhs_namesInScope
        ( _range_self) =
            (_range )
        ( _pattern_beta,_pattern_betaUnique,_pattern_constraints,_pattern_elements,_pattern_environment,_pattern_oneLineTree,_pattern_patVarNames,_pattern_patternMatchWarnings,_pattern_self,_pattern_unboundNames) =
            (_pattern (_lhs_betaUnique) (_lhs_importEnvironment) (_namesInScope) (_lhs_patternMatchWarnings) (_lhs_substitution))
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_localTypes,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_overloadedVars,_expression_patternMatchWarnings,_expression_self,_expression_typeAnnotations,_expression_unboundNames,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_pattern_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_pattern_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) ([]) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _assumptions' `combine` _expression_assumptions
         ,_expression_betaUnique
         ,_expression_collectednotypedef
         ,_newcon .>. _csetBinds .>>.
          Node [ _pattern_constraints
               , _expression_constraints
               , _lhs_constraints
               ]
         ,Nothing
         ,_expression_localTypes
         ,_expression_matchIO
         ,eltsFM _pattern_environment ++ getMonos _csetBinds ++ _lhs_monos
         ,_namesInScope
         ,_oneLineTree
         ,_expression_overloadedVars
         ,patternMatchWarnings _lhs_importEnvironment
                               _lhs_substitution
                               _pattern_beta
                               (:[])
                               [(_pattern_elements, False)]
                               _range
                               Nothing
                               False
                               []
                               "generator"
                               "<-"
          ++ _expression_patternMatchWarnings
         ,_self
         ,_expression_typeAnnotations
         ,_unboundNames
         ,_expression_uniqueSecondRound
         )
sem_Statement_Let :: (T_Range) ->
                     (T_Declarations) ->
                     (T_Statement)
sem_Statement_Let (_range) (_declarations) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_generatorBeta) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_unboundNames) (_lhs_uniqueSecondRound) =
    let (_self) =
            Statement_Let _range_self _declarations_self
        ((_aset,_cset,_monoTable)) =
            performBindingGroup _lhs_monos _declarations_typeSignatures (_mybdggroup : _declarations_bindingGroups)
        (_mybdggroup) =
            (noAssumptions ,_lhs_assumptions,[_lhs_constraints])
        ((_anns,_notypedefs)) =
            findTypeAnnotations False _lhs_monos _declarations_typeSignatures (_mybdggroup : _declarations_bindingGroups)
        ((_collectTypeConstructors,_collectValueConstructors,_collectTypeSynonyms,_collectConstructorEnv,_derivedFunctions,_operatorFixities)) =
            internalError "PartialSyntax.ag" "n/a" "toplevel Statement"
        (_oneLineTree) =
            OneLineNode [ OneLineText "let ", encloseSep "{" "; " "}" _declarations_oneLineTree ]
        ((_namesInScope,_unboundNames,_scopeInfo)) =
            changeOfScope _declarations_declVarNames (_declarations_unboundNames ++ _lhs_unboundNames) _lhs_namesInScope
        ( _range_self) =
            (_range )
        ( _declarations_betaUnique,_declarations_bindingGroups,_declarations_collectednotypedef,_declarations_declVarNames,_declarations_localTypes,_declarations_matchIO,_declarations_oneLineTree,_declarations_overloadedVars,_declarations_patternMatchWarnings,_declarations_self,_declarations_typeAnnotations,_declarations_typeSignatures,_declarations_unboundNames) =
            (_declarations (_lhs_allPatterns) (_lhs_betaUnique) ([]) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_monoTable) (_lhs_monos) (_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (emptyFM))
    in  ( _aset
         ,_declarations_betaUnique
         ,_notypedefs ++ _declarations_collectednotypedef
         ,_cset
         ,Nothing
         ,convertLocal _lhs_substitution _lhs_predicates _notypedefs
          `plusFM` foldFM (\n ts fm -> addToFM fm (NameWithRange n) ts) emptyFM  _declarations_typeSignatures
          `plusFM` _declarations_localTypes
         ,_declarations_matchIO
         ,_lhs_monos
         ,_namesInScope
         ,_oneLineTree
         ,_declarations_overloadedVars
         ,_declarations_patternMatchWarnings
         ,_self
         ,_anns ++ _declarations_typeAnnotations
         ,_unboundNames
         ,_lhs_uniqueSecondRound
         )
-- Statements --------------------------------------------------
-- semantic domain
type T_Statements = ([((Expression, [String]), Core_TypingStrategy)]) ->
                    (Assumptions) ->
                    (Int) ->
                    ([(Name,Tps,Tp,Bool)]) ->
                    (ConstraintSet) ->
                    (Maybe Tp) ->
                    (ImportEnvironment) ->
                    (LocalTypes) ->
                    (IO ()) ->
                    (Tps) ->
                    (Names) ->
                    (OverloadedVariables) ->
                    (Names) ->
                    ([Warning]) ->
                    (Predicates) ->
                    (WrappedSubstitution) ->
                    (TypeAnnotations) ->
                    (Names) ->
                    (Int) ->
                    ( (Assumptions),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(Maybe Tp),(LocalTypes),(IO ()),(Names),( [ OneLineTree] ),(OverloadedVariables),([Warning]),(Statements),(TypeAnnotations),(Names),(Int))
-- cata
sem_Statements :: (Statements) ->
                  (T_Statements)
sem_Statements (list) =
    (foldr (sem_Statements_Cons) (sem_Statements_Nil) ((map sem_Statement list)))
sem_Statements_Cons :: (T_Statement) ->
                       (T_Statements) ->
                       (T_Statements)
sem_Statements_Cons (_hd) (_tl) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_generatorBeta) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_unboundNames) (_lhs_uniqueSecondRound) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_assumptions,_hd_betaUnique,_hd_collectednotypedef,_hd_constraints,_hd_generatorBeta,_hd_localTypes,_hd_matchIO,_hd_monos,_hd_namesInScope,_hd_oneLineTree,_hd_overloadedVars,_hd_patternMatchWarnings,_hd_self,_hd_typeAnnotations,_hd_unboundNames,_hd_uniqueSecondRound) =
            (_hd (_lhs_allPatterns) (_tl_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_tl_constraints) (_lhs_generatorBeta) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_tl_unboundNames) (_lhs_uniqueSecondRound))
        ( _tl_assumptions,_tl_betaUnique,_tl_collectednotypedef,_tl_constraints,_tl_generatorBeta,_tl_localTypes,_tl_matchIO,_tl_namesInScope,_tl_oneLineTree,_tl_overloadedVars,_tl_patternMatchWarnings,_tl_self,_tl_typeAnnotations,_tl_unboundNames,_tl_uniqueSecondRound) =
            (_tl (_lhs_allPatterns) (_lhs_assumptions) (_hd_betaUnique) (_hd_collectednotypedef) (_lhs_constraints) (_hd_generatorBeta) (_lhs_importEnvironment) (_hd_localTypes) (_hd_matchIO) (_hd_monos) (_hd_namesInScope) (_hd_overloadedVars) (_lhs_overloads) (_hd_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_hd_typeAnnotations) (_lhs_unboundNames) (_hd_uniqueSecondRound))
    in  ( _hd_assumptions,_tl_betaUnique,_tl_collectednotypedef,_hd_constraints,_tl_generatorBeta,_tl_localTypes,_tl_matchIO,_tl_namesInScope,_hd_oneLineTree  :  _tl_oneLineTree,_tl_overloadedVars,_tl_patternMatchWarnings,_self,_tl_typeAnnotations,_hd_unboundNames,_tl_uniqueSecondRound)
sem_Statements_Nil :: (T_Statements)
sem_Statements_Nil (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_generatorBeta) (_lhs_importEnvironment) (_lhs_localTypes) (_lhs_matchIO) (_lhs_monos) (_lhs_namesInScope) (_lhs_overloadedVars) (_lhs_overloads) (_lhs_patternMatchWarnings) (_lhs_predicates) (_lhs_substitution) (_lhs_typeAnnotations) (_lhs_unboundNames) (_lhs_uniqueSecondRound) =
    let (_self) =
            []
    in  ( _lhs_assumptions,_lhs_betaUnique,_lhs_collectednotypedef,_lhs_constraints,_lhs_generatorBeta,_lhs_localTypes,_lhs_matchIO,_lhs_namesInScope,[],_lhs_overloadedVars,_lhs_patternMatchWarnings,_self,_lhs_typeAnnotations,_lhs_unboundNames,_lhs_uniqueSecondRound)
-- Strings -----------------------------------------------------
-- semantic domain
type T_Strings = ( ( [ OneLineTree] ),(Strings))
-- cata
sem_Strings :: (Strings) ->
               (T_Strings)
sem_Strings (list) =
    (foldr (sem_Strings_Cons) (sem_Strings_Nil) (list))
sem_Strings_Cons :: (String) ->
                    (T_Strings) ->
                    (T_Strings)
sem_Strings_Cons (_hd) (_tl) =
    let (_self) =
            (:) _hd _tl_self
        ( _tl_oneLineTree,_tl_self) =
            (_tl )
    in  ( _tl_oneLineTree,_self)
sem_Strings_Nil :: (T_Strings)
sem_Strings_Nil  =
    let (_self) =
            []
    in  ( [],_self)
-- Type --------------------------------------------------------
-- semantic domain
type T_Type = ( (Type))
-- cata
sem_Type :: (Type) ->
            (T_Type)
sem_Type ((Type_Application (_range) (_prefix) (_function) (_arguments))) =
    (sem_Type_Application ((sem_Range (_range))) (_prefix) ((sem_Type (_function))) ((sem_Types (_arguments))))
sem_Type ((Type_Constructor (_range) (_name))) =
    (sem_Type_Constructor ((sem_Range (_range))) ((sem_Name (_name))))
sem_Type ((Type_Exists (_range) (_typevariables) (_type))) =
    (sem_Type_Exists ((sem_Range (_range))) ((sem_Names (_typevariables))) ((sem_Type (_type))))
sem_Type ((Type_Forall (_range) (_typevariables) (_type))) =
    (sem_Type_Forall ((sem_Range (_range))) ((sem_Names (_typevariables))) ((sem_Type (_type))))
sem_Type ((Type_Parenthesized (_range) (_type))) =
    (sem_Type_Parenthesized ((sem_Range (_range))) ((sem_Type (_type))))
sem_Type ((Type_Qualified (_range) (_context) (_type))) =
    (sem_Type_Qualified ((sem_Range (_range))) ((sem_ContextItems (_context))) ((sem_Type (_type))))
sem_Type ((Type_Variable (_range) (_name))) =
    (sem_Type_Variable ((sem_Range (_range))) ((sem_Name (_name))))
sem_Type_Application :: (T_Range) ->
                        (Bool) ->
                        (T_Type) ->
                        (T_Types) ->
                        (T_Type)
sem_Type_Application (_range) (_prefix) (_function) (_arguments) =
    let (_self) =
            Type_Application _range_self _prefix _function_self _arguments_self
        ( _range_self) =
            (_range )
        ( _function_self) =
            (_function )
        ( _arguments_self) =
            (_arguments )
    in  ( _self)
sem_Type_Constructor :: (T_Range) ->
                        (T_Name) ->
                        (T_Type)
sem_Type_Constructor (_range) (_name) =
    let (_self) =
            Type_Constructor _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( _self)
sem_Type_Exists :: (T_Range) ->
                   (T_Names) ->
                   (T_Type) ->
                   (T_Type)
sem_Type_Exists (_range) (_typevariables) (_type) =
    let (_self) =
            Type_Exists _range_self _typevariables_self _type_self
        ( _range_self) =
            (_range )
        ( _typevariables_isIdentifier,_typevariables_isOperator,_typevariables_isSpecial,_typevariables_oneLineTree,_typevariables_self) =
            (_typevariables )
        ( _type_self) =
            (_type )
    in  ( _self)
sem_Type_Forall :: (T_Range) ->
                   (T_Names) ->
                   (T_Type) ->
                   (T_Type)
sem_Type_Forall (_range) (_typevariables) (_type) =
    let (_self) =
            Type_Forall _range_self _typevariables_self _type_self
        ( _range_self) =
            (_range )
        ( _typevariables_isIdentifier,_typevariables_isOperator,_typevariables_isSpecial,_typevariables_oneLineTree,_typevariables_self) =
            (_typevariables )
        ( _type_self) =
            (_type )
    in  ( _self)
sem_Type_Parenthesized :: (T_Range) ->
                          (T_Type) ->
                          (T_Type)
sem_Type_Parenthesized (_range) (_type) =
    let (_self) =
            Type_Parenthesized _range_self _type_self
        ( _range_self) =
            (_range )
        ( _type_self) =
            (_type )
    in  ( _self)
sem_Type_Qualified :: (T_Range) ->
                      (T_ContextItems) ->
                      (T_Type) ->
                      (T_Type)
sem_Type_Qualified (_range) (_context) (_type) =
    let (_self) =
            Type_Qualified _range_self _context_self _type_self
        ( _range_self) =
            (_range )
        ( _context_self) =
            (_context )
        ( _type_self) =
            (_type )
    in  ( _self)
sem_Type_Variable :: (T_Range) ->
                     (T_Name) ->
                     (T_Type)
sem_Type_Variable (_range) (_name) =
    let (_self) =
            Type_Variable _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( _self)
-- Types -------------------------------------------------------
-- semantic domain
type T_Types = ( (Types))
-- cata
sem_Types :: (Types) ->
             (T_Types)
sem_Types (list) =
    (foldr (sem_Types_Cons) (sem_Types_Nil) ((map sem_Type list)))
sem_Types_Cons :: (T_Type) ->
                  (T_Types) ->
                  (T_Types)
sem_Types_Cons (_hd) (_tl) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  ( _self)
sem_Types_Nil :: (T_Types)
sem_Types_Nil  =
    let (_self) =
            []
    in  ( _self)

