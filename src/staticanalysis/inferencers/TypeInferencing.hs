-- do not edit; automatically generated by UU.AG
module TypeInferencing where


-- standard
import Monad                   ( when )
import List                    ( intersperse, partition, nub, zipWith4, union )
-- types
import Types
import TypeConversion
-- constraints
import Constraints
import LiftedConstraints
import ConstraintTree
import Strategy
-- messages
import Messages
import TypeErrors
import Warnings
-- solvers
import SolveConstraints 
import SolveEquivalenceGroups  ( solveEquivalenceGroups )
import SolveGreedy             ( solveGreedy )
import ConstraintInfo
import TypeGraphConstraintInfo
import EquivalenceGroupsImplementation ( )
import HeliumConstraintInfo
-- other
import TopSort                 ( topSort )
import Utils                   ( internalError )
import DerivingShow            ( typeOfShowFunction, nameOfShowFunction ) 
import UHA_Range               ( noRange, getNameRange, getExprRange, getPatRange, getLitRange )
import UHA_Syntax
import UHA_Utils               ( showNameAsOperator )
import ImportEnvironment
import FiniteMap

import OneLiner
import Char
import UHA_Utils (showNameAsOperator)
{-
import List (intersperse)
import SATypes (isTupleConstructor)
-}

import List
import Matchers
import TS_Apply (applyTypingStrategy, matchInformation, MetaVariableTable, MetaVariableInfo)
import TS_CoreSyntax

type Assumptions        = FiniteMap Name [(Name,Tp)]
type PatternAssumptions = FiniteMap Name Tp

noAssumptions :: FiniteMap Name a
noAssumptions = emptyFM

combine :: Assumptions -> Assumptions -> Assumptions
combine = plusFM_C (++)

single :: Name -> Tp -> Assumptions
single n t = unitFM n [(n,t)]


type BindingGroups = [BindingGroup]
type BindingGroup  = (PatternAssumptions,Assumptions,ConstraintSets)
type MonoTable    = [(Names,Tps)]

emptyBindingGroup :: BindingGroup
emptyBindingGroup = (noAssumptions, noAssumptions, [])

combineBindingGroup :: BindingGroup -> BindingGroup -> BindingGroup
combineBindingGroup (e1,a1,c1) (e2,a2,c2) = (e1 `plusFM` e2,a1 `combine` a2,c1++c2)

concatBindingGroups :: BindingGroups -> BindingGroup
concatBindingGroups = foldr combineBindingGroup emptyBindingGroup

type TypeAnnotations = [((Tps,Tp),TpScheme,(Tree,Range))]
type NoTypeDefs      = [(Name,Tps,Tp,Bool)]

findTypeAnnotations :: Bool -> Tps -> FiniteMap Name TpScheme -> BindingGroups -> (TypeAnnotations,NoTypeDefs)
findTypeAnnotations toplevel monos typeSignatures bdgs =
   let (environment,_,_) = concatBindingGroups bdgs
       typeAnnotations   = [ ((monos,tp),ts,(Text (show n),getNameRange n))
                           | (n,(tp,ts)) <- fmToList (intersectFM_C (,) environment typeSignatures)
                           ]
       noTypeDefs        = [ (n,monos,tp,toplevel)
                           | (n,tp) <- fmToList (delListFromFM environment (keysFM typeSignatures))
                           ]
   in (typeAnnotations,noTypeDefs)
                    
performBindingGroup :: Tps -> FiniteMap Name TpScheme -> BindingGroups -> (Assumptions,ConstraintSet,MonoTable)
performBindingGroup monos typeSignatures = variableDependencies . bindingGroupAnalysis

   where
        bindingGroupAnalysis :: BindingGroups -> BindingGroups
        bindingGroupAnalysis cs
                        = let explicits = keysFM typeSignatures
                              indexMap = concat (zipWith f cs [0..])
                              f (env,_,_) i = [ (n,i) | n <- keysFM env, n `notElem` explicits ]
                              edges    = concat (zipWith f' cs [0..])
                              f' (_,ass,_) i = [ (i,j)| n <- keysFM ass, (n',j) <- indexMap, n==n' ]
                              list = topSort (length cs-1) edges
                          in map (concatBindingGroups . map (cs !!)) list

        variableDependencies :: BindingGroups -> (Assumptions,ConstraintSet,MonoTable)
        variableDependencies = foldr op (noAssumptions,ctEmpty,[]) where
            op (e,a,c) (aset,cset,mt) =
               let (cset1,e'   ) = (typeSignatures !:::! e) cinfoBindingGroupExplicitTypedBinding
                   (cset5,aset') = (.<==.) monos e' aset    cinfoBindingGroupImplicit
                   (cset2,a'   ) = (typeSignatures .:::. a) cinfoBindingGroupExplicit
                   (cset3,a''  ) = (e' .===. a')            cinfoSameBindingGroup
               in ( a'' `combine` aset'
                  , cset2 .>>. cset3 .>>. cset5 .>>. 
                    ctStrictOrder [ cset1 .<<. ctNode (reverse c)
                                  , cset
                                  ] 
                  , (keysFM e,eltsFM e'):mt
                  )

findMono :: Name -> MonoTable -> Tps
findMono n = let p = elem n . fst
             in snd . head . filter p

cinfoBindingGroupExplicitTypedBinding :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoBindingGroupExplicitTypedBinding =
  \name tppair ->
  CInfo { info       = (NTBindingGroup,AltBindingGroup,3, "explicit typed binding, "++show name)
        , location   = "explicitly typed binding"
        , errorrange = getNameRange name
        , sources    = [ sourceTerm (Text (show name))]
        , typepair   = tppair
        , properties = [ {- FolkloreConstraint -}
                         ExplicitTypedBinding
                       , HighlyTrusted 
                       ]
        }

variableBindingCInfo :: (InfoNT, InfoAlt, Int) -> Name -> (Tp,Tp) -> HeliumConstraintInfo
variableBindingCInfo (infoNT,infoAlt,i) var tppair =
  CInfo { info       = (infoNT,infoAlt,i,show var) 
        , location   = "variable"
        , errorrange = getNameRange var
        , sources    = [ sourceExpression (Text (show var)) ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint ]  
        }

cinfoSameBindingGroup :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoSameBindingGroup var = variableBindingCInfo (NTBindingGroup,AltBindingGroup,0) var

cinfoBindingGroupImplicit :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoBindingGroupImplicit =
  \var tppair ->   
  CInfo { info       = (NTBindingGroup,AltBindingGroup,1,"implicit, "++show var)
        , location   = "variable"
        , errorrange = getNameRange var
        , sources    = [ sourceExpression (Text (show var)) ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted ]
        }

cinfoBindingGroupExplicit :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoBindingGroupExplicit =
  \var tppair ->
  CInfo { info       = (NTBindingGroup,AltBindingGroup,2, "explicit, "++show var)
        , location   = "variable"
        , errorrange = getNameRange var
        , sources    = [ sourceExpression (Text (show var)) ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint ]  
        }

convertMaybeOneLineTree :: Maybe Tree -> Tree
convertMaybeOneLineTree = maybe (Text "") id
    
getRHSRange :: RightHandSide -> Range
getRHSRange (RightHandSide_Expression r _ _) = r
getRHSRange (RightHandSide_Guarded r _ _) = r

getMaybeExprRange :: MaybeExpression -> Range
getMaybeExprRange (MaybeExpression_Just expr) = getExprRange expr
getMaybeExprRange (MaybeExpression_Nothing)   = noRange

tpToInt :: Tp -> Int
tpToInt tp = case ftv tp of
               [i] -> i
               _   -> (-1)

sourceTerm, sourceExpression, sourcePattern, sourceOperator :: Tree -> (String, Tree)
sourceTerm        = (,) "term"
sourceExpression  = (,) "expression"
sourcePattern     = (,) "pattern"
sourceOperator    = (,) "operator"
sourceConstructor = (,) "constructor"


encloseSep :: String -> String -> String -> [Tree] -> Tree
encloseSep left sep right [] = Node [Text left, Text right]
encloseSep left sep right (t:ts) =
    Node ([ Text left] ++ (t : concatMap (\t -> [Text sep,t]) ts) ++ [Text right] )

punctuate :: String -> [Tree] -> Tree
punctuate _ [] = Text ""
punctuate _ [t] = t
punctuate s (t:ts) = Node (t : concatMap (\t -> [Text s,t]) ts)
    
parens :: Tree -> Tree
parens tree = Node [ Text "(", tree, Text ")" ]

sepBy :: Tree -> [Tree] -> [Tree]
sepBy separator list =
    intersperse separator (map (\x -> Node [x]) list)

intErr :: String -> String -> a
intErr node message = internalError "UHA_OneLine" node message

oneLineTreeAsOperator :: Tree -> Tree
oneLineTreeAsOperator tree =
   case tree of
      Node [Text (first:_)]
         |  isAlpha first || first == '_'
         -> Node [ Text "`", tree, Text "`" ]
      _  -> tree

matchConverter0 :: [([String],())] -> ()
matchConverter0 = const ()

matchConverter1 :: [([String],a)] -> [(a,[String])]
matchConverter1 = map (\(a,b) -> (b,a))  
                  
matchConverter2 :: [([String],(a,b))] -> ([(a,[String])],[(b,[String])])
matchConverter2 = let insert (metas,(a,b)) (as,bs) = ((a,metas):as,(b,metas):bs)
                  in foldr insert ([],[])                  

matchConverter3 :: [([String],(a,b,c))] -> ([(a,[String])],[(b,[String])],[(c,[String])])
matchConverter3 = let insert (metas,(a,b,c)) (as,bs,cs) = ((a,metas):as,(b,metas):bs,(c,metas):cs)
                  in foldr insert ([],[],[]) 

allMatch :: [Maybe [a]] -> Maybe [a]
allMatch = rec []
  where rec xs []             = Just xs
        rec xs (Nothing:_)    = Nothing
        rec xs (Just ys:rest) = rec (ys ++ xs) rest

data Match a = NoMatch | NonTerminalMatch a | MetaVariableMatch String

instance Show (Match a) where
  show (NoMatch) = "NoMatch"
  show (NonTerminalMatch a) = "NonTerminal ??"
  show (MetaVariableMatch s) = "MetaVariableMatch "++show s

expressionVariableMatcher :: Expression -> Maybe String
expressionVariableMatcher expr =
   case expr of
      Expression_Variable _ name -> Just (show name)
      _                          -> Nothing

match0 = generalMatch expressionVariableMatcher matchConverter0
match1 = generalMatch expressionVariableMatcher matchConverter1
match2 = generalMatch expressionVariableMatcher matchConverter2
match3 = generalMatch expressionVariableMatcher matchConverter3

match0' = generalMatch noMatch matchConverter0 noMetaVariableInfo 0
match1' = generalMatch noMatch matchConverter1 noMetaVariableInfo 0
match2' = generalMatch noMatch matchConverter2 noMetaVariableInfo 0

matchOnlyVariable localInfo tryPats = 
   let ((),matches,_,_,_) = match0 localInfo 0 noMatch tryPats [] []
   in matches

noMatch :: a -> Maybe b
noMatch = const Nothing

--noMetaVariableInfo :: MetaVariableInfo
noMetaVariableInfo = internalError "PatternMatching.ag" "noMetaVariableInfo" ""

generalMatch :: (nonTerminal -> Maybe String) 
             -> ([([String], childrenTuple)] -> childrenResult)
             -> (ConstraintSet, MetaVariableInfo)
             -> Int             
             -> (nonTerminal -> Maybe childrenTuple) 
             -> [(nonTerminal, [String])] 
             -> [((nonTerminal, [String]), Core_TypingStrategy)] 
             -> [[Maybe (MetaVariableTable MetaVariableInfo)]] 
             -> ( childrenResult
                , [Maybe (MetaVariableTable MetaVariableInfo)]
                , ConstraintSet
                , Int
                , IO ()
                )

generalMatch exprVarMatcher converter metaVariableInfo unique matcher tryPats allPats childrenResults =
   let match (expr,metas) = 
          case exprVarMatcher expr of
             Just s | s `elem` metas -> MetaVariableMatch s
             _ -> case matcher expr of
                     Just x  -> NonTerminalMatch (metas,x)
                     Nothing -> NoMatch
           
       (allPatterns, allStrategies) = unzip allPats
       matchListTry = map match tryPats
       matchListNew = map match allPatterns
       
       matchNTTry  = [ x | NonTerminalMatch x <- matchListTry ]
       matchNTNew  = [ x | NonTerminalMatch x <- matchListNew ]
       forChildren = converter (matchNTTry ++ matchNTNew)
       
       numberOfTry = length matchNTTry
       (resultTry,resultNew) = unzip . map (splitAt numberOfTry) $ 
                               if null childrenResults
                                 then [repeat (Just [])]
                                 else childrenResults
       inspectMatch m (res, nts) =
          case m of
             NoMatch             -> (Nothing:res, nts)
             NonTerminalMatch _  -> (allMatch (head nts):res, tail nts)
             MetaVariableMatch s -> (Just [(s,(constraintSet, snd metaVariableInfo))]:res, nts) --  !!!
       
       result   = fst (foldr inspectMatch ([],reverse $ transpose resultTry) matchListTry)       
       complete = let (list,_) = foldr inspectMatch ([],reverse $ transpose resultNew) matchListNew
                  in [ (x, y) | (Just x, y) <- zip list allStrategies ]

       (constraintSet, debugIO, newUnique) = 
          case complete of
          
             [] -> (fst metaVariableInfo, return (), unique)
             
             (childrenInfo, typingStrategy):_ 
                -> applyTypingStrategy typingStrategy metaVariableInfo childrenInfo unique            
   in (forChildren, result, constraintSet, newUnique, debugIO)
   
     {-  msg = unlines [ "try-in: " ++ show (length tryPats)
              , "result: " ++ show (length result)
              , "strategies: " ++ show (length allStrategies)
              , "nt-match try: " ++ show (length matchNTTry)
              , "nt-match new: " ++ show (length matchNTNew)
              , "result try: " ++ if null childrenResults then "???" else show (length $ transpose resultTry)
              , "result new: " ++ if null childrenResults then "???" else show (map (map (maybe "N" (const "J"))) (transpose resultNew))
              , "complete matches: " ++ show (length complete)
              ] -}
-- Alternative -------------------------------------------------
-- semantic domain
type T_Alternative = ([((Expression, [String]), Core_TypingStrategy)]) ->
                     (Tp) ->
                     (Tp) ->
                     (Int) ->
                     ([(Name,Tps,Tp,Bool)]) ->
                     (ImportEnvironment) ->
                     (IO ()) ->
                     (Tps) ->
                     (Int) ->
                     (TypeAnnotations) ->
                     (Int) ->
                     ( (Assumptions),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(IO ()),(Tree),(Alternative),(TypeAnnotations),(Int))
-- cata
sem_Alternative :: (Alternative) ->
                   (T_Alternative)
sem_Alternative ((Alternative_Alternative (_range) (_pattern) (_righthandside))) =
    (sem_Alternative_Alternative ((sem_Range (_range))) ((sem_Pattern (_pattern))) ((sem_RightHandSide (_righthandside))))
sem_Alternative ((Alternative_Empty (_range))) =
    (sem_Alternative_Empty ((sem_Range (_range))))
sem_Alternative_Alternative :: (T_Range) ->
                               (T_Pattern) ->
                               (T_RightHandSide) ->
                               (T_Alternative)
sem_Alternative_Alternative (_range) (_pattern) (_righthandside) (_lhs_allPatterns) (_lhs_betaLeft) (_lhs_betaRight) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_nrOfAlternatives) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Alternative_Alternative _range_self _pattern_self _righthandside_self
        ((_csetBinds,_assumptions')) =
            (_pattern_environment .===. _righthandside_assumptions) _cinfoBind
        (_conLeft) =
            [ (_pattern_beta .==. _lhs_betaLeft) _cinfoLeft ]
        (_conRight) =
            [ (_righthandside_beta .==. _lhs_betaRight) _cinfoRight ]
        (_cinfoLeft) =
            \tppair ->
            CInfo { info       = (NTAlternative, AltAlternative, 0, "left")
                  , location   = "case pattern"
                  , errorrange = _range_self
                  , sources    = [ sourcePattern _pattern_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getPatRange _pattern_self) ]
                  }
        (_cinfoRight) =
            \tppair ->
            CInfo { info       = (NTAlternative, AltAlternative, 1, "right")
                  , location   = "right-hand side of case alternative"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression (_righthandside_oneLineTree "") ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getRHSRange _righthandside_self) ] ++
                                 if _lhs_nrOfAlternatives > 1 then [] else [ HighlyTrusted ]
                  }
        (_cinfoBind) =
            variableBindingCInfo (NTAlternative, AltAlternative, 2)
        (_oneLineTree) =
            Node [ _pattern_oneLineTree, _righthandside_oneLineTree " -> " ]
        ( _range_self) =
            (_range )
        ( _pattern_beta,_pattern_betaUnique,_pattern_constraints,_pattern_environment,_pattern_oneLineTree,_pattern_self) =
            (_pattern (_lhs_betaUnique) (_lhs_importEnvironment))
        ( _righthandside_assumptions,_righthandside_beta,_righthandside_betaUnique,_righthandside_collectednotypedef,_righthandside_constraints,_righthandside_matchIO,_righthandside_oneLineTree,_righthandside_self,_righthandside_typeAnnotations,_righthandside_uniqueSecondRound) =
            (_righthandside (_lhs_allPatterns) (_pattern_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (eltsFM _pattern_environment ++ _lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _assumptions'
         ,_righthandside_betaUnique
         ,_righthandside_collectednotypedef
         ,_csetBinds .>>.
          ctNode [ _conLeft  .<. _pattern_constraints
                 , _conRight .<. _righthandside_constraints
                 ]
         ,_righthandside_matchIO
         ,_oneLineTree
         ,_self
         ,_righthandside_typeAnnotations
         ,_righthandside_uniqueSecondRound
         )
sem_Alternative_Empty :: (T_Range) ->
                         (T_Alternative)
sem_Alternative_Empty (_range) (_lhs_allPatterns) (_lhs_betaLeft) (_lhs_betaRight) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_nrOfAlternatives) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Alternative_Empty _range_self
        (_oneLineTree) =
            Text ""
        ( _range_self) =
            (_range )
    in  ( noAssumptions,_lhs_betaUnique,_lhs_collectednotypedef,ctEmpty,_lhs_matchIO,_oneLineTree,_self,_lhs_typeAnnotations,_lhs_uniqueSecondRound)
-- Alternatives ------------------------------------------------
-- semantic domain
type T_Alternatives = ([((Expression, [String]), Core_TypingStrategy)]) ->
                      (Tp) ->
                      (Tp) ->
                      (Int) ->
                      ([(Name,Tps,Tp,Bool)]) ->
                      (ImportEnvironment) ->
                      (IO ()) ->
                      (Tps) ->
                      (Int) ->
                      (TypeAnnotations) ->
                      (Int) ->
                      ( (Assumptions),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSets),(IO ()),( [ Tree] ),(Alternatives),(TypeAnnotations),(Int))
-- cata
sem_Alternatives :: (Alternatives) ->
                    (T_Alternatives)
sem_Alternatives (list) =
    (foldr (sem_Alternatives_Cons) (sem_Alternatives_Nil) ((map sem_Alternative list)))
sem_Alternatives_Cons :: (T_Alternative) ->
                         (T_Alternatives) ->
                         (T_Alternatives)
sem_Alternatives_Cons (_hd) (_tl) (_lhs_allPatterns) (_lhs_betaLeft) (_lhs_betaRight) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_nrOfAlternatives) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_assumptions,_hd_betaUnique,_hd_collectednotypedef,_hd_constraints,_hd_matchIO,_hd_oneLineTree,_hd_self,_hd_typeAnnotations,_hd_uniqueSecondRound) =
            (_hd (_lhs_allPatterns) (_lhs_betaLeft) (_lhs_betaRight) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_nrOfAlternatives) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _tl_assumptions,_tl_betaUnique,_tl_collectednotypedef,_tl_constraintslist,_tl_matchIO,_tl_oneLineTree,_tl_self,_tl_typeAnnotations,_tl_uniqueSecondRound) =
            (_tl (_lhs_allPatterns) (_lhs_betaLeft) (_lhs_betaRight) (_hd_betaUnique) (_hd_collectednotypedef) (_lhs_importEnvironment) (_hd_matchIO) (_lhs_monos) (_lhs_nrOfAlternatives) (_hd_typeAnnotations) (_hd_uniqueSecondRound))
    in  ( _hd_assumptions `combine` _tl_assumptions,_tl_betaUnique,_tl_collectednotypedef,_hd_constraints : _tl_constraintslist,_tl_matchIO,_hd_oneLineTree  :  _tl_oneLineTree,_self,_tl_typeAnnotations,_tl_uniqueSecondRound)
sem_Alternatives_Nil :: (T_Alternatives)
sem_Alternatives_Nil (_lhs_allPatterns) (_lhs_betaLeft) (_lhs_betaRight) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_nrOfAlternatives) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            []
    in  ( noAssumptions,_lhs_betaUnique,_lhs_collectednotypedef,[],_lhs_matchIO,[],_self,_lhs_typeAnnotations,_lhs_uniqueSecondRound)
-- AnnotatedType -----------------------------------------------
-- semantic domain
type T_AnnotatedType = ( (AnnotatedType))
-- cata
sem_AnnotatedType :: (AnnotatedType) ->
                     (T_AnnotatedType)
sem_AnnotatedType ((AnnotatedType_AnnotatedType (_range) (_strict) (_type))) =
    (sem_AnnotatedType_AnnotatedType ((sem_Range (_range))) (_strict) ((sem_Type (_type))))
sem_AnnotatedType_AnnotatedType :: (T_Range) ->
                                   (Bool) ->
                                   (T_Type) ->
                                   (T_AnnotatedType)
sem_AnnotatedType_AnnotatedType (_range) (_strict) (_type) =
    let (_self) =
            AnnotatedType_AnnotatedType _range_self _strict _type_self
        ( _range_self) =
            (_range )
        ( _type_self) =
            (_type )
    in  ( _self)
-- AnnotatedTypes ----------------------------------------------
-- semantic domain
type T_AnnotatedTypes = ( (AnnotatedTypes))
-- cata
sem_AnnotatedTypes :: (AnnotatedTypes) ->
                      (T_AnnotatedTypes)
sem_AnnotatedTypes (list) =
    (foldr (sem_AnnotatedTypes_Cons) (sem_AnnotatedTypes_Nil) ((map sem_AnnotatedType list)))
sem_AnnotatedTypes_Cons :: (T_AnnotatedType) ->
                           (T_AnnotatedTypes) ->
                           (T_AnnotatedTypes)
sem_AnnotatedTypes_Cons (_hd) (_tl) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  ( _self)
sem_AnnotatedTypes_Nil :: (T_AnnotatedTypes)
sem_AnnotatedTypes_Nil  =
    let (_self) =
            []
    in  ( _self)
-- Body --------------------------------------------------------
-- semantic domain
type T_Body = ([((Expression, [String]), Core_TypingStrategy)]) ->
              (Int) ->
              ([(Name,Tps,Tp,Bool)]) ->
              (ImportEnvironment) ->
              (IO ()) ->
              (Tps) ->
              (TypeAnnotations) ->
              ( (Assumptions),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(IO ()),([(Name,Tp)]),(Body),(TypeAnnotations),(FiniteMap Name TpScheme))
-- cata
sem_Body :: (Body) ->
            (T_Body)
sem_Body ((Body_Body (_range) (_importdeclarations) (_declarations))) =
    (sem_Body_Body ((sem_Range (_range))) ((sem_ImportDeclarations (_importdeclarations))) ((sem_Declarations (_declarations))))
sem_Body_Body :: (T_Range) ->
                 (T_ImportDeclarations) ->
                 (T_Declarations) ->
                 (T_Body)
sem_Body_Body (_range) (_importdeclarations) (_declarations) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) =
    let (_self) =
            Body_Body _range_self _importdeclarations_self _declarations_self
        ((_aset,_cset,_monoTable)) =
            performBindingGroup [] _declarations_typeSignatures _declarations_bindingGroups
        ((_csetBinds,_aset')) =
            (typeEnvironment _lhs_importEnvironment .:::. _aset) _cinfo
        ((_anns,_notypedefs)) =
            findTypeAnnotations True [] _declarations_typeSignatures _declarations_bindingGroups
        (_cinfo) =
            \var tppair ->
            CInfo { info       = (NTBody, AltBody, 0, show var)
                  , location   = "variable"
                  , errorrange = getNameRange var
                  , sources    = [ sourceExpression (Text (show var)) ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , HighlyTrusted
                                 , IsImported var
                                 ]
                  }
        ( _range_self) =
            (_range )
        ( _importdeclarations_self) =
            (_importdeclarations )
        ( _declarations_betaUnique,_declarations_bindingGroups,_declarations_collectednotypedef,_declarations_matchIO,_declarations_oneLineTree,_declarations_self,_declarations_typeAnnotations,_declarations_typeSignatures,_declarations_uniqueSecondRound) =
            (_declarations (_lhs_allPatterns) (_lhs_betaUnique) ([]) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_monoTable) (_lhs_monos) (_lhs_typeAnnotations) (emptyFM) (_declarations_betaUnique))
    in  ( _aset',_declarations_uniqueSecondRound,_notypedefs ++ _declarations_collectednotypedef,ctNode [ _csetBinds .<<. _cset ],_declarations_matchIO,[ (n,tp) | (n,_,tp,_) <- _notypedefs ],_self,_anns ++ _declarations_typeAnnotations,_declarations_typeSignatures)
-- Constructor -------------------------------------------------
-- semantic domain
type T_Constructor = ( (Constructor))
-- cata
sem_Constructor :: (Constructor) ->
                   (T_Constructor)
sem_Constructor ((Constructor_Constructor (_range) (_constructor) (_types))) =
    (sem_Constructor_Constructor ((sem_Range (_range))) ((sem_Name (_constructor))) ((sem_AnnotatedTypes (_types))))
sem_Constructor ((Constructor_Infix (_range) (_leftType) (_constructorOperator) (_rightType))) =
    (sem_Constructor_Infix ((sem_Range (_range))) ((sem_AnnotatedType (_leftType))) ((sem_Name (_constructorOperator))) ((sem_AnnotatedType (_rightType))))
sem_Constructor ((Constructor_Record (_range) (_constructor) (_fieldDeclarations))) =
    (sem_Constructor_Record ((sem_Range (_range))) ((sem_Name (_constructor))) ((sem_FieldDeclarations (_fieldDeclarations))))
sem_Constructor_Constructor :: (T_Range) ->
                               (T_Name) ->
                               (T_AnnotatedTypes) ->
                               (T_Constructor)
sem_Constructor_Constructor (_range) (_constructor) (_types) =
    let (_self) =
            Constructor_Constructor _range_self _constructor_self _types_self
        ( _range_self) =
            (_range )
        ( _constructor_isIdentifier,_constructor_isOperator,_constructor_isSpecial,_constructor_oneLineTree,_constructor_self) =
            (_constructor )
        ( _types_self) =
            (_types )
    in  ( _self)
sem_Constructor_Infix :: (T_Range) ->
                         (T_AnnotatedType) ->
                         (T_Name) ->
                         (T_AnnotatedType) ->
                         (T_Constructor)
sem_Constructor_Infix (_range) (_leftType) (_constructorOperator) (_rightType) =
    let (_self) =
            Constructor_Infix _range_self _leftType_self _constructorOperator_self _rightType_self
        ( _range_self) =
            (_range )
        ( _leftType_self) =
            (_leftType )
        ( _constructorOperator_isIdentifier,_constructorOperator_isOperator,_constructorOperator_isSpecial,_constructorOperator_oneLineTree,_constructorOperator_self) =
            (_constructorOperator )
        ( _rightType_self) =
            (_rightType )
    in  ( _self)
sem_Constructor_Record :: (T_Range) ->
                          (T_Name) ->
                          (T_FieldDeclarations) ->
                          (T_Constructor)
sem_Constructor_Record (_range) (_constructor) (_fieldDeclarations) =
    let (_self) =
            Constructor_Record _range_self _constructor_self _fieldDeclarations_self
        ( _range_self) =
            (_range )
        ( _constructor_isIdentifier,_constructor_isOperator,_constructor_isSpecial,_constructor_oneLineTree,_constructor_self) =
            (_constructor )
        ( _fieldDeclarations_self) =
            (_fieldDeclarations )
    in  ( _self)
-- Constructors ------------------------------------------------
-- semantic domain
type T_Constructors = ( (Constructors))
-- cata
sem_Constructors :: (Constructors) ->
                    (T_Constructors)
sem_Constructors (list) =
    (foldr (sem_Constructors_Cons) (sem_Constructors_Nil) ((map sem_Constructor list)))
sem_Constructors_Cons :: (T_Constructor) ->
                         (T_Constructors) ->
                         (T_Constructors)
sem_Constructors_Cons (_hd) (_tl) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  ( _self)
sem_Constructors_Nil :: (T_Constructors)
sem_Constructors_Nil  =
    let (_self) =
            []
    in  ( _self)
-- ContextItem -------------------------------------------------
-- semantic domain
type T_ContextItem = ( (ContextItem))
-- cata
sem_ContextItem :: (ContextItem) ->
                   (T_ContextItem)
sem_ContextItem ((ContextItem_ContextItem (_range) (_name) (_types))) =
    (sem_ContextItem_ContextItem ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Types (_types))))
sem_ContextItem_ContextItem :: (T_Range) ->
                               (T_Name) ->
                               (T_Types) ->
                               (T_ContextItem)
sem_ContextItem_ContextItem (_range) (_name) (_types) =
    let (_self) =
            ContextItem_ContextItem _range_self _name_self _types_self
        (_tyconEnv) =
            internalError "PartialSyntax.ag" "n/a" "ContextItem.ContextItem"
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _types_self) =
            (_types )
    in  ( _self)
-- ContextItems ------------------------------------------------
-- semantic domain
type T_ContextItems = ( (ContextItems))
-- cata
sem_ContextItems :: (ContextItems) ->
                    (T_ContextItems)
sem_ContextItems (list) =
    (foldr (sem_ContextItems_Cons) (sem_ContextItems_Nil) ((map sem_ContextItem list)))
sem_ContextItems_Cons :: (T_ContextItem) ->
                         (T_ContextItems) ->
                         (T_ContextItems)
sem_ContextItems_Cons (_hd) (_tl) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  ( _self)
sem_ContextItems_Nil :: (T_ContextItems)
sem_ContextItems_Nil  =
    let (_self) =
            []
    in  ( _self)
-- Declaration -------------------------------------------------
-- semantic domain
type T_Declaration = ([((Expression, [String]), Core_TypingStrategy)]) ->
                     (Int) ->
                     (BindingGroups) ->
                     ([(Name,Tps,Tp,Bool)]) ->
                     (ImportEnvironment) ->
                     (IO ()) ->
                     (MonoTable) ->
                     (Tps) ->
                     (TypeAnnotations) ->
                     (FiniteMap Name TpScheme) ->
                     (Int) ->
                     ( (Int),(BindingGroups),([(Name,Tps,Tp,Bool)]),(IO ()),(Tree),(Declaration),(TypeAnnotations),(FiniteMap Name TpScheme),(Int))
-- cata
sem_Declaration :: (Declaration) ->
                   (T_Declaration)
sem_Declaration ((Declaration_Class (_range) (_context) (_simpletype) (_where))) =
    (sem_Declaration_Class ((sem_Range (_range))) ((sem_ContextItems (_context))) ((sem_SimpleType (_simpletype))) ((sem_MaybeDeclarations (_where))))
sem_Declaration ((Declaration_Data (_range) (_context) (_simpletype) (_constructors) (_derivings))) =
    (sem_Declaration_Data ((sem_Range (_range))) ((sem_ContextItems (_context))) ((sem_SimpleType (_simpletype))) ((sem_Constructors (_constructors))) ((sem_Names (_derivings))))
sem_Declaration ((Declaration_Default (_range) (_types))) =
    (sem_Declaration_Default ((sem_Range (_range))) ((sem_Types (_types))))
sem_Declaration ((Declaration_Empty (_range))) =
    (sem_Declaration_Empty ((sem_Range (_range))))
sem_Declaration ((Declaration_Fixity (_range) (_fixity) (_priority) (_operators))) =
    (sem_Declaration_Fixity ((sem_Range (_range))) ((sem_Fixity (_fixity))) ((sem_MaybeInt (_priority))) ((sem_Names (_operators))))
sem_Declaration ((Declaration_FunctionBindings (_range) (_bindings))) =
    (sem_Declaration_FunctionBindings ((sem_Range (_range))) ((sem_FunctionBindings (_bindings))))
sem_Declaration ((Declaration_Instance (_range) (_context) (_name) (_types) (_where))) =
    (sem_Declaration_Instance ((sem_Range (_range))) ((sem_ContextItems (_context))) ((sem_Name (_name))) ((sem_Types (_types))) ((sem_MaybeDeclarations (_where))))
sem_Declaration ((Declaration_Newtype (_range) (_context) (_simpletype) (_constructor) (_derivings))) =
    (sem_Declaration_Newtype ((sem_Range (_range))) ((sem_ContextItems (_context))) ((sem_SimpleType (_simpletype))) ((sem_Constructor (_constructor))) ((sem_Names (_derivings))))
sem_Declaration ((Declaration_PatternBinding (_range) (_pattern) (_righthandside))) =
    (sem_Declaration_PatternBinding ((sem_Range (_range))) ((sem_Pattern (_pattern))) ((sem_RightHandSide (_righthandside))))
sem_Declaration ((Declaration_Type (_range) (_simpletype) (_type))) =
    (sem_Declaration_Type ((sem_Range (_range))) ((sem_SimpleType (_simpletype))) ((sem_Type (_type))))
sem_Declaration ((Declaration_TypeSignature (_range) (_names) (_type))) =
    (sem_Declaration_TypeSignature ((sem_Range (_range))) ((sem_Names (_names))) ((sem_Type (_type))))
sem_Declaration_Class :: (T_Range) ->
                         (T_ContextItems) ->
                         (T_SimpleType) ->
                         (T_MaybeDeclarations) ->
                         (T_Declaration)
sem_Declaration_Class (_range) (_context) (_simpletype) (_where) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_typeSignatures) (_lhs_uniqueSecondRound) =
    let (_self) =
            Declaration_Class _range_self _context_self _simpletype_self _where_self
        ((_assumptions,_constraints,_unboundNames)) =
            internalError "PartialSyntax.ag" "n/a" "Declaration.Class"
        (_oneLineTree) =
            intErr "Declaration" "class"
        ( _range_self) =
            (_range )
        ( _context_self) =
            (_context )
        ( _simpletype_self) =
            (_simpletype )
        ( _where_assumptions,_where_betaUnique,_where_collectednotypedef,_where_constraints,_where_matchIO,_where_oneLineTree,_where_self,_where_typeAnnotations,_where_uniqueSecondRound) =
            (_where (_lhs_allPatterns) (_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_constraints) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _where_betaUnique,_lhs_bindingGroups,_where_collectednotypedef,_where_matchIO,_oneLineTree,_self,_where_typeAnnotations,_lhs_typeSignatures,_where_uniqueSecondRound)
sem_Declaration_Data :: (T_Range) ->
                        (T_ContextItems) ->
                        (T_SimpleType) ->
                        (T_Constructors) ->
                        (T_Names) ->
                        (T_Declaration)
sem_Declaration_Data (_range) (_context) (_simpletype) (_constructors) (_derivings) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_typeSignatures) (_lhs_uniqueSecondRound) =
    let (_self) =
            Declaration_Data _range_self _context_self _simpletype_self _constructors_self _derivings_self
        (_oneLineTree) =
            intErr "Declaration" "data"
        ( _range_self) =
            (_range )
        ( _context_self) =
            (_context )
        ( _simpletype_self) =
            (_simpletype )
        ( _constructors_self) =
            (_constructors )
        ( _derivings_isIdentifier,_derivings_isOperator,_derivings_isSpecial,_derivings_oneLineTree,_derivings_self) =
            (_derivings )
    in  ( _lhs_betaUnique,_lhs_bindingGroups,_lhs_collectednotypedef,_lhs_matchIO,_oneLineTree,_self,_lhs_typeAnnotations,_lhs_typeSignatures,_lhs_uniqueSecondRound)
sem_Declaration_Default :: (T_Range) ->
                           (T_Types) ->
                           (T_Declaration)
sem_Declaration_Default (_range) (_types) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_typeSignatures) (_lhs_uniqueSecondRound) =
    let (_self) =
            Declaration_Default _range_self _types_self
        (_oneLineTree) =
            intErr "Declaration" "default"
        ( _range_self) =
            (_range )
        ( _types_self) =
            (_types )
    in  ( _lhs_betaUnique,_lhs_bindingGroups,_lhs_collectednotypedef,_lhs_matchIO,_oneLineTree,_self,_lhs_typeAnnotations,_lhs_typeSignatures,_lhs_uniqueSecondRound)
sem_Declaration_Empty :: (T_Range) ->
                         (T_Declaration)
sem_Declaration_Empty (_range) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_typeSignatures) (_lhs_uniqueSecondRound) =
    let (_self) =
            Declaration_Empty _range_self
        (_oneLineTree) =
            Text ""
        ( _range_self) =
            (_range )
    in  ( _lhs_betaUnique,_lhs_bindingGroups,_lhs_collectednotypedef,_lhs_matchIO,_oneLineTree,_self,_lhs_typeAnnotations,_lhs_typeSignatures,_lhs_uniqueSecondRound)
sem_Declaration_Fixity :: (T_Range) ->
                          (T_Fixity) ->
                          (T_MaybeInt) ->
                          (T_Names) ->
                          (T_Declaration)
sem_Declaration_Fixity (_range) (_fixity) (_priority) (_operators) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_typeSignatures) (_lhs_uniqueSecondRound) =
    let (_self) =
            Declaration_Fixity _range_self _fixity_self _priority_self _operators_self
        (_oneLineTree) =
            intErr "Declaration" "fixity"
        ( _range_self) =
            (_range )
        ( _fixity_self) =
            (_fixity )
        ( _priority_self) =
            (_priority )
        ( _operators_isIdentifier,_operators_isOperator,_operators_isSpecial,_operators_oneLineTree,_operators_self) =
            (_operators )
    in  ( _lhs_betaUnique,_lhs_bindingGroups,_lhs_collectednotypedef,_lhs_matchIO,_oneLineTree,_self,_lhs_typeAnnotations,_lhs_typeSignatures,_lhs_uniqueSecondRound)
sem_Declaration_FunctionBindings :: (T_Range) ->
                                    (T_FunctionBindings) ->
                                    (T_Declaration)
sem_Declaration_FunctionBindings (_range) (_bindings) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_typeSignatures) (_lhs_uniqueSecondRound) =
    let (_self) =
            Declaration_FunctionBindings _range_self _bindings_self
        (_beta) =
            TVar _lhs_betaUnique
        (_betaRight) =
            TVar (_lhs_betaUnique + 1)
        (_betasLeft) =
            take _bindings_numberOfPatterns (map TVar [_lhs_betaUnique + 2..])
        (_newcon) =
            [ (_beta .==. foldr (.->.) _betaRight _betasLeft) _cinfo ]
        (_mybdggrp) =
            ( unitFM _bindings_name _beta
            , _bindings_assumptions
            , [ _newcon !<!
                ctNode [ ctVariable _lhs_betaUnique
                       , ctNode _bindings_constraintslist
                       ]
              ]
            )
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTDeclaration, AltFunctionBindings, 0, show _bindings_name)
                  , location   = "function bindings (INTERNAL ERROR)"
                  , errorrange = _range_self
                  , sources    = [ ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , SuperHighlyTrusted
                                 , FuntionBindingEdge _bindings_numberOfPatterns
                                 ]
                  }
        (_oneLineTree) =
            punctuate ";" _bindings_oneLineTree
        ( _range_self) =
            (_range )
        ( _bindings_assumptions,_bindings_betaUnique,_bindings_collectednotypedef,_bindings_constraintslist,_bindings_matchIO,_bindings_name,_bindings_numberOfPatterns,_bindings_oneLineTree,_bindings_self,_bindings_typeAnnotations,_bindings_uniqueSecondRound) =
            (_bindings (_lhs_allPatterns) (_betaRight) (_lhs_betaUnique + 2 + _bindings_numberOfPatterns) (_betasLeft) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (findMono _bindings_name _lhs_monoTable ++ _lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _bindings_betaUnique,_mybdggrp : _lhs_bindingGroups,_bindings_collectednotypedef,_bindings_matchIO,_oneLineTree,_self,_bindings_typeAnnotations,_lhs_typeSignatures,_bindings_uniqueSecondRound)
sem_Declaration_Instance :: (T_Range) ->
                            (T_ContextItems) ->
                            (T_Name) ->
                            (T_Types) ->
                            (T_MaybeDeclarations) ->
                            (T_Declaration)
sem_Declaration_Instance (_range) (_context) (_name) (_types) (_where) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_typeSignatures) (_lhs_uniqueSecondRound) =
    let (_self) =
            Declaration_Instance _range_self _context_self _name_self _types_self _where_self
        ((_assumptions,_constraints,_unboundNames)) =
            internalError "PartialSyntax.ag" "n/a" "Declaration.Instance"
        (_oneLineTree) =
            intErr "Declaration" "instance"
        ( _range_self) =
            (_range )
        ( _context_self) =
            (_context )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _types_self) =
            (_types )
        ( _where_assumptions,_where_betaUnique,_where_collectednotypedef,_where_constraints,_where_matchIO,_where_oneLineTree,_where_self,_where_typeAnnotations,_where_uniqueSecondRound) =
            (_where (_lhs_allPatterns) (_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_constraints) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _where_betaUnique,_lhs_bindingGroups,_where_collectednotypedef,_where_matchIO,_oneLineTree,_self,_where_typeAnnotations,_lhs_typeSignatures,_where_uniqueSecondRound)
sem_Declaration_Newtype :: (T_Range) ->
                           (T_ContextItems) ->
                           (T_SimpleType) ->
                           (T_Constructor) ->
                           (T_Names) ->
                           (T_Declaration)
sem_Declaration_Newtype (_range) (_context) (_simpletype) (_constructor) (_derivings) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_typeSignatures) (_lhs_uniqueSecondRound) =
    let (_self) =
            Declaration_Newtype _range_self _context_self _simpletype_self _constructor_self _derivings_self
        (_oneLineTree) =
            intErr "Declaration" "newtype"
        ( _range_self) =
            (_range )
        ( _context_self) =
            (_context )
        ( _simpletype_self) =
            (_simpletype )
        ( _constructor_self) =
            (_constructor )
        ( _derivings_isIdentifier,_derivings_isOperator,_derivings_isSpecial,_derivings_oneLineTree,_derivings_self) =
            (_derivings )
    in  ( _lhs_betaUnique,_lhs_bindingGroups,_lhs_collectednotypedef,_lhs_matchIO,_oneLineTree,_self,_lhs_typeAnnotations,_lhs_typeSignatures,_lhs_uniqueSecondRound)
sem_Declaration_PatternBinding :: (T_Range) ->
                                  (T_Pattern) ->
                                  (T_RightHandSide) ->
                                  (T_Declaration)
sem_Declaration_PatternBinding (_range) (_pattern) (_righthandside) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_typeSignatures) (_lhs_uniqueSecondRound) =
    let (_self) =
            Declaration_PatternBinding _range_self _pattern_self _righthandside_self
        (_newcon) =
            [ (_righthandside_beta .==. _pattern_beta) _cinfo ]
        (_mybdggrp) =
            ( _pattern_environment
            , _righthandside_assumptions
            , [ _newcon .>.
                ctNode [ _pattern_constraints
                       , _righthandside_constraints
                       ]
              ]
            )
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTDeclaration, AltPatternBinding, 0, "")
                  , location   = "right hand side"
                  , errorrange = getRHSRange _righthandside_self
                  , sources    = [ sourceExpression (_righthandside_oneLineTree "") ]
                  , typepair   = tppair
                  , properties = [ ]
                  }
        (_oneLineTree) =
            Node
                [ Node [_pattern_oneLineTree]
                , Node [_righthandside_oneLineTree " = "]
                ]
        ( _range_self) =
            (_range )
        ( _pattern_beta,_pattern_betaUnique,_pattern_constraints,_pattern_environment,_pattern_oneLineTree,_pattern_self) =
            (_pattern (_lhs_betaUnique) (_lhs_importEnvironment))
        ( _righthandside_assumptions,_righthandside_beta,_righthandside_betaUnique,_righthandside_collectednotypedef,_righthandside_constraints,_righthandside_matchIO,_righthandside_oneLineTree,_righthandside_self,_righthandside_typeAnnotations,_righthandside_uniqueSecondRound) =
            (_righthandside (_lhs_allPatterns) (_pattern_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (findMono (head (keysFM _pattern_environment)) _lhs_monoTable ++ _lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _righthandside_betaUnique,_mybdggrp : _lhs_bindingGroups,_righthandside_collectednotypedef,_righthandside_matchIO,_oneLineTree,_self,_righthandside_typeAnnotations,_lhs_typeSignatures,_righthandside_uniqueSecondRound)
sem_Declaration_Type :: (T_Range) ->
                        (T_SimpleType) ->
                        (T_Type) ->
                        (T_Declaration)
sem_Declaration_Type (_range) (_simpletype) (_type) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_typeSignatures) (_lhs_uniqueSecondRound) =
    let (_self) =
            Declaration_Type _range_self _simpletype_self _type_self
        (_oneLineTree) =
            intErr "Declaration" "type"
        ( _range_self) =
            (_range )
        ( _simpletype_self) =
            (_simpletype )
        ( _type_self) =
            (_type )
    in  ( _lhs_betaUnique,_lhs_bindingGroups,_lhs_collectednotypedef,_lhs_matchIO,_oneLineTree,_self,_lhs_typeAnnotations,_lhs_typeSignatures,_lhs_uniqueSecondRound)
sem_Declaration_TypeSignature :: (T_Range) ->
                                 (T_Names) ->
                                 (T_Type) ->
                                 (T_Declaration)
sem_Declaration_TypeSignature (_range) (_names) (_type) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_typeSignatures) (_lhs_uniqueSecondRound) =
    let (_self) =
            Declaration_TypeSignature _range_self _names_self _type_self
        (_typeScheme) =
            makeTpSchemeFromType _type_self
        (_oneLineTree) =
            Node
                 [ Text (concat . intersperse "," . map show $ _names_self)
                 , Text " :: "
                 , Text (show (makeTpSchemeFromType _type_self))
                 ]
        ( _range_self) =
            (_range )
        ( _names_isIdentifier,_names_isOperator,_names_isSpecial,_names_oneLineTree,_names_self) =
            (_names )
        ( _type_self) =
            (_type )
    in  ( _lhs_betaUnique,_lhs_bindingGroups,_lhs_collectednotypedef,_lhs_matchIO,_oneLineTree,_self,_lhs_typeAnnotations,addListToFM _lhs_typeSignatures [ (name, _typeScheme) | name <- _names_self ],_lhs_uniqueSecondRound)
-- Declarations ------------------------------------------------
-- semantic domain
type T_Declarations = ([((Expression, [String]), Core_TypingStrategy)]) ->
                      (Int) ->
                      (BindingGroups) ->
                      ([(Name,Tps,Tp,Bool)]) ->
                      (ImportEnvironment) ->
                      (IO ()) ->
                      (MonoTable) ->
                      (Tps) ->
                      (TypeAnnotations) ->
                      (FiniteMap Name TpScheme) ->
                      (Int) ->
                      ( (Int),(BindingGroups),([(Name,Tps,Tp,Bool)]),(IO ()),( [ Tree] ),(Declarations),(TypeAnnotations),(FiniteMap Name TpScheme),(Int))
-- cata
sem_Declarations :: (Declarations) ->
                    (T_Declarations)
sem_Declarations (list) =
    (foldr (sem_Declarations_Cons) (sem_Declarations_Nil) ((map sem_Declaration list)))
sem_Declarations_Cons :: (T_Declaration) ->
                         (T_Declarations) ->
                         (T_Declarations)
sem_Declarations_Cons (_hd) (_tl) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_typeSignatures) (_lhs_uniqueSecondRound) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_betaUnique,_hd_bindingGroups,_hd_collectednotypedef,_hd_matchIO,_hd_oneLineTree,_hd_self,_hd_typeAnnotations,_hd_typeSignatures,_hd_uniqueSecondRound) =
            (_hd (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_typeSignatures) (_lhs_uniqueSecondRound))
        ( _tl_betaUnique,_tl_bindingGroups,_tl_collectednotypedef,_tl_matchIO,_tl_oneLineTree,_tl_self,_tl_typeAnnotations,_tl_typeSignatures,_tl_uniqueSecondRound) =
            (_tl (_lhs_allPatterns) (_hd_betaUnique) (_hd_bindingGroups) (_hd_collectednotypedef) (_lhs_importEnvironment) (_hd_matchIO) (_lhs_monoTable) (_lhs_monos) (_hd_typeAnnotations) (_hd_typeSignatures) (_hd_uniqueSecondRound))
    in  ( _tl_betaUnique,_tl_bindingGroups,_tl_collectednotypedef,_tl_matchIO,_hd_oneLineTree  :  _tl_oneLineTree,_self,_tl_typeAnnotations,_tl_typeSignatures,_tl_uniqueSecondRound)
sem_Declarations_Nil :: (T_Declarations)
sem_Declarations_Nil (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_bindingGroups) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monoTable) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_typeSignatures) (_lhs_uniqueSecondRound) =
    let (_self) =
            []
    in  ( _lhs_betaUnique,_lhs_bindingGroups,_lhs_collectednotypedef,_lhs_matchIO,[],_self,_lhs_typeAnnotations,_lhs_typeSignatures,_lhs_uniqueSecondRound)
-- Export ------------------------------------------------------
-- semantic domain
type T_Export = ( (Export))
-- cata
sem_Export :: (Export) ->
              (T_Export)
sem_Export ((Export_Module (_range) (_name))) =
    (sem_Export_Module ((sem_Range (_range))) ((sem_Name (_name))))
sem_Export ((Export_TypeOrClass (_range) (_name) (_names))) =
    (sem_Export_TypeOrClass ((sem_Range (_range))) ((sem_Name (_name))) ((sem_MaybeNames (_names))))
sem_Export ((Export_TypeOrClassComplete (_range) (_name))) =
    (sem_Export_TypeOrClassComplete ((sem_Range (_range))) ((sem_Name (_name))))
sem_Export ((Export_Variable (_range) (_name))) =
    (sem_Export_Variable ((sem_Range (_range))) ((sem_Name (_name))))
sem_Export_Module :: (T_Range) ->
                     (T_Name) ->
                     (T_Export)
sem_Export_Module (_range) (_name) =
    let (_self) =
            Export_Module _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( _self)
sem_Export_TypeOrClass :: (T_Range) ->
                          (T_Name) ->
                          (T_MaybeNames) ->
                          (T_Export)
sem_Export_TypeOrClass (_range) (_name) (_names) =
    let (_self) =
            Export_TypeOrClass _range_self _name_self _names_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _names_self) =
            (_names )
    in  ( _self)
sem_Export_TypeOrClassComplete :: (T_Range) ->
                                  (T_Name) ->
                                  (T_Export)
sem_Export_TypeOrClassComplete (_range) (_name) =
    let (_self) =
            Export_TypeOrClassComplete _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( _self)
sem_Export_Variable :: (T_Range) ->
                       (T_Name) ->
                       (T_Export)
sem_Export_Variable (_range) (_name) =
    let (_self) =
            Export_Variable _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( _self)
-- Exports -----------------------------------------------------
-- semantic domain
type T_Exports = ( (Exports))
-- cata
sem_Exports :: (Exports) ->
               (T_Exports)
sem_Exports (list) =
    (foldr (sem_Exports_Cons) (sem_Exports_Nil) ((map sem_Export list)))
sem_Exports_Cons :: (T_Export) ->
                    (T_Exports) ->
                    (T_Exports)
sem_Exports_Cons (_hd) (_tl) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  ( _self)
sem_Exports_Nil :: (T_Exports)
sem_Exports_Nil  =
    let (_self) =
            []
    in  ( _self)
-- Expression --------------------------------------------------
-- semantic domain
type T_Expression = ([((Expression, [String]), Core_TypingStrategy)]) ->
                    (Int) ->
                    ([(Name,Tps,Tp,Bool)]) ->
                    (ImportEnvironment) ->
                    (IO ()) ->
                    (Tps) ->
                    ([(Expression     , [String])]) ->
                    (TypeAnnotations) ->
                    (Int) ->
                    ( (Assumptions),(Tp),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(IO ()),([Maybe (MetaVariableTable MetaVariableInfo)]),(Tree),(Expression),(TypeAnnotations),(Int))
-- cata
sem_Expression :: (Expression) ->
                  (T_Expression)
sem_Expression ((Expression_Case (_range) (_expression) (_alternatives))) =
    (sem_Expression_Case ((sem_Range (_range))) ((sem_Expression (_expression))) ((sem_Alternatives (_alternatives))))
sem_Expression ((Expression_Comprehension (_range) (_expression) (_qualifiers))) =
    (sem_Expression_Comprehension ((sem_Range (_range))) ((sem_Expression (_expression))) ((sem_Qualifiers (_qualifiers))))
sem_Expression ((Expression_Constructor (_range) (_name))) =
    (sem_Expression_Constructor ((sem_Range (_range))) ((sem_Name (_name))))
sem_Expression ((Expression_Do (_range) (_statements))) =
    (sem_Expression_Do ((sem_Range (_range))) ((sem_Statements (_statements))))
sem_Expression ((Expression_Enum (_range) (_from) (_then) (_to))) =
    (sem_Expression_Enum ((sem_Range (_range))) ((sem_Expression (_from))) ((sem_MaybeExpression (_then))) ((sem_MaybeExpression (_to))))
sem_Expression ((Expression_If (_range) (_guardExpression) (_thenExpression) (_elseExpression))) =
    (sem_Expression_If ((sem_Range (_range))) ((sem_Expression (_guardExpression))) ((sem_Expression (_thenExpression))) ((sem_Expression (_elseExpression))))
sem_Expression ((Expression_InfixApplication (_range) (_leftExpression) (_operator) (_rightExpression))) =
    (sem_Expression_InfixApplication ((sem_Range (_range))) ((sem_MaybeExpression (_leftExpression))) ((sem_Expression (_operator))) ((sem_MaybeExpression (_rightExpression))))
sem_Expression ((Expression_Lambda (_range) (_patterns) (_expression))) =
    (sem_Expression_Lambda ((sem_Range (_range))) ((sem_Patterns (_patterns))) ((sem_Expression (_expression))))
sem_Expression ((Expression_Let (_range) (_declarations) (_expression))) =
    (sem_Expression_Let ((sem_Range (_range))) ((sem_Declarations (_declarations))) ((sem_Expression (_expression))))
sem_Expression ((Expression_List (_range) (_expressions))) =
    (sem_Expression_List ((sem_Range (_range))) ((sem_Expressions (_expressions))))
sem_Expression ((Expression_Literal (_range) (_literal))) =
    (sem_Expression_Literal ((sem_Range (_range))) ((sem_Literal (_literal))))
sem_Expression ((Expression_Negate (_range) (_expression))) =
    (sem_Expression_Negate ((sem_Range (_range))) ((sem_Expression (_expression))))
sem_Expression ((Expression_NegateFloat (_range) (_expression))) =
    (sem_Expression_NegateFloat ((sem_Range (_range))) ((sem_Expression (_expression))))
sem_Expression ((Expression_NormalApplication (_range) (_function) (_arguments))) =
    (sem_Expression_NormalApplication ((sem_Range (_range))) ((sem_Expression (_function))) ((sem_Expressions (_arguments))))
sem_Expression ((Expression_Parenthesized (_range) (_expression))) =
    (sem_Expression_Parenthesized ((sem_Range (_range))) ((sem_Expression (_expression))))
sem_Expression ((Expression_RecordConstruction (_range) (_name) (_recordExpressionBindings))) =
    (sem_Expression_RecordConstruction ((sem_Range (_range))) ((sem_Name (_name))) ((sem_RecordExpressionBindings (_recordExpressionBindings))))
sem_Expression ((Expression_RecordUpdate (_range) (_expression) (_recordExpressionBindings))) =
    (sem_Expression_RecordUpdate ((sem_Range (_range))) ((sem_Expression (_expression))) ((sem_RecordExpressionBindings (_recordExpressionBindings))))
sem_Expression ((Expression_Tuple (_range) (_expressions))) =
    (sem_Expression_Tuple ((sem_Range (_range))) ((sem_Expressions (_expressions))))
sem_Expression ((Expression_Typed (_range) (_expression) (_type))) =
    (sem_Expression_Typed ((sem_Range (_range))) ((sem_Expression (_expression))) ((sem_Type (_type))))
sem_Expression ((Expression_Variable (_range) (_name))) =
    (sem_Expression_Variable ((sem_Range (_range))) ((sem_Name (_name))))
sem_Expression_Case :: (T_Range) ->
                       (T_Expression) ->
                       (T_Alternatives) ->
                       (T_Expression)
sem_Expression_Case (_range) (_expression) (_alternatives) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Case _range_self _expression_self _alternatives_self
        (_constraints) =
            ctNode [ _newcon .<. _expression_constraints
                   , ctNode _alternatives_constraintslist
                   ]
        (_beta) =
            TVar _lhs_betaUnique
        (_beta') =
            TVar (_lhs_betaUnique + 1)
        (_newcon) =
            [ (_expression_beta .==. _beta') _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTExpression, AltCase, 0, "")
                  , location   = "scrutinee of case expression"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm _expression_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getExprRange _expression_self) ]
                  }
        (_oneLineTree) =
            Node
                [ Text "case "
                , Node [_expression_oneLineTree]
                , Text " of "
                , encloseSep "{" "; " "}" _alternatives_oneLineTree
                ]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        ( _range_self) =
            (_range )
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_self,_expression_typeAnnotations,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_lhs_betaUnique + 2) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) ([]) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _alternatives_assumptions,_alternatives_betaUnique,_alternatives_collectednotypedef,_alternatives_constraintslist,_alternatives_matchIO,_alternatives_oneLineTree,_alternatives_self,_alternatives_typeAnnotations,_alternatives_uniqueSecondRound) =
            (_alternatives (_lhs_allPatterns) (_beta') (_beta) (_expression_betaUnique) (_expression_collectednotypedef) (_lhs_importEnvironment) (_expression_matchIO) (_lhs_monos) (length _alternatives_constraintslist) (_expression_typeAnnotations) (_expression_uniqueSecondRound))
    in  ( _expression_assumptions `combine` _alternatives_assumptions,_beta,_alternatives_betaUnique,_alternatives_collectednotypedef,_constraints,_alternatives_matchIO,matchOnlyVariable _localInfo _lhs_tryPatterns,_oneLineTree,_self,_alternatives_typeAnnotations,_alternatives_uniqueSecondRound)
sem_Expression_Comprehension :: (T_Range) ->
                                (T_Expression) ->
                                (T_Qualifiers) ->
                                (T_Expression)
sem_Expression_Comprehension (_range) (_expression) (_qualifiers) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Comprehension _range_self _expression_self _qualifiers_self
        (_constraints) =
            _newcon .>. ctNode [ _qualifiers_constraints ]
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            [ (listType _expression_beta .==. _beta) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTExpression, AltComprehension, 0, "")
                  , location   = "list comprehension"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint ]
                  }
        (_oneLineTree) =
            Node
                [ Text "[ "
                , Node [_expression_oneLineTree]
                , Text " | "
                , Node [ punctuate ", " _qualifiers_oneLineTree ]
                , Text " ]"
                ]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        ( _range_self) =
            (_range )
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_self,_expression_typeAnnotations,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_qualifiers_monos) ([]) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _qualifiers_assumptions,_qualifiers_betaUnique,_qualifiers_collectednotypedef,_qualifiers_constraints,_qualifiers_matchIO,_qualifiers_monos,_qualifiers_oneLineTree,_qualifiers_self,_qualifiers_typeAnnotations,_qualifiers_uniqueSecondRound) =
            (_qualifiers (_lhs_allPatterns) (_expression_assumptions) (_expression_betaUnique) (_expression_collectednotypedef) (_expression_constraints) (_lhs_importEnvironment) (_expression_matchIO) (_lhs_monos) (_expression_typeAnnotations) (_expression_uniqueSecondRound))
    in  ( _qualifiers_assumptions,_beta,_qualifiers_betaUnique,_qualifiers_collectednotypedef,_constraints,_qualifiers_matchIO,matchOnlyVariable _localInfo _lhs_tryPatterns,_oneLineTree,_self,_qualifiers_typeAnnotations,_qualifiers_uniqueSecondRound)
sem_Expression_Constructor :: (T_Range) ->
                              (T_Name) ->
                              (T_Expression)
sem_Expression_Constructor (_range) (_name) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Constructor _range_self _name_self
        (_constraints) =
            ctSingle _newcon
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            case lookupFM (valueConstructors _lhs_importEnvironment) _name_self of
               Nothing  -> []
               Just ctp -> [ (_beta .::. ctp) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTExpression, AltConstructor, 0, "")
                  , location   = "constructor"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _name_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , HighlyTrusted
                                 , IsImported _name_self
                                 ]
                  }
        (_oneLineTree) =
            Node [_name_oneLineTree]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        (((),_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match0 _localInfo _lhs_uniqueSecondRound
                   (match_Expression_Constructor _name_self)
                   _lhs_tryPatterns _lhs_allPatterns
                   []
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( noAssumptions,_beta,_lhs_betaUnique + 1,_lhs_collectednotypedef,_newConstraintSet,_lhs_matchIO >> _ioMatch,_matches,_oneLineTree,_self,_lhs_typeAnnotations,_newUnique)
sem_Expression_Do :: (T_Range) ->
                     (T_Statements) ->
                     (T_Expression)
sem_Expression_Do (_range) (_statements) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Do _range_self _statements_self
        (_constraints) =
            ctEmpty
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            case _statements_generatorBeta of
               Nothing -> []
               Just b  -> [ (ioType b .==. _beta) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTExpression, AltDo, 0, "")
                  , location   = "do-expression"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint ]
                  }
        (_oneLineTree) =
            Node
                [ Text "do "
                , Node (sepBy (Text "; ") _statements_oneLineTree)
                ]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        ( _range_self) =
            (_range )
        ( _statements_assumptions,_statements_betaUnique,_statements_collectednotypedef,_statements_constraints,_statements_generatorBeta,_statements_matchIO,_statements_oneLineTree,_statements_self,_statements_typeAnnotations,_statements_uniqueSecondRound) =
            (_statements (_lhs_allPatterns) (noAssumptions) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_constraints) (Nothing) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _statements_assumptions,_beta,_statements_betaUnique,_statements_collectednotypedef,ctNode [ _newcon .<. _statements_constraints ],_statements_matchIO,matchOnlyVariable _localInfo _lhs_tryPatterns,_oneLineTree,_self,_statements_typeAnnotations,_statements_uniqueSecondRound)
sem_Expression_Enum :: (T_Range) ->
                       (T_Expression) ->
                       (T_MaybeExpression) ->
                       (T_MaybeExpression) ->
                       (T_Expression)
sem_Expression_Enum (_range) (_from) (_then) (_to) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Enum _range_self _from_self _then_self _to_self
        (_constraints) =
            [ (listType intType .==. _beta) _cinfoResult ] .>.
            ctNode [ _conFrom .<. _from_constraints
                   , _conThen .<. _then_constraints
                   , _conTo   .<. _to_constraints
                   ]
        (_beta) =
            TVar _lhs_betaUnique
        (_conFrom) =
            [ (_from_beta .==. intType) _cinfoFrom ]
        (_conThen) =
            [ (_then_beta .==. intType) _cinfoThen ]
        (_conTo) =
            [ (_to_beta   .==. intType) _cinfoTo   ]
        (_cinfoFrom) =
            \tppair ->
            CInfo { info       = (NTExpression, AltEnum, 0, "from")
                  , location   = "enumeration"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm _from_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getExprRange _from_self) ]
                  }
        (_cinfoThen) =
            \tppair ->
            CInfo { info       = (NTExpression, AltEnum, 1, "then")
                  , location   = "enumeration"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm (convertMaybeOneLineTree _then_oneLineTree) ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getMaybeExprRange _then_self) ]
                  }
        (_cinfoTo) =
            \tppair ->
            CInfo { info       = (NTExpression, AltEnum, 2, "to")
                  , location   = "enumeration"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm (convertMaybeOneLineTree _to_oneLineTree) ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getMaybeExprRange _to_self) ]
                  }
        (_cinfoResult) =
            \tppair ->
            CInfo { info       = (NTExpression, AltEnum, 3, "result")
                  , location   = "enumeration"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint ]
                  }
        (_oneLineTree) =
            Node (
                [ Text "["
                , Node [_from_oneLineTree]
                ]
                ++
                maybe [] (\x -> [Text ", ", x]) _then_oneLineTree
                ++
                [ Text " .. " ]
                ++
                maybe [] (\x -> [Node [x]]) _to_oneLineTree
                ++
                [ Text "]" ]
            )
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        (((_t1,_t2,_t3),_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match3 _localInfo _to_uniqueSecondRound
                   match_Expression_Enum
                   _lhs_tryPatterns _lhs_allPatterns
                   [_from_matches, _then_matches, _to_matches]
        ( _range_self) =
            (_range )
        ( _from_assumptions,_from_beta,_from_betaUnique,_from_collectednotypedef,_from_constraints,_from_matchIO,_from_matches,_from_oneLineTree,_from_self,_from_typeAnnotations,_from_uniqueSecondRound) =
            (_from (_lhs_allPatterns) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_t1) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _then_assumptions,_then_beta,_then_betaUnique,_then_collectednotypedef,_then_constraints,_then_matchIO,_then_matches,_then_oneLineTree,_then_section,_then_self,_then_typeAnnotations,_then_uniqueSecondRound) =
            (_then (_lhs_allPatterns) (_from_betaUnique) (_from_collectednotypedef) (_lhs_importEnvironment) (_from_matchIO) (_lhs_monos) (_t2) (_from_typeAnnotations) (_from_uniqueSecondRound))
        ( _to_assumptions,_to_beta,_to_betaUnique,_to_collectednotypedef,_to_constraints,_to_matchIO,_to_matches,_to_oneLineTree,_to_section,_to_self,_to_typeAnnotations,_to_uniqueSecondRound) =
            (_to (_lhs_allPatterns) (_then_betaUnique) (_then_collectednotypedef) (_lhs_importEnvironment) (_then_matchIO) (_lhs_monos) (_t3) (_then_typeAnnotations) (_then_uniqueSecondRound))
    in  ( _from_assumptions `combine` _then_assumptions `combine` _to_assumptions,_beta,_to_betaUnique,_to_collectednotypedef,_newConstraintSet,_to_matchIO >> _ioMatch,_matches,_oneLineTree,_self,_to_typeAnnotations,_newUnique)
sem_Expression_If :: (T_Range) ->
                     (T_Expression) ->
                     (T_Expression) ->
                     (T_Expression) ->
                     (T_Expression)
sem_Expression_If (_range) (_guardExpression) (_thenExpression) (_elseExpression) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_If _range_self _guardExpression_self _thenExpression_self _elseExpression_self
        (_constraints) =
            ctNode [ _conGuard .<. _guardExpression_constraints
                   , _conThen  .<. _thenExpression_constraints
                   , _conElse  .<. _elseExpression_constraints
                   ]
        (_beta) =
            TVar _lhs_betaUnique
        (_conGuard) =
            [ (_guardExpression_beta .==. boolType) _cinfoGuard ]
        (_conThen) =
            [ (_thenExpression_beta  .==. _beta   ) _cinfoThen  ]
        (_conElse) =
            [ (_elseExpression_beta  .==. _beta   ) _cinfoElse  ]
        (_cinfoGuard) =
            \tppair ->
            CInfo { info       = (NTExpression, AltIf, 0, "guard")
                  , location   = "conditional"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm _guardExpression_oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getExprRange _guardExpression_self) ]
                  }
        (_cinfoThen) =
            \tppair ->
            CInfo { info       = (NTExpression, AltIf, 1, "then")
                  , location   = "then branch of conditional"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm _thenExpression_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getExprRange _thenExpression_self)
                                 , Unifier (tpToInt _beta) ]
                  }
        (_cinfoElse) =
            \tppair ->
            CInfo { info       = (NTExpression, AltIf,2, "else")
                  , location   = "else branch of conditional"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm _elseExpression_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getExprRange _elseExpression_self)
                                 , Unifier (tpToInt _beta) ]
                  }
        (_oneLineTree) =
            Node
                [ Text "if "
                , Node [_guardExpression_oneLineTree]
                , Text " then "
                , Node [_thenExpression_oneLineTree]
                , Text " else "
                , Node [_elseExpression_oneLineTree]
                ]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        (((_t1,_t2,_t3),_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match3 _localInfo _elseExpression_uniqueSecondRound
                   match_Expression_If
                   _lhs_tryPatterns _lhs_allPatterns
                   [_guardExpression_matches,_thenExpression_matches,_elseExpression_matches]
        ( _range_self) =
            (_range )
        ( _guardExpression_assumptions,_guardExpression_beta,_guardExpression_betaUnique,_guardExpression_collectednotypedef,_guardExpression_constraints,_guardExpression_matchIO,_guardExpression_matches,_guardExpression_oneLineTree,_guardExpression_self,_guardExpression_typeAnnotations,_guardExpression_uniqueSecondRound) =
            (_guardExpression (_lhs_allPatterns) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_t1) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _thenExpression_assumptions,_thenExpression_beta,_thenExpression_betaUnique,_thenExpression_collectednotypedef,_thenExpression_constraints,_thenExpression_matchIO,_thenExpression_matches,_thenExpression_oneLineTree,_thenExpression_self,_thenExpression_typeAnnotations,_thenExpression_uniqueSecondRound) =
            (_thenExpression (_lhs_allPatterns) (_guardExpression_betaUnique) (_guardExpression_collectednotypedef) (_lhs_importEnvironment) (_guardExpression_matchIO) (_lhs_monos) (_t2) (_guardExpression_typeAnnotations) (_guardExpression_uniqueSecondRound))
        ( _elseExpression_assumptions,_elseExpression_beta,_elseExpression_betaUnique,_elseExpression_collectednotypedef,_elseExpression_constraints,_elseExpression_matchIO,_elseExpression_matches,_elseExpression_oneLineTree,_elseExpression_self,_elseExpression_typeAnnotations,_elseExpression_uniqueSecondRound) =
            (_elseExpression (_lhs_allPatterns) (_thenExpression_betaUnique) (_thenExpression_collectednotypedef) (_lhs_importEnvironment) (_thenExpression_matchIO) (_lhs_monos) (_t3) (_thenExpression_typeAnnotations) (_thenExpression_uniqueSecondRound))
    in  ( _guardExpression_assumptions `combine` _thenExpression_assumptions `combine` _elseExpression_assumptions,_beta,_elseExpression_betaUnique,_elseExpression_collectednotypedef,_newConstraintSet,_elseExpression_matchIO >> _ioMatch,_matches,_oneLineTree,_self,_elseExpression_typeAnnotations,_newUnique)
sem_Expression_InfixApplication :: (T_Range) ->
                                   (T_MaybeExpression) ->
                                   (T_Expression) ->
                                   (T_MaybeExpression) ->
                                   (T_Expression)
sem_Expression_InfixApplication (_range) (_leftExpression) (_operator) (_rightExpression) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_InfixApplication _range_self _leftExpression_self _operator_self _rightExpression_self
        (_constraints) =
            _conTotal .>.
            ctNode [ _operator_constraints
                   , _leftExpression_constraints
                   , _rightExpression_constraints
                   ]
        (_beta) =
            TVar _lhs_betaUnique
        (_betaResOp) =
            TVar (_lhs_betaUnique + 1)
        (_conOperator) =
            (_operator_beta .==. _leftExpression_beta .->. _rightExpression_beta .->. _betaResOp) _cinfoOperator
        (_conTotal) =
            case (_leftExpression_section,_rightExpression_section) of
                   (False,False) -> [ _conOperator, (_betaResOp     .==. _beta)                        _cinfoComplete     ]
                   (True ,True ) -> [               (_operator_beta .==. _beta)                        _cinfoEmpty        ]
                   (False,True ) -> [ _conOperator, (_rightExpression_beta .->. _betaResOp .==. _beta) _cinfoRightSection ]
                   (True ,False) -> [ _conOperator, (_leftExpression_beta  .->. _betaResOp .==. _beta) _cinfoLeftSection  ]
        (_cinfoOperator) =
            \tppair ->
            CInfo { info       = (NTExpression, AltInfixApplication, 0, "operator")
                  , location   = "infix application"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceOperator _operatorName ]
                  , typepair   = tppair
                  , properties = (if _leftExpression_section || _rightExpression_section
                                    then [ HighlyTrusted ]
                                    else [ ApplicationEdge True
                                                   [ ( convertMaybeOneLineTree _leftExpression_oneLineTree
                                                     , _leftExpression_beta
                                                     , getMaybeExprRange _leftExpression_self
                                                     )
                                                   , ( convertMaybeOneLineTree _rightExpression_oneLineTree
                                                     , _rightExpression_beta
                                                     , getMaybeExprRange _rightExpression_self
                                                     )
                                                   ] ])
                                 ++
                                 [ SubTermRange (getExprRange _operator_self) ]
                  }
        (_cinfoComplete) =
            \tppair ->
            CInfo { info       = (NTExpression, AltInfixApplication, 1, "")
                  , location   = "infix application (INTERNAL ERROR)"
                  , errorrange = _range_self
                  , sources    = [ ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , SuperHighlyTrusted
                                 ]
                  }
        (_cinfoLeftSection) =
            \tppair ->
            CInfo { info       = (NTExpression, AltInfixApplication, 2, "left")
                  , location   = "left section"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree ]
                  , typepair   = tppair
                  , properties = [ ]
                  }
        (_cinfoRightSection) =
            \tppair ->
            CInfo { info       = (NTExpression, AltInfixApplication, 3, "right")
                  , location   = "right section"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree ]
                  , typepair   = tppair
                  , properties = [ ]
                  }
        (_cinfoEmpty) =
            \tppair ->
            CInfo { info       = (NTExpression, AltInfixApplication, 4, "empty")
                  , location   = "infix application"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , HighlyTrusted
                                 ]
                  }
        (_operatorName) =
            oneLineTreeAsOperator _operator_oneLineTree
        (_oneLineTree) =
            case (_leftExpression_oneLineTree, _rightExpression_oneLineTree) of
                (Nothing, Nothing) -> parens _operatorName
                (Just l , Nothing) -> encloseSep "(" " " ")" [l, _operatorName]
                (Nothing, Just r ) -> encloseSep "(" " " ")" [_operatorName, r]
                (Just l , Just r ) -> Node [ l, Text " ", _operatorName, Text " ", r ]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        (((_t1,_t2,_t3),_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match3 _localInfo _rightExpression_uniqueSecondRound
                   match_Expression_InfixApplication
                   _lhs_tryPatterns _lhs_allPatterns
                   [_leftExpression_matches, _operator_matches,_rightExpression_matches]
        ( _range_self) =
            (_range )
        ( _leftExpression_assumptions,_leftExpression_beta,_leftExpression_betaUnique,_leftExpression_collectednotypedef,_leftExpression_constraints,_leftExpression_matchIO,_leftExpression_matches,_leftExpression_oneLineTree,_leftExpression_section,_leftExpression_self,_leftExpression_typeAnnotations,_leftExpression_uniqueSecondRound) =
            (_leftExpression (_lhs_allPatterns) (_lhs_betaUnique + 2) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_t1) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _operator_assumptions,_operator_beta,_operator_betaUnique,_operator_collectednotypedef,_operator_constraints,_operator_matchIO,_operator_matches,_operator_oneLineTree,_operator_self,_operator_typeAnnotations,_operator_uniqueSecondRound) =
            (_operator (_lhs_allPatterns) (_leftExpression_betaUnique) (_leftExpression_collectednotypedef) (_lhs_importEnvironment) (_leftExpression_matchIO) (_lhs_monos) (_t2) (_leftExpression_typeAnnotations) (_leftExpression_uniqueSecondRound))
        ( _rightExpression_assumptions,_rightExpression_beta,_rightExpression_betaUnique,_rightExpression_collectednotypedef,_rightExpression_constraints,_rightExpression_matchIO,_rightExpression_matches,_rightExpression_oneLineTree,_rightExpression_section,_rightExpression_self,_rightExpression_typeAnnotations,_rightExpression_uniqueSecondRound) =
            (_rightExpression (_lhs_allPatterns) (_operator_betaUnique) (_operator_collectednotypedef) (_lhs_importEnvironment) (_operator_matchIO) (_lhs_monos) (_t3) (_operator_typeAnnotations) (_operator_uniqueSecondRound))
    in  ( _leftExpression_assumptions `combine` _operator_assumptions `combine` _rightExpression_assumptions,_beta,_rightExpression_betaUnique,_rightExpression_collectednotypedef,_newConstraintSet,_rightExpression_matchIO >> _ioMatch,_matches,_oneLineTree,_self,_rightExpression_typeAnnotations,_newUnique)
sem_Expression_Lambda :: (T_Range) ->
                         (T_Patterns) ->
                         (T_Expression) ->
                         (T_Expression)
sem_Expression_Lambda (_range) (_patterns) (_expression) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Lambda _range_self _patterns_self _expression_self
        (_constraints) =
            _newcon .>. _csetBinds .>>.
            ctNode [ ctNode _patterns_constraintslist
                   , _expression_constraints
                   ]
        (_beta) =
            TVar _lhs_betaUnique
        ((_csetBinds,_assumptions')) =
            (_patterns_environment .===. _expression_assumptions) _cinfoBind
        (_newcon) =
            [ (foldr (.->.) _expression_beta _patterns_betas .==. _beta) _cinfoType ]
        (_cinfoBind) =
            variableBindingCInfo (NTExpression, AltLambda, 0)
        (_cinfoType) =
            \tppair ->
            CInfo { info       = (NTExpression, AltLambda, 1, "type")
                  , location   = "lambda abstraction"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint ]
                  }
        (_oneLineTree) =
            Node
                (  [ Text "\\", punctuate " " _patterns_oneLineTree, Text " -> "
                   , Node [_expression_oneLineTree]
                   ]
                )
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        ( _range_self) =
            (_range )
        ( _patterns_betaUnique,_patterns_betas,_patterns_constraintslist,_patterns_environment,_patterns_numberOfPatterns,_patterns_oneLineTree,_patterns_self) =
            (_patterns (_lhs_betaUnique + 1) (_lhs_importEnvironment))
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_self,_expression_typeAnnotations,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_patterns_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (eltsFM _patterns_environment ++ _lhs_monos) ([]) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _assumptions',_beta,_expression_betaUnique,_expression_collectednotypedef,_constraints,_expression_matchIO,matchOnlyVariable _localInfo _lhs_tryPatterns,_oneLineTree,_self,_expression_typeAnnotations,_expression_uniqueSecondRound)
sem_Expression_Let :: (T_Range) ->
                      (T_Declarations) ->
                      (T_Expression) ->
                      (T_Expression)
sem_Expression_Let (_range) (_declarations) (_expression) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Let _range_self _declarations_self _expression_self
        (_constraints) =
            [ (_expression_beta .==. _beta) _cinfoType ] .>. _cset
        (_beta) =
            TVar _lhs_betaUnique
        (_mybdggroup) =
            (noAssumptions,_expression_assumptions,[_expression_constraints])
        ((_aset,_cset,_monoTable)) =
            performBindingGroup _lhs_monos _declarations_typeSignatures (_mybdggroup : _declarations_bindingGroups)
        ((_anns,_notypedefs)) =
            findTypeAnnotations False _lhs_monos _declarations_typeSignatures (_mybdggroup : _declarations_bindingGroups)
        (_cinfoType) =
            \tppair ->
            CInfo { info       = (NTExpression, AltLet, 0, "")
                  , location   = "let expression (INTERNAL ERROR)"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm _expression_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , SuperHighlyTrusted
                                 , SubTermRange (getExprRange _expression_self)
                                 ]
                  }
        ((_collectTypeConstructors,_collectValueConstructors,_collectTypeSynonyms,_collectConstructorEnv,_derivedFunctions,_operatorFixities)) =
            internalError "PartialSyntax.ag" "n/a" "toplevel Expression"
        (_oneLineTree) =
            Node
                [ Text "let "
                , encloseSep "{" "; " "}" _declarations_oneLineTree
                , Text " in "
                , Node [_expression_oneLineTree]
                ]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        ( _range_self) =
            (_range )
        ( _declarations_betaUnique,_declarations_bindingGroups,_declarations_collectednotypedef,_declarations_matchIO,_declarations_oneLineTree,_declarations_self,_declarations_typeAnnotations,_declarations_typeSignatures,_declarations_uniqueSecondRound) =
            (_declarations (_lhs_allPatterns) (_lhs_betaUnique + 1) ([]) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_monoTable) (_lhs_monos) (_lhs_typeAnnotations) (emptyFM) (_lhs_uniqueSecondRound))
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_self,_expression_typeAnnotations,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_declarations_betaUnique) (_declarations_collectednotypedef) (_lhs_importEnvironment) (_declarations_matchIO) (_lhs_monos) ([]) (_declarations_typeAnnotations) (_declarations_uniqueSecondRound))
    in  ( _aset,_beta,_expression_betaUnique,_notypedefs ++ _declarations_collectednotypedef,_constraints,_expression_matchIO,matchOnlyVariable _localInfo _lhs_tryPatterns,_oneLineTree,_self,_anns ++ _expression_typeAnnotations,_expression_uniqueSecondRound)
sem_Expression_List :: (T_Range) ->
                       (T_Expressions) ->
                       (T_Expression)
sem_Expression_List (_range) (_expressions) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_List _range_self _expressions_self
        (_constraints) =
            _newcon .>.
             ctNode (zipWith3 _zipf _expressions_betas _childrenInfo _expressions_constraintslist)
        (_beta) =
            TVar _lhs_betaUnique
        (_beta') =
            TVar (_lhs_betaUnique + 1)
        (_newcon) =
            [ (listType _beta' .==. _beta) _cinfoResult ]
        (_childrenInfo) =
            zip _expressions_oneLineTree (map getExprRange _expressions_self)
        (_zipf) =
            \tp pair ctree -> [ (tp .==. _beta') (_cinfoElem pair) ] .<. ctree
        (_cinfoElem) =
            \(elemtext, elemrange) tppair ->
            CInfo { info       = (NTExpression, AltList, 0, "element")
                  , location   = "element of list"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm elemtext ]
                  , typepair   = tppair
                  , properties = [ SubTermRange elemrange ] ++
                                 if length _expressions_betas > 1 then [] else [ HighlyTrusted ]
                  }
        (_cinfoResult) =
            \tppair ->
            CInfo { info       = (NTExpression, AltList, 1, "result")
                  , location   = "list"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint ]
                  }
        (_oneLineTree) =
            encloseSep "[" ", " "]" _expressions_oneLineTree
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        ((_t1,_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match1 _localInfo _expressions_uniqueSecondRound
               match_Expression_List
               _lhs_tryPatterns _lhs_allPatterns
               [_expressions_matches]
        ( _range_self) =
            (_range )
        ( _expressions_assumptions,_expressions_betaUnique,_expressions_betas,_expressions_collectednotypedef,_expressions_constraintslist,_expressions_matchIO,_expressions_matches,_expressions_oneLineTree,_expressions_self,_expressions_typeAnnotations,_expressions_uniqueSecondRound) =
            (_expressions (_lhs_allPatterns) (_lhs_betaUnique + 2) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_t1) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _expressions_assumptions,_beta,_expressions_betaUnique,_expressions_collectednotypedef,_newConstraintSet,_expressions_matchIO,_matches,_oneLineTree,_self,_expressions_typeAnnotations,_newUnique)
sem_Expression_Literal :: (T_Range) ->
                          (T_Literal) ->
                          (T_Expression)
sem_Expression_Literal (_range) (_literal) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Literal _range_self _literal_self
        (_constraints) =
            ctSingle [ (_literal_literalType .==. _beta) _cinfo ]
        (_beta) =
            TVar _lhs_betaUnique
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTExpression, AltLiteral, 0, "")
                  , location   = "literal"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , HighlyTrusted
                                 , IsLiteral _literal_self
                                 ]
                  }
        (_oneLineTree) =
            Node [_literal_oneLineTree]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        (((),_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match0 _localInfo _lhs_uniqueSecondRound
                   (match_Expression_Literal _literal_self)
                   _lhs_tryPatterns _lhs_allPatterns
                   []
        ( _range_self) =
            (_range )
        ( _literal_literalType,_literal_oneLineTree,_literal_self) =
            (_literal )
    in  ( noAssumptions,_beta,_lhs_betaUnique + 1,_lhs_collectednotypedef,_newConstraintSet,_lhs_matchIO >> _ioMatch,_matches,_oneLineTree,_self,_lhs_typeAnnotations,_newUnique)
sem_Expression_Negate :: (T_Range) ->
                         (T_Expression) ->
                         (T_Expression)
sem_Expression_Negate (_range) (_expression) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Negate _range_self _expression_self
        (_constraints) =
            _newcon .>. ctNode [ _expression_constraints ]
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            [ (intType .->. intType .==. _expression_beta .->. _beta) _cinfo]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTExpression, AltNegate, 0, "")
                  , location   = "negation"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceOperator (Text "-") ]
                  , typepair   = tppair
                  , properties = [ Negation True ]
                  }
        (_oneLineTree) =
            Node [ Text "-", Node [_expression_oneLineTree] ]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        ((_t1,_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match1 _localInfo _expression_uniqueSecondRound
                   match_Expression_Negate
                   _lhs_tryPatterns _lhs_allPatterns
                   [_expression_matches]
        ( _range_self) =
            (_range )
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_self,_expression_typeAnnotations,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_t1) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _expression_assumptions,_beta,_expression_betaUnique,_expression_collectednotypedef,_newConstraintSet,_expression_matchIO >> _ioMatch,_matches,_oneLineTree,_self,_expression_typeAnnotations,_newUnique)
sem_Expression_NegateFloat :: (T_Range) ->
                              (T_Expression) ->
                              (T_Expression)
sem_Expression_NegateFloat (_range) (_expression) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_NegateFloat _range_self _expression_self
        (_constraints) =
            _newcon .>. ctNode [ _expression_constraints ]
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            [ (floatType .->. floatType .==. _expression_beta .->. _beta) _cinfo]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTExpression, AltNegateFloat, 0, "")
                  , location   = "negation"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceOperator (Text "-.") ]
                  , typepair   = tppair
                  , properties = [ Negation False ]
                  }
        (_oneLineTree) =
            Node [ Text "-.", Node [_expression_oneLineTree] ]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        ((_t1,_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match1 _localInfo _expression_uniqueSecondRound
                   match_Expression_NegateFloat
                   _lhs_tryPatterns _lhs_allPatterns
                   [_expression_matches]
        ( _range_self) =
            (_range )
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_self,_expression_typeAnnotations,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_t1) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _expression_assumptions,_beta,_expression_betaUnique,_expression_collectednotypedef,_newConstraintSet,_expression_matchIO >> _ioMatch,_matches,_oneLineTree,_self,_expression_typeAnnotations,_newUnique)
sem_Expression_NormalApplication :: (T_Range) ->
                                    (T_Expression) ->
                                    (T_Expressions) ->
                                    (T_Expression)
sem_Expression_NormalApplication (_range) (_function) (_arguments) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_NormalApplication _range_self _function_self _arguments_self
        (_constraints) =
            _newcon .>.
            ctNode [ _function_constraints
                   , ctNode _arguments_constraintslist
                   ]
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            [ (_function_beta .==. foldr (.->.) _beta _arguments_betas) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTExpression, AltNormalApplication, 0, "")
                  , location   = "application"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm _function_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ ApplicationEdge False (zip3 _arguments_oneLineTree
                                                               _arguments_betas
                                                               (map getExprRange _arguments_self)
                                                         )
                                 , SubTermRange (getExprRange _function_self)
                                 ]
                  }
        (_oneLineTree) =
            punctuate " " (_function_oneLineTree : _arguments_oneLineTree)
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        (((_t1,_t2),_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match2 _localInfo _arguments_uniqueSecondRound
                   match_Expression_NormalApplication
                   _lhs_tryPatterns _lhs_allPatterns
                   [_function_matches, _arguments_matches]
        ( _range_self) =
            (_range )
        ( _function_assumptions,_function_beta,_function_betaUnique,_function_collectednotypedef,_function_constraints,_function_matchIO,_function_matches,_function_oneLineTree,_function_self,_function_typeAnnotations,_function_uniqueSecondRound) =
            (_function (_lhs_allPatterns) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_t1) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _arguments_assumptions,_arguments_betaUnique,_arguments_betas,_arguments_collectednotypedef,_arguments_constraintslist,_arguments_matchIO,_arguments_matches,_arguments_oneLineTree,_arguments_self,_arguments_typeAnnotations,_arguments_uniqueSecondRound) =
            (_arguments (_lhs_allPatterns) (_function_betaUnique) (_function_collectednotypedef) (_lhs_importEnvironment) (_function_matchIO) (_lhs_monos) (_t2) (_function_typeAnnotations) (_function_uniqueSecondRound))
    in  ( _function_assumptions `combine` _arguments_assumptions,_beta,_arguments_betaUnique,_arguments_collectednotypedef,_newConstraintSet,_arguments_matchIO >> _ioMatch,_matches,_oneLineTree,_self,_arguments_typeAnnotations,_newUnique)
sem_Expression_Parenthesized :: (T_Range) ->
                                (T_Expression) ->
                                (T_Expression)
sem_Expression_Parenthesized (_range) (_expression) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Parenthesized _range_self _expression_self
        (_oneLineTree) =
            parens _expression_oneLineTree
        ( _range_self) =
            (_range )
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_self,_expression_typeAnnotations,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_matchIO,_expression_matches,_oneLineTree,_self,_expression_typeAnnotations,_expression_uniqueSecondRound)
sem_Expression_RecordConstruction :: (T_Range) ->
                                     (T_Name) ->
                                     (T_RecordExpressionBindings) ->
                                     (T_Expression)
sem_Expression_RecordConstruction (_range) (_name) (_recordExpressionBindings) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_RecordConstruction _range_self _name_self _recordExpressionBindings_self
        ((_assumptions,_constraints,_beta)) =
            internalError "PartialSyntax.ag" "n/a" "Expression.RecordConstruction"
        (_oneLineTree) =
            intErr "Expression" "record construction"
        (_matches) =
            undefined
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _recordExpressionBindings_collectednotypedef,_recordExpressionBindings_self,_recordExpressionBindings_typeAnnotations) =
            (_recordExpressionBindings (_lhs_collectednotypedef) (_lhs_typeAnnotations))
    in  ( _assumptions,_beta,_lhs_betaUnique,_recordExpressionBindings_collectednotypedef,_constraints,_lhs_matchIO,_matches,_oneLineTree,_self,_recordExpressionBindings_typeAnnotations,_lhs_uniqueSecondRound)
sem_Expression_RecordUpdate :: (T_Range) ->
                               (T_Expression) ->
                               (T_RecordExpressionBindings) ->
                               (T_Expression)
sem_Expression_RecordUpdate (_range) (_expression) (_recordExpressionBindings) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_RecordUpdate _range_self _expression_self _recordExpressionBindings_self
        (_oneLineTree) =
            intErr "Expression" "record update"
        ( _range_self) =
            (_range )
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_self,_expression_typeAnnotations,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _recordExpressionBindings_collectednotypedef,_recordExpressionBindings_self,_recordExpressionBindings_typeAnnotations) =
            (_recordExpressionBindings (_expression_collectednotypedef) (_expression_typeAnnotations))
    in  ( _expression_assumptions,_expression_beta,_expression_betaUnique,_recordExpressionBindings_collectednotypedef,_expression_constraints,_expression_matchIO,_expression_matches,_oneLineTree,_self,_recordExpressionBindings_typeAnnotations,_expression_uniqueSecondRound)
sem_Expression_Tuple :: (T_Range) ->
                        (T_Expressions) ->
                        (T_Expression)
sem_Expression_Tuple (_range) (_expressions) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Tuple _range_self _expressions_self
        (_constraints) =
            _newcon .>. ctNode _expressions_constraintslist
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            [ (tupleType _expressions_betas .==. _beta) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTExpression, AltTuple, 0, "")
                  , location   = "tuple"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , IsTupleEdge ]
                  }
        (_oneLineTree) =
            encloseSep "(" ", " ")" _expressions_oneLineTree
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        ((_t1,_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match1 _localInfo _expressions_uniqueSecondRound
                   match_Expression_Tuple
                   _lhs_tryPatterns _lhs_allPatterns
                   [_expressions_matches]
        ( _range_self) =
            (_range )
        ( _expressions_assumptions,_expressions_betaUnique,_expressions_betas,_expressions_collectednotypedef,_expressions_constraintslist,_expressions_matchIO,_expressions_matches,_expressions_oneLineTree,_expressions_self,_expressions_typeAnnotations,_expressions_uniqueSecondRound) =
            (_expressions (_lhs_allPatterns) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_t1) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _expressions_assumptions,_beta,_expressions_betaUnique,_expressions_collectednotypedef,_newConstraintSet,_expressions_matchIO >> _ioMatch,_matches,_oneLineTree,_self,_expressions_typeAnnotations,_newUnique)
sem_Expression_Typed :: (T_Range) ->
                        (T_Expression) ->
                        (T_Type) ->
                        (T_Expression)
sem_Expression_Typed (_range) (_expression) (_type) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Typed _range_self _expression_self _type_self
        (_constraints) =
            _conResult .>.
            ctNode [ _conExpr .<. _expression_constraints ]
        (_beta) =
            TVar _lhs_betaUnique
        (_typeScheme) =
            makeTpSchemeFromType _type_self
        (_conResult) =
            [ (_beta            .::. _typeScheme) _cinfoResult ]
        (_conExpr) =
            [ (_expression_beta .::. _typeScheme) _cinfoExpr   ]
        (_cinfoExpr) =
            \tppair ->
            CInfo { info       = (NTExpression, AltTyped, 0, "expression")
                  , location   = "type annotation"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm _expression_oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getExprRange _expression_self) ]
                  }
        (_cinfoResult) =
            \tppair ->
            CInfo { info       = (NTExpression, AltTyped, 1, "result")
                  , location   = "type annotation"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint ]
                  }
        (_oneLineTree) =
            Node
                [ Node [_expression_oneLineTree]
                , Text " :: "
                , Node [ Text (show (makeTpSchemeFromType _type_self))]
                ]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        ( _range_self) =
            (_range )
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_self,_expression_typeAnnotations,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) ([]) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _type_self) =
            (_type )
    in  ( _expression_assumptions,_beta,_expression_betaUnique,_expression_collectednotypedef,_constraints,_expression_matchIO,matchOnlyVariable _localInfo _lhs_tryPatterns,_oneLineTree,_self,((_lhs_monos,_expression_beta),_typeScheme,(_expression_oneLineTree,_range_self)) : _expression_typeAnnotations,_expression_uniqueSecondRound)
sem_Expression_Variable :: (T_Range) ->
                           (T_Name) ->
                           (T_Expression)
sem_Expression_Variable (_range) (_name) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Expression_Variable _range_self _name_self
        (_constraints) =
            ctNode [ ctVariable _lhs_betaUnique ]
        (_beta) =
            TVar _lhs_betaUnique
        (_oneLineTree) =
            Node [_name_oneLineTree]
        (_localInfo) =
            (_constraints, (_beta, _oneLineTree, _range_self))
        (((),_matches,_newConstraintSet,_newUnique,_ioMatch)) =
            match0 _localInfo _lhs_uniqueSecondRound
                   (match_Expression_Variable _name_self)
                   _lhs_tryPatterns _lhs_allPatterns
                   []
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( _name_self `single` _beta,_beta,_lhs_betaUnique + 1,_lhs_collectednotypedef,_newConstraintSet,_lhs_matchIO >> _ioMatch,_matches,_oneLineTree,_self,_lhs_typeAnnotations,_newUnique)
-- Expressions -------------------------------------------------
-- semantic domain
type T_Expressions = ([((Expression, [String]), Core_TypingStrategy)]) ->
                     (Int) ->
                     ([(Name,Tps,Tp,Bool)]) ->
                     (ImportEnvironment) ->
                     (IO ()) ->
                     (Tps) ->
                     ([(Expressions    , [String])]) ->
                     (TypeAnnotations) ->
                     (Int) ->
                     ( (Assumptions),(Int),(Tps),([(Name,Tps,Tp,Bool)]),(ConstraintSets),(IO ()),([Maybe (MetaVariableTable MetaVariableInfo)]),( [ Tree] ),(Expressions),(TypeAnnotations),(Int))
-- cata
sem_Expressions :: (Expressions) ->
                   (T_Expressions)
sem_Expressions (list) =
    (foldr (sem_Expressions_Cons) (sem_Expressions_Nil) ((map sem_Expression list)))
sem_Expressions_Cons :: (T_Expression) ->
                        (T_Expressions) ->
                        (T_Expressions)
sem_Expressions_Cons (_hd) (_tl) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            (:) _hd_self _tl_self
        (((_t1,_t2),_matches,_,_,_)) =
            match2' match_Expressions_Cons _lhs_tryPatterns [] [_hd_matches, _tl_matches]
        ( _hd_assumptions,_hd_beta,_hd_betaUnique,_hd_collectednotypedef,_hd_constraints,_hd_matchIO,_hd_matches,_hd_oneLineTree,_hd_self,_hd_typeAnnotations,_hd_uniqueSecondRound) =
            (_hd (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_t1) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _tl_assumptions,_tl_betaUnique,_tl_betas,_tl_collectednotypedef,_tl_constraintslist,_tl_matchIO,_tl_matches,_tl_oneLineTree,_tl_self,_tl_typeAnnotations,_tl_uniqueSecondRound) =
            (_tl (_lhs_allPatterns) (_hd_betaUnique) (_hd_collectednotypedef) (_lhs_importEnvironment) (_hd_matchIO) (_lhs_monos) (_t2) (_hd_typeAnnotations) (_hd_uniqueSecondRound))
    in  ( _hd_assumptions `combine` _tl_assumptions,_tl_betaUnique,_hd_beta : _tl_betas,_tl_collectednotypedef,_hd_constraints : _tl_constraintslist,_tl_matchIO,_matches,_hd_oneLineTree  :  _tl_oneLineTree,_self,_tl_typeAnnotations,_tl_uniqueSecondRound)
sem_Expressions_Nil :: (T_Expressions)
sem_Expressions_Nil (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            []
        (((),_matches,_,_,_)) =
            match0' match_Expressions_Nil _lhs_tryPatterns [] []
    in  ( noAssumptions,_lhs_betaUnique,[],_lhs_collectednotypedef,[],_lhs_matchIO,_matches,[],_self,_lhs_typeAnnotations,_lhs_uniqueSecondRound)
-- FieldDeclaration --------------------------------------------
-- semantic domain
type T_FieldDeclaration = ( (FieldDeclaration))
-- cata
sem_FieldDeclaration :: (FieldDeclaration) ->
                        (T_FieldDeclaration)
sem_FieldDeclaration ((FieldDeclaration_FieldDeclaration (_range) (_names) (_type))) =
    (sem_FieldDeclaration_FieldDeclaration ((sem_Range (_range))) ((sem_Names (_names))) ((sem_AnnotatedType (_type))))
sem_FieldDeclaration_FieldDeclaration :: (T_Range) ->
                                         (T_Names) ->
                                         (T_AnnotatedType) ->
                                         (T_FieldDeclaration)
sem_FieldDeclaration_FieldDeclaration (_range) (_names) (_type) =
    let (_self) =
            FieldDeclaration_FieldDeclaration _range_self _names_self _type_self
        ((_kindErrors,_tyconEnv,_constructorenv,_importEnvironment,_valueConstructors,_allValueConstructors,_typeConstructors,_allTypeConstructors)) =
            internalError "PartialSyntax.ag" "n/a" "FieldDeclaration.FieldDeclaration"
        ( _range_self) =
            (_range )
        ( _names_isIdentifier,_names_isOperator,_names_isSpecial,_names_oneLineTree,_names_self) =
            (_names )
        ( _type_self) =
            (_type )
    in  ( _self)
-- FieldDeclarations -------------------------------------------
-- semantic domain
type T_FieldDeclarations = ( (FieldDeclarations))
-- cata
sem_FieldDeclarations :: (FieldDeclarations) ->
                         (T_FieldDeclarations)
sem_FieldDeclarations (list) =
    (foldr (sem_FieldDeclarations_Cons) (sem_FieldDeclarations_Nil) ((map sem_FieldDeclaration list)))
sem_FieldDeclarations_Cons :: (T_FieldDeclaration) ->
                              (T_FieldDeclarations) ->
                              (T_FieldDeclarations)
sem_FieldDeclarations_Cons (_hd) (_tl) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  ( _self)
sem_FieldDeclarations_Nil :: (T_FieldDeclarations)
sem_FieldDeclarations_Nil  =
    let (_self) =
            []
    in  ( _self)
-- Fixity ------------------------------------------------------
-- semantic domain
type T_Fixity = ( (Fixity))
-- cata
sem_Fixity :: (Fixity) ->
              (T_Fixity)
sem_Fixity ((Fixity_Infix (_range))) =
    (sem_Fixity_Infix ((sem_Range (_range))))
sem_Fixity ((Fixity_Infixl (_range))) =
    (sem_Fixity_Infixl ((sem_Range (_range))))
sem_Fixity ((Fixity_Infixr (_range))) =
    (sem_Fixity_Infixr ((sem_Range (_range))))
sem_Fixity_Infix :: (T_Range) ->
                    (T_Fixity)
sem_Fixity_Infix (_range) =
    let (_self) =
            Fixity_Infix _range_self
        ( _range_self) =
            (_range )
    in  ( _self)
sem_Fixity_Infixl :: (T_Range) ->
                     (T_Fixity)
sem_Fixity_Infixl (_range) =
    let (_self) =
            Fixity_Infixl _range_self
        ( _range_self) =
            (_range )
    in  ( _self)
sem_Fixity_Infixr :: (T_Range) ->
                     (T_Fixity)
sem_Fixity_Infixr (_range) =
    let (_self) =
            Fixity_Infixr _range_self
        ( _range_self) =
            (_range )
    in  ( _self)
-- FunctionBinding ---------------------------------------------
-- semantic domain
type T_FunctionBinding = ([((Expression, [String]), Core_TypingStrategy)]) ->
                         (Tp) ->
                         (Int) ->
                         (Tps) ->
                         ([(Name,Tps,Tp,Bool)]) ->
                         (ImportEnvironment) ->
                         (IO ()) ->
                         (Tps) ->
                         (TypeAnnotations) ->
                         (Int) ->
                         ( (Assumptions),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(IO ()),(Name),(Int),(Tree),(FunctionBinding),(TypeAnnotations),(Int))
-- cata
sem_FunctionBinding :: (FunctionBinding) ->
                       (T_FunctionBinding)
sem_FunctionBinding ((FunctionBinding_FunctionBinding (_range) (_lefthandside) (_righthandside))) =
    (sem_FunctionBinding_FunctionBinding ((sem_Range (_range))) ((sem_LeftHandSide (_lefthandside))) ((sem_RightHandSide (_righthandside))))
sem_FunctionBinding_FunctionBinding :: (T_Range) ->
                                       (T_LeftHandSide) ->
                                       (T_RightHandSide) ->
                                       (T_FunctionBinding)
sem_FunctionBinding_FunctionBinding (_range) (_lefthandside) (_righthandside) (_lhs_allPatterns) (_lhs_betaRight) (_lhs_betaUnique) (_lhs_betasLeft) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            FunctionBinding_FunctionBinding _range_self _lefthandside_self _righthandside_self
        ((_csetBinds,_assumptions')) =
            (_lefthandside_environment .===. _righthandside_assumptions) _cinfoBind
        (_conLeft) =
            zipWith4 (\t1 t2 txt nr -> (t1 .==. t2) (_cinfoLeft nr txt)) _lefthandside_betas _lhs_betasLeft _lefthandside_patternTrees [0..]
        (_conRight) =
            [ (_righthandside_beta .==. _lhs_betaRight) _cinfoRight ]
        (_cinfoLeft) =
            \num txt tppair ->
            CInfo { info       = (NTFunctionBinding, AltFunctionBinding, 0, "left "++show num)
                  , location   = "pattern of function binding"
                  , errorrange = _range_self
                  , sources    = [ sourcePattern txt ]
                  , typepair   = tppair
                  , properties = [ ]
                  }
        (_cinfoRight) =
            \tppair ->
            CInfo { info       = (NTFunctionBinding, AltFunctionBinding, 1, "right")
                  , location   = "right hand side"
                  , errorrange = _range_self
                  , sources    = [ sourceTerm (_righthandside_oneLineTree "") ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getRHSRange _righthandside_self) ]
                  }
        (_cinfoBind) =
            variableBindingCInfo (NTFunctionBinding, AltFunctionBinding, 2)
        (_oneLineTree) =
            Node [_lefthandside_oneLineTree, _righthandside_oneLineTree " = " ]
        ( _range_self) =
            (_range )
        ( _lefthandside_betaUnique,_lefthandside_betas,_lefthandside_constraints,_lefthandside_environment,_lefthandside_name,_lefthandside_numberOfPatterns,_lefthandside_oneLineTree,_lefthandside_patternTrees,_lefthandside_self) =
            (_lefthandside (_lhs_betaUnique) (_lhs_importEnvironment))
        ( _righthandside_assumptions,_righthandside_beta,_righthandside_betaUnique,_righthandside_collectednotypedef,_righthandside_constraints,_righthandside_matchIO,_righthandside_oneLineTree,_righthandside_self,_righthandside_typeAnnotations,_righthandside_uniqueSecondRound) =
            (_righthandside (_lhs_allPatterns) (_lefthandside_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (eltsFM _lefthandside_environment ++ _lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _assumptions'
         ,_righthandside_betaUnique
         ,_righthandside_collectednotypedef
         ,_csetBinds .>>.
          ctNode [ _conLeft  .<. _lefthandside_constraints
                 , _conRight .<. _righthandside_constraints
                 ]
         ,_righthandside_matchIO
         ,_lefthandside_name
         ,_lefthandside_numberOfPatterns
         ,_oneLineTree
         ,_self
         ,_righthandside_typeAnnotations
         ,_righthandside_uniqueSecondRound
         )
-- FunctionBindings --------------------------------------------
-- semantic domain
type T_FunctionBindings = ([((Expression, [String]), Core_TypingStrategy)]) ->
                          (Tp) ->
                          (Int) ->
                          (Tps) ->
                          ([(Name,Tps,Tp,Bool)]) ->
                          (ImportEnvironment) ->
                          (IO ()) ->
                          (Tps) ->
                          (TypeAnnotations) ->
                          (Int) ->
                          ( (Assumptions),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSets),(IO ()),(Name),(Int),( [ Tree] ),(FunctionBindings),(TypeAnnotations),(Int))
-- cata
sem_FunctionBindings :: (FunctionBindings) ->
                        (T_FunctionBindings)
sem_FunctionBindings (list) =
    (foldr (sem_FunctionBindings_Cons) (sem_FunctionBindings_Nil) ((map sem_FunctionBinding list)))
sem_FunctionBindings_Cons :: (T_FunctionBinding) ->
                             (T_FunctionBindings) ->
                             (T_FunctionBindings)
sem_FunctionBindings_Cons (_hd) (_tl) (_lhs_allPatterns) (_lhs_betaRight) (_lhs_betaUnique) (_lhs_betasLeft) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_assumptions,_hd_betaUnique,_hd_collectednotypedef,_hd_constraints,_hd_matchIO,_hd_name,_hd_numberOfPatterns,_hd_oneLineTree,_hd_self,_hd_typeAnnotations,_hd_uniqueSecondRound) =
            (_hd (_lhs_allPatterns) (_lhs_betaRight) (_lhs_betaUnique) (_lhs_betasLeft) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _tl_assumptions,_tl_betaUnique,_tl_collectednotypedef,_tl_constraintslist,_tl_matchIO,_tl_name,_tl_numberOfPatterns,_tl_oneLineTree,_tl_self,_tl_typeAnnotations,_tl_uniqueSecondRound) =
            (_tl (_lhs_allPatterns) (_lhs_betaRight) (_hd_betaUnique) (_lhs_betasLeft) (_hd_collectednotypedef) (_lhs_importEnvironment) (_hd_matchIO) (_lhs_monos) (_hd_typeAnnotations) (_hd_uniqueSecondRound))
    in  ( _hd_assumptions `combine` _tl_assumptions,_tl_betaUnique,_tl_collectednotypedef,_hd_constraints : _tl_constraintslist,_tl_matchIO,_hd_name,_hd_numberOfPatterns,_hd_oneLineTree  :  _tl_oneLineTree,_self,_tl_typeAnnotations,_tl_uniqueSecondRound)
sem_FunctionBindings_Nil :: (T_FunctionBindings)
sem_FunctionBindings_Nil (_lhs_allPatterns) (_lhs_betaRight) (_lhs_betaUnique) (_lhs_betasLeft) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            []
    in  ( noAssumptions,_lhs_betaUnique,_lhs_collectednotypedef,[],_lhs_matchIO,internalError "TypeInferencing.ag" "n/a" "FunctionBindings(2)",internalError "TypeInferencing.ag" "n/a" "FunctionBindings(1)",[],_self,_lhs_typeAnnotations,_lhs_uniqueSecondRound)
-- GuardedExpression -------------------------------------------
-- semantic domain
type T_GuardedExpression = ([((Expression, [String]), Core_TypingStrategy)]) ->
                           (Int) ->
                           ([(Name,Tps,Tp,Bool)]) ->
                           (ImportEnvironment) ->
                           (IO ()) ->
                           (Tps) ->
                           (Int) ->
                           (Tp) ->
                           (TypeAnnotations) ->
                           (Int) ->
                           ( (Assumptions),(Tp),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(IO ()),( String -> Tree ),(GuardedExpression),(TypeAnnotations),(Int))
-- cata
sem_GuardedExpression :: (GuardedExpression) ->
                         (T_GuardedExpression)
sem_GuardedExpression ((GuardedExpression_GuardedExpression (_range) (_guard) (_expression))) =
    (sem_GuardedExpression_GuardedExpression ((sem_Range (_range))) ((sem_Expression (_guard))) ((sem_Expression (_expression))))
sem_GuardedExpression_GuardedExpression :: (T_Range) ->
                                           (T_Expression) ->
                                           (T_Expression) ->
                                           (T_GuardedExpression)
sem_GuardedExpression_GuardedExpression (_range) (_guard) (_expression) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_numberOfGuards) (_lhs_rightBeta) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            GuardedExpression_GuardedExpression _range_self _guard_self _expression_self
        (_newconGuard) =
            [ (_guard_beta .==. boolType) _cinfoGuard ]
        (_newconExpr) =
            [ (_expression_beta .==. _lhs_rightBeta) _cinfoExpr ]
        (_cinfoGuard) =
            \tppair ->
            CInfo { info       = (NTGuardedExpression, AltGuardedExpression, 0, "guard")
                  , location   = "guard"
                  , errorrange = getExprRange _guard_self
                  , sources    = [ sourceExpression _guard_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ ]
                  }
        (_cinfoExpr) =
            \tppair ->
            CInfo { info       = (NTGuardedExpression, AltGuardedExpression, 1, "expression")
                  , location   = "guarded expression"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _expression_oneLineTree ]
                  , typepair   = tppair
                  , properties = if _lhs_numberOfGuards > 1 then [] else [ HighlyTrusted ]
                  }
        (_oneLineTree) =
            \assign -> Node [ _guard_oneLineTree, Text assign, _expression_oneLineTree ]
        ( _range_self) =
            (_range )
        ( _guard_assumptions,_guard_beta,_guard_betaUnique,_guard_collectednotypedef,_guard_constraints,_guard_matchIO,_guard_matches,_guard_oneLineTree,_guard_self,_guard_typeAnnotations,_guard_uniqueSecondRound) =
            (_guard (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) ([]) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_self,_expression_typeAnnotations,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_guard_betaUnique) (_guard_collectednotypedef) (_lhs_importEnvironment) (_guard_matchIO) (_lhs_monos) ([]) (_guard_typeAnnotations) (_guard_uniqueSecondRound))
    in  ( _guard_assumptions `combine` _expression_assumptions
         ,_expression_beta
         ,_expression_betaUnique
         ,_expression_collectednotypedef
         ,ctNode [ _newconGuard .<. _guard_constraints
                 , _newconExpr  .<. _expression_constraints
                 ]
         ,_expression_matchIO
         ,_oneLineTree
         ,_self
         ,_expression_typeAnnotations
         ,_expression_uniqueSecondRound
         )
-- GuardedExpressions ------------------------------------------
-- semantic domain
type T_GuardedExpressions = ([((Expression, [String]), Core_TypingStrategy)]) ->
                            (Int) ->
                            ([(Name,Tps,Tp,Bool)]) ->
                            (ImportEnvironment) ->
                            (IO ()) ->
                            (Tps) ->
                            (Int) ->
                            (Tp) ->
                            (TypeAnnotations) ->
                            (Int) ->
                            ( (Assumptions),(Int),(Tps),([(Name,Tps,Tp,Bool)]),(ConstraintSets),(IO ()),( [ String -> Tree ] ),(GuardedExpressions),(TypeAnnotations),(Int))
-- cata
sem_GuardedExpressions :: (GuardedExpressions) ->
                          (T_GuardedExpressions)
sem_GuardedExpressions (list) =
    (foldr (sem_GuardedExpressions_Cons) (sem_GuardedExpressions_Nil) ((map sem_GuardedExpression list)))
sem_GuardedExpressions_Cons :: (T_GuardedExpression) ->
                               (T_GuardedExpressions) ->
                               (T_GuardedExpressions)
sem_GuardedExpressions_Cons (_hd) (_tl) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_numberOfGuards) (_lhs_rightBeta) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_assumptions,_hd_beta,_hd_betaUnique,_hd_collectednotypedef,_hd_constraints,_hd_matchIO,_hd_oneLineTree,_hd_self,_hd_typeAnnotations,_hd_uniqueSecondRound) =
            (_hd (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_numberOfGuards) (_lhs_rightBeta) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _tl_assumptions,_tl_betaUnique,_tl_betas,_tl_collectednotypedef,_tl_constraintslist,_tl_matchIO,_tl_oneLineTree,_tl_self,_tl_typeAnnotations,_tl_uniqueSecondRound) =
            (_tl (_lhs_allPatterns) (_hd_betaUnique) (_hd_collectednotypedef) (_lhs_importEnvironment) (_hd_matchIO) (_lhs_monos) (_lhs_numberOfGuards) (_lhs_rightBeta) (_hd_typeAnnotations) (_hd_uniqueSecondRound))
    in  ( _hd_assumptions `combine` _tl_assumptions,_tl_betaUnique,_hd_beta : _tl_betas,_tl_collectednotypedef,_hd_constraints : _tl_constraintslist,_tl_matchIO,_hd_oneLineTree  :  _tl_oneLineTree,_self,_tl_typeAnnotations,_tl_uniqueSecondRound)
sem_GuardedExpressions_Nil :: (T_GuardedExpressions)
sem_GuardedExpressions_Nil (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_numberOfGuards) (_lhs_rightBeta) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            []
    in  ( noAssumptions,_lhs_betaUnique,[],_lhs_collectednotypedef,[],_lhs_matchIO,[],_self,_lhs_typeAnnotations,_lhs_uniqueSecondRound)
-- Import ------------------------------------------------------
-- semantic domain
type T_Import = ( (Import))
-- cata
sem_Import :: (Import) ->
              (T_Import)
sem_Import ((Import_TypeOrClass (_range) (_name) (_names))) =
    (sem_Import_TypeOrClass ((sem_Range (_range))) ((sem_Name (_name))) ((sem_MaybeNames (_names))))
sem_Import ((Import_TypeOrClassComplete (_range) (_name))) =
    (sem_Import_TypeOrClassComplete ((sem_Range (_range))) ((sem_Name (_name))))
sem_Import ((Import_Variable (_range) (_name))) =
    (sem_Import_Variable ((sem_Range (_range))) ((sem_Name (_name))))
sem_Import_TypeOrClass :: (T_Range) ->
                          (T_Name) ->
                          (T_MaybeNames) ->
                          (T_Import)
sem_Import_TypeOrClass (_range) (_name) (_names) =
    let (_self) =
            Import_TypeOrClass _range_self _name_self _names_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _names_self) =
            (_names )
    in  ( _self)
sem_Import_TypeOrClassComplete :: (T_Range) ->
                                  (T_Name) ->
                                  (T_Import)
sem_Import_TypeOrClassComplete (_range) (_name) =
    let (_self) =
            Import_TypeOrClassComplete _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( _self)
sem_Import_Variable :: (T_Range) ->
                       (T_Name) ->
                       (T_Import)
sem_Import_Variable (_range) (_name) =
    let (_self) =
            Import_Variable _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( _self)
-- ImportDeclaration -------------------------------------------
-- semantic domain
type T_ImportDeclaration = ( (ImportDeclaration))
-- cata
sem_ImportDeclaration :: (ImportDeclaration) ->
                         (T_ImportDeclaration)
sem_ImportDeclaration ((ImportDeclaration_Empty (_range))) =
    (sem_ImportDeclaration_Empty ((sem_Range (_range))))
sem_ImportDeclaration ((ImportDeclaration_Import (_range) (_qualified) (_name) (_asname) (_importspecification))) =
    (sem_ImportDeclaration_Import ((sem_Range (_range))) (_qualified) ((sem_Name (_name))) ((sem_MaybeName (_asname))) ((sem_MaybeImportSpecification (_importspecification))))
sem_ImportDeclaration_Empty :: (T_Range) ->
                               (T_ImportDeclaration)
sem_ImportDeclaration_Empty (_range) =
    let (_self) =
            ImportDeclaration_Empty _range_self
        ( _range_self) =
            (_range )
    in  ( _self)
sem_ImportDeclaration_Import :: (T_Range) ->
                                (Bool) ->
                                (T_Name) ->
                                (T_MaybeName) ->
                                (T_MaybeImportSpecification) ->
                                (T_ImportDeclaration)
sem_ImportDeclaration_Import (_range) (_qualified) (_name) (_asname) (_importspecification) =
    let (_self) =
            ImportDeclaration_Import _range_self _qualified _name_self _asname_self _importspecification_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _asname_self) =
            (_asname )
        ( _importspecification_self) =
            (_importspecification )
    in  ( _self)
-- ImportDeclarations ------------------------------------------
-- semantic domain
type T_ImportDeclarations = ( (ImportDeclarations))
-- cata
sem_ImportDeclarations :: (ImportDeclarations) ->
                          (T_ImportDeclarations)
sem_ImportDeclarations (list) =
    (foldr (sem_ImportDeclarations_Cons) (sem_ImportDeclarations_Nil) ((map sem_ImportDeclaration list)))
sem_ImportDeclarations_Cons :: (T_ImportDeclaration) ->
                               (T_ImportDeclarations) ->
                               (T_ImportDeclarations)
sem_ImportDeclarations_Cons (_hd) (_tl) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  ( _self)
sem_ImportDeclarations_Nil :: (T_ImportDeclarations)
sem_ImportDeclarations_Nil  =
    let (_self) =
            []
    in  ( _self)
-- ImportSpecification -----------------------------------------
-- semantic domain
type T_ImportSpecification = ( (ImportSpecification))
-- cata
sem_ImportSpecification :: (ImportSpecification) ->
                           (T_ImportSpecification)
sem_ImportSpecification ((ImportSpecification_Import (_range) (_hiding) (_imports))) =
    (sem_ImportSpecification_Import ((sem_Range (_range))) (_hiding) ((sem_Imports (_imports))))
sem_ImportSpecification_Import :: (T_Range) ->
                                  (Bool) ->
                                  (T_Imports) ->
                                  (T_ImportSpecification)
sem_ImportSpecification_Import (_range) (_hiding) (_imports) =
    let (_self) =
            ImportSpecification_Import _range_self _hiding _imports_self
        ( _range_self) =
            (_range )
        ( _imports_self) =
            (_imports )
    in  ( _self)
-- Imports -----------------------------------------------------
-- semantic domain
type T_Imports = ( (Imports))
-- cata
sem_Imports :: (Imports) ->
               (T_Imports)
sem_Imports (list) =
    (foldr (sem_Imports_Cons) (sem_Imports_Nil) ((map sem_Import list)))
sem_Imports_Cons :: (T_Import) ->
                    (T_Imports) ->
                    (T_Imports)
sem_Imports_Cons (_hd) (_tl) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  ( _self)
sem_Imports_Nil :: (T_Imports)
sem_Imports_Nil  =
    let (_self) =
            []
    in  ( _self)
-- LeftHandSide ------------------------------------------------
-- semantic domain
type T_LeftHandSide = (Int) ->
                      (ImportEnvironment) ->
                      ( (Int),(Tps),(ConstraintSet),(PatternAssumptions),(Name),(Int),(Tree),([Tree]),(LeftHandSide))
-- cata
sem_LeftHandSide :: (LeftHandSide) ->
                    (T_LeftHandSide)
sem_LeftHandSide ((LeftHandSide_Function (_range) (_name) (_patterns))) =
    (sem_LeftHandSide_Function ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Patterns (_patterns))))
sem_LeftHandSide ((LeftHandSide_Infix (_range) (_leftPattern) (_operator) (_rightPattern))) =
    (sem_LeftHandSide_Infix ((sem_Range (_range))) ((sem_Pattern (_leftPattern))) ((sem_Name (_operator))) ((sem_Pattern (_rightPattern))))
sem_LeftHandSide ((LeftHandSide_Parenthesized (_range) (_lefthandside) (_patterns))) =
    (sem_LeftHandSide_Parenthesized ((sem_Range (_range))) ((sem_LeftHandSide (_lefthandside))) ((sem_Patterns (_patterns))))
sem_LeftHandSide_Function :: (T_Range) ->
                             (T_Name) ->
                             (T_Patterns) ->
                             (T_LeftHandSide)
sem_LeftHandSide_Function (_range) (_name) (_patterns) (_lhs_betaUnique) (_lhs_importEnvironment) =
    let (_self) =
            LeftHandSide_Function _range_self _name_self _patterns_self
        (_oneLineTree) =
            punctuate " " (_name_oneLineTree : _patterns_oneLineTree)
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _patterns_betaUnique,_patterns_betas,_patterns_constraintslist,_patterns_environment,_patterns_numberOfPatterns,_patterns_oneLineTree,_patterns_self) =
            (_patterns (_lhs_betaUnique) (_lhs_importEnvironment))
    in  ( _patterns_betaUnique,_patterns_betas,ctNode _patterns_constraintslist,_patterns_environment,_name_self,_patterns_numberOfPatterns,_oneLineTree,_patterns_oneLineTree,_self)
sem_LeftHandSide_Infix :: (T_Range) ->
                          (T_Pattern) ->
                          (T_Name) ->
                          (T_Pattern) ->
                          (T_LeftHandSide)
sem_LeftHandSide_Infix (_range) (_leftPattern) (_operator) (_rightPattern) (_lhs_betaUnique) (_lhs_importEnvironment) =
    let (_self) =
            LeftHandSide_Infix _range_self _leftPattern_self _operator_self _rightPattern_self
        (_operatorName) =
            oneLineTreeAsOperator _operator_oneLineTree
        (_oneLineTree) =
            punctuate " " [_leftPattern_oneLineTree, _operatorName, _rightPattern_oneLineTree]
        ( _range_self) =
            (_range )
        ( _leftPattern_beta,_leftPattern_betaUnique,_leftPattern_constraints,_leftPattern_environment,_leftPattern_oneLineTree,_leftPattern_self) =
            (_leftPattern (_lhs_betaUnique) (_lhs_importEnvironment))
        ( _operator_isIdentifier,_operator_isOperator,_operator_isSpecial,_operator_oneLineTree,_operator_self) =
            (_operator )
        ( _rightPattern_beta,_rightPattern_betaUnique,_rightPattern_constraints,_rightPattern_environment,_rightPattern_oneLineTree,_rightPattern_self) =
            (_rightPattern (_leftPattern_betaUnique) (_lhs_importEnvironment))
    in  ( _rightPattern_betaUnique
         ,[_leftPattern_beta,_rightPattern_beta]
         ,ctNode [ _leftPattern_constraints
                 , _rightPattern_constraints
                 ]
         ,_leftPattern_environment `plusFM` _rightPattern_environment
         ,_operator_self
         ,2
         ,_oneLineTree
         ,[_leftPattern_oneLineTree, _rightPattern_oneLineTree]
         ,_self
         )
sem_LeftHandSide_Parenthesized :: (T_Range) ->
                                  (T_LeftHandSide) ->
                                  (T_Patterns) ->
                                  (T_LeftHandSide)
sem_LeftHandSide_Parenthesized (_range) (_lefthandside) (_patterns) (_lhs_betaUnique) (_lhs_importEnvironment) =
    let (_self) =
            LeftHandSide_Parenthesized _range_self _lefthandside_self _patterns_self
        (_oneLineTree) =
            punctuate " " ( parens _lefthandside_oneLineTree : _patterns_oneLineTree )
        ( _range_self) =
            (_range )
        ( _lefthandside_betaUnique,_lefthandside_betas,_lefthandside_constraints,_lefthandside_environment,_lefthandside_name,_lefthandside_numberOfPatterns,_lefthandside_oneLineTree,_lefthandside_patternTrees,_lefthandside_self) =
            (_lefthandside (_lhs_betaUnique) (_lhs_importEnvironment))
        ( _patterns_betaUnique,_patterns_betas,_patterns_constraintslist,_patterns_environment,_patterns_numberOfPatterns,_patterns_oneLineTree,_patterns_self) =
            (_patterns (_lefthandside_betaUnique) (_lhs_importEnvironment))
    in  ( _patterns_betaUnique,_lefthandside_betas ++ _patterns_betas,ctNode ( _lefthandside_constraints : _patterns_constraintslist ),_lefthandside_environment `plusFM` _patterns_environment,_lefthandside_name,_lefthandside_numberOfPatterns + _patterns_numberOfPatterns,_oneLineTree,_lefthandside_patternTrees ++ _patterns_oneLineTree,_self)
-- Literal -----------------------------------------------------
-- semantic domain
type T_Literal = ( (Tp),(Tree),(Literal))
-- cata
sem_Literal :: (Literal) ->
               (T_Literal)
sem_Literal ((Literal_Char (_range) (_value))) =
    (sem_Literal_Char ((sem_Range (_range))) (_value))
sem_Literal ((Literal_Float (_range) (_value))) =
    (sem_Literal_Float ((sem_Range (_range))) (_value))
sem_Literal ((Literal_Int (_range) (_value))) =
    (sem_Literal_Int ((sem_Range (_range))) (_value))
sem_Literal ((Literal_String (_range) (_value))) =
    (sem_Literal_String ((sem_Range (_range))) (_value))
sem_Literal_Char :: (T_Range) ->
                    (String) ->
                    (T_Literal)
sem_Literal_Char (_range) (_value) =
    let (_self) =
            Literal_Char _range_self _value
        (_oneLineTree) =
            Text ("'" ++ _value ++ "'")
        ( _range_self) =
            (_range )
    in  ( charType,_oneLineTree,_self)
sem_Literal_Float :: (T_Range) ->
                     (String) ->
                     (T_Literal)
sem_Literal_Float (_range) (_value) =
    let (_self) =
            Literal_Float _range_self _value
        (_oneLineTree) =
            Text _value
        ( _range_self) =
            (_range )
    in  ( floatType,_oneLineTree,_self)
sem_Literal_Int :: (T_Range) ->
                   (String) ->
                   (T_Literal)
sem_Literal_Int (_range) (_value) =
    let (_self) =
            Literal_Int _range_self _value
        (_oneLineTree) =
            Text _value
        ( _range_self) =
            (_range )
    in  ( intType,_oneLineTree,_self)
sem_Literal_String :: (T_Range) ->
                      (String) ->
                      (T_Literal)
sem_Literal_String (_range) (_value) =
    let (_self) =
            Literal_String _range_self _value
        (_oneLineTree) =
            Text ("\"" ++ _value ++ "\"")
        ( _range_self) =
            (_range )
    in  ( stringType,_oneLineTree,_self)
-- MaybeDeclarations -------------------------------------------
-- semantic domain
type T_MaybeDeclarations = ([((Expression, [String]), Core_TypingStrategy)]) ->
                           (Assumptions) ->
                           (Int) ->
                           ([(Name,Tps,Tp,Bool)]) ->
                           (ConstraintSet) ->
                           (ImportEnvironment) ->
                           (IO ()) ->
                           (Tps) ->
                           (TypeAnnotations) ->
                           (Int) ->
                           ( (Assumptions),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(IO ()),( Maybe [Tree] ),(MaybeDeclarations),(TypeAnnotations),(Int))
-- cata
sem_MaybeDeclarations :: (MaybeDeclarations) ->
                         (T_MaybeDeclarations)
sem_MaybeDeclarations ((MaybeDeclarations_Just (_declarations))) =
    (sem_MaybeDeclarations_Just ((sem_Declarations (_declarations))))
sem_MaybeDeclarations ((MaybeDeclarations_Nothing )) =
    (sem_MaybeDeclarations_Nothing )
sem_MaybeDeclarations_Just :: (T_Declarations) ->
                              (T_MaybeDeclarations)
sem_MaybeDeclarations_Just (_declarations) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            MaybeDeclarations_Just _declarations_self
        ((_aset,_cset,_monoTable)) =
            performBindingGroup _lhs_monos _declarations_typeSignatures (_mybdggroup : _declarations_bindingGroups)
        (_mybdggroup) =
            (emptyFM,_lhs_assumptions,[_lhs_constraints])
        ((_anns,_notypedefs)) =
            findTypeAnnotations False _lhs_monos _declarations_typeSignatures (_mybdggroup : _declarations_bindingGroups)
        ((_collectTypeConstructors,_collectValueConstructors,_collectTypeSynonyms,_collectConstructorEnv,_derivedFunctions,_operatorFixities)) =
            internalError "PartialSyntax.ag" "n/a" "toplevel MaybeDeclaration"
        (_oneLineTree) =
            Just _declarations_oneLineTree
        ( _declarations_betaUnique,_declarations_bindingGroups,_declarations_collectednotypedef,_declarations_matchIO,_declarations_oneLineTree,_declarations_self,_declarations_typeAnnotations,_declarations_typeSignatures,_declarations_uniqueSecondRound) =
            (_declarations (_lhs_allPatterns) (_lhs_betaUnique) ([]) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_monoTable) (_lhs_monos) (_lhs_typeAnnotations) (emptyFM) (_lhs_uniqueSecondRound))
    in  ( _aset,_declarations_betaUnique,_notypedefs ++ _declarations_collectednotypedef,_cset,_declarations_matchIO,_oneLineTree,_self,_anns ++ _declarations_typeAnnotations,_declarations_uniqueSecondRound)
sem_MaybeDeclarations_Nothing :: (T_MaybeDeclarations)
sem_MaybeDeclarations_Nothing (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            MaybeDeclarations_Nothing
        (_oneLineTree) =
            Nothing
    in  ( _lhs_assumptions,_lhs_betaUnique,_lhs_collectednotypedef,_lhs_constraints,_lhs_matchIO,_oneLineTree,_self,_lhs_typeAnnotations,_lhs_uniqueSecondRound)
-- MaybeExports ------------------------------------------------
-- semantic domain
type T_MaybeExports = ( (MaybeExports))
-- cata
sem_MaybeExports :: (MaybeExports) ->
                    (T_MaybeExports)
sem_MaybeExports ((MaybeExports_Just (_exports))) =
    (sem_MaybeExports_Just ((sem_Exports (_exports))))
sem_MaybeExports ((MaybeExports_Nothing )) =
    (sem_MaybeExports_Nothing )
sem_MaybeExports_Just :: (T_Exports) ->
                         (T_MaybeExports)
sem_MaybeExports_Just (_exports) =
    let (_self) =
            MaybeExports_Just _exports_self
        ( _exports_self) =
            (_exports )
    in  ( _self)
sem_MaybeExports_Nothing :: (T_MaybeExports)
sem_MaybeExports_Nothing  =
    let (_self) =
            MaybeExports_Nothing
    in  ( _self)
-- MaybeExpression ---------------------------------------------
-- semantic domain
type T_MaybeExpression = ([((Expression, [String]), Core_TypingStrategy)]) ->
                         (Int) ->
                         ([(Name,Tps,Tp,Bool)]) ->
                         (ImportEnvironment) ->
                         (IO ()) ->
                         (Tps) ->
                         ([(MaybeExpression, [String])]) ->
                         (TypeAnnotations) ->
                         (Int) ->
                         ( (Assumptions),(Tp),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(IO ()),([Maybe (MetaVariableTable MetaVariableInfo)]),( Maybe Tree ),(Bool),(MaybeExpression),(TypeAnnotations),(Int))
-- cata
sem_MaybeExpression :: (MaybeExpression) ->
                       (T_MaybeExpression)
sem_MaybeExpression ((MaybeExpression_Just (_expression))) =
    (sem_MaybeExpression_Just ((sem_Expression (_expression))))
sem_MaybeExpression ((MaybeExpression_Nothing )) =
    (sem_MaybeExpression_Nothing )
sem_MaybeExpression_Just :: (T_Expression) ->
                            (T_MaybeExpression)
sem_MaybeExpression_Just (_expression) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            MaybeExpression_Just _expression_self
        (_oneLineTree) =
            Just _expression_oneLineTree
        ((_t1,_matches,_,_,_)) =
            match1' match_MaybeExpression_Just _lhs_tryPatterns [] [_expression_matches]
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_self,_expression_typeAnnotations,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_t1) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_matchIO,_matches,_oneLineTree,False,_self,_expression_typeAnnotations,_expression_uniqueSecondRound)
sem_MaybeExpression_Nothing :: (T_MaybeExpression)
sem_MaybeExpression_Nothing (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_tryPatterns) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            MaybeExpression_Nothing
        (_beta) =
            TVar _lhs_betaUnique
        (_oneLineTree) =
            Nothing
        (((),_matches,_,_,_)) =
            match0' match_MaybeExpression_Nothing _lhs_tryPatterns [] []
    in  ( noAssumptions,_beta,_lhs_betaUnique + 1,_lhs_collectednotypedef,ctEmpty,_lhs_matchIO,_matches,_oneLineTree,True,_self,_lhs_typeAnnotations,_lhs_uniqueSecondRound)
-- MaybeImportSpecification ------------------------------------
-- semantic domain
type T_MaybeImportSpecification = ( (MaybeImportSpecification))
-- cata
sem_MaybeImportSpecification :: (MaybeImportSpecification) ->
                                (T_MaybeImportSpecification)
sem_MaybeImportSpecification ((MaybeImportSpecification_Just (_importspecification))) =
    (sem_MaybeImportSpecification_Just ((sem_ImportSpecification (_importspecification))))
sem_MaybeImportSpecification ((MaybeImportSpecification_Nothing )) =
    (sem_MaybeImportSpecification_Nothing )
sem_MaybeImportSpecification_Just :: (T_ImportSpecification) ->
                                     (T_MaybeImportSpecification)
sem_MaybeImportSpecification_Just (_importspecification) =
    let (_self) =
            MaybeImportSpecification_Just _importspecification_self
        ( _importspecification_self) =
            (_importspecification )
    in  ( _self)
sem_MaybeImportSpecification_Nothing :: (T_MaybeImportSpecification)
sem_MaybeImportSpecification_Nothing  =
    let (_self) =
            MaybeImportSpecification_Nothing
    in  ( _self)
-- MaybeInt ----------------------------------------------------
-- semantic domain
type T_MaybeInt = ( (MaybeInt))
-- cata
sem_MaybeInt :: (MaybeInt) ->
                (T_MaybeInt)
sem_MaybeInt ((MaybeInt_Just (_int))) =
    (sem_MaybeInt_Just (_int))
sem_MaybeInt ((MaybeInt_Nothing )) =
    (sem_MaybeInt_Nothing )
sem_MaybeInt_Just :: (Int) ->
                     (T_MaybeInt)
sem_MaybeInt_Just (_int) =
    let (_self) =
            MaybeInt_Just _int
    in  ( _self)
sem_MaybeInt_Nothing :: (T_MaybeInt)
sem_MaybeInt_Nothing  =
    let (_self) =
            MaybeInt_Nothing
    in  ( _self)
-- MaybeName ---------------------------------------------------
-- semantic domain
type T_MaybeName = ( (MaybeName))
-- cata
sem_MaybeName :: (MaybeName) ->
                 (T_MaybeName)
sem_MaybeName ((MaybeName_Just (_name))) =
    (sem_MaybeName_Just ((sem_Name (_name))))
sem_MaybeName ((MaybeName_Nothing )) =
    (sem_MaybeName_Nothing )
sem_MaybeName_Just :: (T_Name) ->
                      (T_MaybeName)
sem_MaybeName_Just (_name) =
    let (_self) =
            MaybeName_Just _name_self
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( _self)
sem_MaybeName_Nothing :: (T_MaybeName)
sem_MaybeName_Nothing  =
    let (_self) =
            MaybeName_Nothing
    in  ( _self)
-- MaybeNames --------------------------------------------------
-- semantic domain
type T_MaybeNames = ( (MaybeNames))
-- cata
sem_MaybeNames :: (MaybeNames) ->
                  (T_MaybeNames)
sem_MaybeNames ((MaybeNames_Just (_names))) =
    (sem_MaybeNames_Just ((sem_Names (_names))))
sem_MaybeNames ((MaybeNames_Nothing )) =
    (sem_MaybeNames_Nothing )
sem_MaybeNames_Just :: (T_Names) ->
                       (T_MaybeNames)
sem_MaybeNames_Just (_names) =
    let (_self) =
            MaybeNames_Just _names_self
        ( _names_isIdentifier,_names_isOperator,_names_isSpecial,_names_oneLineTree,_names_self) =
            (_names )
    in  ( _self)
sem_MaybeNames_Nothing :: (T_MaybeNames)
sem_MaybeNames_Nothing  =
    let (_self) =
            MaybeNames_Nothing
    in  ( _self)
-- Module ------------------------------------------------------
-- semantic domain
type T_Module = (ImportEnvironment) ->
                (Strategy) ->
                (Bool) ->
                ( (IO ()),(Module),(TypeEnvironment),(TypeErrors),(Warnings))
-- cata
sem_Module :: (Module) ->
              (T_Module)
sem_Module ((Module_Module (_range) (_name) (_exports) (_body))) =
    (sem_Module_Module ((sem_Range (_range))) ((sem_MaybeName (_name))) ((sem_MaybeExports (_exports))) ((sem_Body (_body))))
sem_Module_Module :: (T_Range) ->
                     (T_MaybeName) ->
                     (T_MaybeExports) ->
                     (T_Body) ->
                     (T_Module)
sem_Module_Module (_range) (_name) (_exports) (_body) (_lhs_importEnvironment) (_lhs_strategy) (_lhs_useTypeGraph) =
    let (_self) =
            Module_Module _range_self _name_self _exports_self _body_self
        (_debugIO) =
            do putStrLn "--- Debug Info ---"
               putStrLn $ unlines $ map show _constraints
               putStrLn $ "type variables in constraint set: "++show _body_betaUnique
               putStrLn $ "type variables used while solving: "++show _betaUniqueAtTheEnd
               putStrLn $ "constraints in set: "++show (length _constraints)
               when _filteredBool (putStrLn ("WARNING: Filtered type errors"))
               _solveDebug
        (_constraints) =
            zipWith setPosition [0..] (ctRoot _body_constraints _lhs_strategy)
        (_orderedTypeSynonyms) =
            getOrderedTypeSynonyms _lhs_importEnvironment
        ((_betaUniqueAtTheEnd,_substitution,_finalPredicates,_solveErrors,_solveDebug)) =
            (if _lhs_useTypeGraph then solveEquivalenceGroups else solveGreedy)
               _body_betaUnique ([ SolveWithTypeSynonyms _orderedTypeSynonyms
                                 , SolveWithTypeSignatures . map (\(n,ts) -> (show n,ts)) $
                                      (  fmToList (valueConstructors _lhs_importEnvironment)
                                      ++ fmToList (typeEnvironment _lhs_importEnvironment)
                                      )
                                 ] ++
                                 [ SolveWithSiblings xs | Siblings xs <- typingStrategies _lhs_importEnvironment ]
                                )
                                _constraints
        (_monomorphics) =
            ftv (  (eltsFM $ valueConstructors _lhs_importEnvironment)
                ++ (eltsFM $ typeEnvironment _lhs_importEnvironment)
                )
        (_monos) =
            map TVar _monomorphics
        (_inferredgamma) =
            map (\(name,tp) -> (name,generalize (ftv (_substitution |-> _monos)) [] (_substitution |-> tp))) _body_namesWithoutTypeDef
        ((_typeErrors,_filteredBool)) =
            let notGeneralEnoughErrors =
                   let f ((m,t),s2,(tree,range)) =
                          let m' = _substitution |-> m
                              t' = _substitution |-> t
                              s1 = generalize (ftv m') [] t'
                         in if not (genericInstanceOf _orderedTypeSynonyms standardClasses s2 s1) &&
                               unifiableTypeSchemes   _orderedTypeSynonyms s1 s2
                            then [makeNotGeneralEnoughTypeError range tree s1 s2]
                            else []
                   in concatMap f _body_typeAnnotations
                op typeError (list,bool) =
                                           case checkTypeError _orderedTypeSynonyms typeError of
                                              Just t  -> (t:list,bool)
                                              Nothing -> (list,True)
            in if null _solveErrors
                 then (notGeneralEnoughErrors,False)
                 else foldr op ([], False) (map ((_substitution |->) . makeTypeError) _solveErrors)
        (_toplevelTypes) =
            addListToFM _body_typeSignatures _inferredgamma
        (_warnings) =
            let f (n,ms,t,isToplevel) =
                               let ms'    = _substitution |-> ms
                                   t'     = _substitution |-> t
                                   scheme = generalize (ftv ms') [] t'
                               in if null (ftv scheme) && isToplevel
                                    then [NoTypeDef n scheme isToplevel]
                                    else []
            in concatMap f _body_collectednotypedef
        ( _range_self) =
            (_range )
        ( _name_self) =
            (_name )
        ( _exports_self) =
            (_exports )
        ( _body_assumptions,_body_betaUnique,_body_collectednotypedef,_body_constraints,_body_matchIO,_body_namesWithoutTypeDef,_body_self,_body_typeAnnotations,_body_typeSignatures) =
            (_body ([ (matchInfo, typingStrategy)
                    | typingStrategy <- typingStrategies _lhs_importEnvironment
                    , matchInfo      <- matchInformation
                                         _lhs_importEnvironment
                                         typingStrategy
                    ])
                   (maximum (0 : _monomorphics) + 1)
                   ([])
                   (_lhs_importEnvironment)
                   (return ())
                   (_monos)
                   ([]))
    in  ( _debugIO >> putStrLn "Inference Strategies:" >> _body_matchIO,_self,_toplevelTypes,_typeErrors,_warnings)
-- Name --------------------------------------------------------
-- semantic domain
type T_Name = ( (Bool),(Bool),(Bool),(Tree),(Name))
-- cata
sem_Name :: (Name) ->
            (T_Name)
sem_Name ((Name_Identifier (_range) (_module) (_name))) =
    (sem_Name_Identifier ((sem_Range (_range))) ((sem_Strings (_module))) (_name))
sem_Name ((Name_Operator (_range) (_module) (_name))) =
    (sem_Name_Operator ((sem_Range (_range))) ((sem_Strings (_module))) (_name))
sem_Name ((Name_Special (_range) (_module) (_name))) =
    (sem_Name_Special ((sem_Range (_range))) ((sem_Strings (_module))) (_name))
sem_Name_Identifier :: (T_Range) ->
                       (T_Strings) ->
                       (String) ->
                       (T_Name)
sem_Name_Identifier (_range) (_module) (_name) =
    let (_self) =
            Name_Identifier _range_self _module_self _name
        (_oneLineTree) =
            Text _name
        ( _range_self) =
            (_range )
        ( _module_oneLineTree,_module_self) =
            (_module )
    in  ( True,False,False,_oneLineTree,_self)
sem_Name_Operator :: (T_Range) ->
                     (T_Strings) ->
                     (String) ->
                     (T_Name)
sem_Name_Operator (_range) (_module) (_name) =
    let (_self) =
            Name_Operator _range_self _module_self _name
        (_oneLineTree) =
            Text _name
        ( _range_self) =
            (_range )
        ( _module_oneLineTree,_module_self) =
            (_module )
    in  ( False,True,False,_oneLineTree,_self)
sem_Name_Special :: (T_Range) ->
                    (T_Strings) ->
                    (String) ->
                    (T_Name)
sem_Name_Special (_range) (_module) (_name) =
    let (_self) =
            Name_Special _range_self _module_self _name
        (_oneLineTree) =
            Text _name
        ( _range_self) =
            (_range )
        ( _module_oneLineTree,_module_self) =
            (_module )
    in  ( False,False,True,_oneLineTree,_self)
-- Names -------------------------------------------------------
-- semantic domain
type T_Names = ( ( [Bool] ),( [Bool] ),( [Bool] ),( [ Tree] ),(Names))
-- cata
sem_Names :: (Names) ->
             (T_Names)
sem_Names (list) =
    (foldr (sem_Names_Cons) (sem_Names_Nil) ((map sem_Name list)))
sem_Names_Cons :: (T_Name) ->
                  (T_Names) ->
                  (T_Names)
sem_Names_Cons (_hd) (_tl) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_isIdentifier,_hd_isOperator,_hd_isSpecial,_hd_oneLineTree,_hd_self) =
            (_hd )
        ( _tl_isIdentifier,_tl_isOperator,_tl_isSpecial,_tl_oneLineTree,_tl_self) =
            (_tl )
    in  ( _hd_isIdentifier  :  _tl_isIdentifier,_hd_isOperator  :  _tl_isOperator,_hd_isSpecial  :  _tl_isSpecial,_hd_oneLineTree  :  _tl_oneLineTree,_self)
sem_Names_Nil :: (T_Names)
sem_Names_Nil  =
    let (_self) =
            []
    in  ( [],[],[],[],_self)
-- Pattern -----------------------------------------------------
-- semantic domain
type T_Pattern = (Int) ->
                 (ImportEnvironment) ->
                 ( (Tp),(Int),(ConstraintSet),(PatternAssumptions),(Tree),(Pattern))
-- cata
sem_Pattern :: (Pattern) ->
               (T_Pattern)
sem_Pattern ((Pattern_As (_range) (_name) (_pattern))) =
    (sem_Pattern_As ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Pattern (_pattern))))
sem_Pattern ((Pattern_Constructor (_range) (_name) (_patterns))) =
    (sem_Pattern_Constructor ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Patterns (_patterns))))
sem_Pattern ((Pattern_InfixConstructor (_range) (_leftPattern) (_constructorOperator) (_rightPattern))) =
    (sem_Pattern_InfixConstructor ((sem_Range (_range))) ((sem_Pattern (_leftPattern))) ((sem_Name (_constructorOperator))) ((sem_Pattern (_rightPattern))))
sem_Pattern ((Pattern_Irrefutable (_range) (_pattern))) =
    (sem_Pattern_Irrefutable ((sem_Range (_range))) ((sem_Pattern (_pattern))))
sem_Pattern ((Pattern_List (_range) (_patterns))) =
    (sem_Pattern_List ((sem_Range (_range))) ((sem_Patterns (_patterns))))
sem_Pattern ((Pattern_Literal (_range) (_literal))) =
    (sem_Pattern_Literal ((sem_Range (_range))) ((sem_Literal (_literal))))
sem_Pattern ((Pattern_Negate (_range) (_literal))) =
    (sem_Pattern_Negate ((sem_Range (_range))) ((sem_Literal (_literal))))
sem_Pattern ((Pattern_NegateFloat (_range) (_literal))) =
    (sem_Pattern_NegateFloat ((sem_Range (_range))) ((sem_Literal (_literal))))
sem_Pattern ((Pattern_Parenthesized (_range) (_pattern))) =
    (sem_Pattern_Parenthesized ((sem_Range (_range))) ((sem_Pattern (_pattern))))
sem_Pattern ((Pattern_Record (_range) (_name) (_recordPatternBindings))) =
    (sem_Pattern_Record ((sem_Range (_range))) ((sem_Name (_name))) ((sem_RecordPatternBindings (_recordPatternBindings))))
sem_Pattern ((Pattern_Successor (_range) (_name) (_literal))) =
    (sem_Pattern_Successor ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Literal (_literal))))
sem_Pattern ((Pattern_Tuple (_range) (_patterns))) =
    (sem_Pattern_Tuple ((sem_Range (_range))) ((sem_Patterns (_patterns))))
sem_Pattern ((Pattern_Variable (_range) (_name))) =
    (sem_Pattern_Variable ((sem_Range (_range))) ((sem_Name (_name))))
sem_Pattern ((Pattern_Wildcard (_range))) =
    (sem_Pattern_Wildcard ((sem_Range (_range))))
sem_Pattern_As :: (T_Range) ->
                  (T_Name) ->
                  (T_Pattern) ->
                  (T_Pattern)
sem_Pattern_As (_range) (_name) (_pattern) (_lhs_betaUnique) (_lhs_importEnvironment) =
    let (_self) =
            Pattern_As _range_self _name_self _pattern_self
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            [ (_beta .==. _pattern_beta) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTPattern, AltAs, 0, "")
                  , location   = "as pattern"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm (Text (show _name_self)) ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getNameRange _name_self) ]
                  }
        (_oneLineTree) =
            Node
                [ Node [_name_oneLineTree]
                , Text "@"
                , Node [_pattern_oneLineTree]
                ]
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _pattern_beta,_pattern_betaUnique,_pattern_constraints,_pattern_environment,_pattern_oneLineTree,_pattern_self) =
            (_pattern (_lhs_betaUnique + 1) (_lhs_importEnvironment))
    in  ( _beta
         ,_pattern_betaUnique
         ,_newcon .>.
          ctNode [ ctVariable _lhs_betaUnique
                 , _pattern_constraints
                 ]
         ,addToFM _pattern_environment _name_self _beta
         ,_oneLineTree
         ,_self
         )
sem_Pattern_Constructor :: (T_Range) ->
                           (T_Name) ->
                           (T_Patterns) ->
                           (T_Pattern)
sem_Pattern_Constructor (_range) (_name) (_patterns) (_lhs_betaUnique) (_lhs_importEnvironment) =
    let (_self) =
            Pattern_Constructor _range_self _name_self _patterns_self
        (_beta) =
            TVar (_lhs_betaUnique)
        (_betaCon) =
            TVar (_lhs_betaUnique + 1)
        (_conApply) =
            [ (_betaCon .==. foldr (.->.) _beta _patterns_betas) _cinfoApply ]
        (_conConstructor) =
            case lookupFM (valueConstructors _lhs_importEnvironment) _name_self of
               Nothing  -> []
               Just ctp -> [ (_betaCon .::. ctp) _cinfoConstructor ]
        (_cinfoConstructor) =
            \tppair ->
            CInfo { info       = (NTPattern, AltConstructor, 0, "")
                  , location   = "pattern constructor"
                  , errorrange = getNameRange _name_self
                  , sources    = [ sourcePattern _oneLineTree ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , HighlyTrusted
                                 ]
                  }
        (_cinfoApply) =
            \tppair ->
            CInfo { info       = (NTPattern, AltConstructor, 1, "apply")
                  , location   = if _patterns_numberOfPatterns == 0
                                   then "pattern constructor"
                                   else "pattern application"
                  , errorrange = _range_self
                  , sources    = if _patterns_numberOfPatterns == 0
                                   then [ sourcePattern _oneLineTree                            ]
                                   else [ sourcePattern _oneLineTree, sourceConstructor _name_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getNameRange _name_self) ] ++
                                 if _patterns_numberOfPatterns == 0
                                   then [HighlyTrusted]
                                   else [ ApplicationEdge False (zip3 _patterns_oneLineTree
                                                                      _patterns_betas
                                                                      (map getPatRange (_patterns_self))
                                                                )]
                  }
        (_operatorName) =
            if _name_isOperator
              then Node [Text "(", _name_oneLineTree, Text ")"]
              else _name_oneLineTree
        (_oneLineTree) =
            Node (sepBy (Text " ") (_operatorName : _patterns_oneLineTree))
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _patterns_betaUnique,_patterns_betas,_patterns_constraintslist,_patterns_environment,_patterns_numberOfPatterns,_patterns_oneLineTree,_patterns_self) =
            (_patterns (_lhs_betaUnique + 2) (_lhs_importEnvironment))
    in  ( _beta
         ,_patterns_betaUnique
         ,_conApply .>.
          ctNode [ ctSingle _conConstructor
                 , ctNode _patterns_constraintslist
                 ]
         ,_patterns_environment
         ,_oneLineTree
         ,_self
         )
sem_Pattern_InfixConstructor :: (T_Range) ->
                                (T_Pattern) ->
                                (T_Name) ->
                                (T_Pattern) ->
                                (T_Pattern)
sem_Pattern_InfixConstructor (_range) (_leftPattern) (_constructorOperator) (_rightPattern) (_lhs_betaUnique) (_lhs_importEnvironment) =
    let (_self) =
            Pattern_InfixConstructor _range_self _leftPattern_self _constructorOperator_self _rightPattern_self
        (_beta) =
            TVar _lhs_betaUnique
        (_betaCon) =
            TVar (_lhs_betaUnique + 1)
        (_conApply) =
            [ (_betaCon .==. _leftPattern_beta .->. _rightPattern_beta .->. _beta) _cinfoApply ]
        (_conConstructor) =
            case lookupFM (valueConstructors _lhs_importEnvironment) _constructorOperator_self  of
               Nothing  -> []
               Just ctp -> [ (_betaCon .::. ctp) _cinfoConstructor ]
        (_cinfoConstructor) =
            \tppair ->
            CInfo { info       = (NTPattern, AltInfixConstructor, 0, "")
                  , location   = "pattern constructor"
                  , errorrange = getNameRange _constructorOperator_self
                  , sources    = [ sourceOperator _constructorOperator_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , HighlyTrusted
                                 , SubTermRange (getNameRange _constructorOperator_self)
                                 ]
                  }
        (_cinfoApply) =
            \tppair ->
            CInfo { info       = (NTPattern, AltInfixConstructor, 1, "apply")
                  , location   = "infix pattern application"
                  , errorrange = _range_self
                  , sources    = [ sourcePattern _oneLineTree, sourceConstructor (Text (showNameAsOperator _constructorOperator_self))]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getNameRange _constructorOperator_self)
                                 , ApplicationEdge True
                                                   [ (_leftPattern_oneLineTree ,_leftPattern_beta ,getPatRange (_leftPattern_self))
                                                   , (_rightPattern_oneLineTree,_rightPattern_beta,getPatRange (_rightPattern_self))
                                                   ]
                                 ]
                  }
        (_operatorName) =
            Text (showNameAsOperator _constructorOperator_self)
        (_oneLineTree) =
            Node
                [ Node [_leftPattern_oneLineTree]
                , Text " "
                , Node [_operatorName]
                , Text " "
                , Node [_rightPattern_oneLineTree]
                ]
        ( _range_self) =
            (_range )
        ( _leftPattern_beta,_leftPattern_betaUnique,_leftPattern_constraints,_leftPattern_environment,_leftPattern_oneLineTree,_leftPattern_self) =
            (_leftPattern (_lhs_betaUnique + 2) (_lhs_importEnvironment))
        ( _constructorOperator_isIdentifier,_constructorOperator_isOperator,_constructorOperator_isSpecial,_constructorOperator_oneLineTree,_constructorOperator_self) =
            (_constructorOperator )
        ( _rightPattern_beta,_rightPattern_betaUnique,_rightPattern_constraints,_rightPattern_environment,_rightPattern_oneLineTree,_rightPattern_self) =
            (_rightPattern (_leftPattern_betaUnique) (_lhs_importEnvironment))
    in  ( _beta
         ,_rightPattern_betaUnique
         ,_conApply .>.
          ctNode [ ctSingle _conConstructor
                 , _leftPattern_constraints
                 , _rightPattern_constraints
                 ]
         ,_leftPattern_environment `plusFM` _rightPattern_environment
         ,_oneLineTree
         ,_self
         )
sem_Pattern_Irrefutable :: (T_Range) ->
                           (T_Pattern) ->
                           (T_Pattern)
sem_Pattern_Irrefutable (_range) (_pattern) (_lhs_betaUnique) (_lhs_importEnvironment) =
    let (_self) =
            Pattern_Irrefutable _range_self _pattern_self
        (_oneLineTree) =
            intErr "pattern" "irrefutable"
        ( _range_self) =
            (_range )
        ( _pattern_beta,_pattern_betaUnique,_pattern_constraints,_pattern_environment,_pattern_oneLineTree,_pattern_self) =
            (_pattern (_lhs_betaUnique) (_lhs_importEnvironment))
    in  ( _pattern_beta,_pattern_betaUnique,_pattern_constraints,_pattern_environment,_oneLineTree,_self)
sem_Pattern_List :: (T_Range) ->
                    (T_Patterns) ->
                    (T_Pattern)
sem_Pattern_List (_range) (_patterns) (_lhs_betaUnique) (_lhs_importEnvironment) =
    let (_self) =
            Pattern_List _range_self _patterns_self
        (_beta) =
            TVar _lhs_betaUnique
        (_beta') =
            TVar (_lhs_betaUnique + 1)
        (_newcon) =
            [ (listType _beta' .==. _beta) _cinfoResult ]
        (_childrenInfo) =
            zip _patterns_oneLineTree (map getPatRange _patterns_self)
        (_zipf) =
            \tp pair ctree -> [ (tp .==. _beta') (_cinfoElem pair) ] .<. ctree
        (_cinfoElem) =
            \(elemtext, elemrange) tppair ->
            CInfo { info       = (NTPattern, AltList, 0, "element")
                  , location   = "element of pattern list"
                  , errorrange = _range_self
                  , sources    = [ sourcePattern _oneLineTree, sourceTerm elemtext ]
                  , typepair   = tppair
                  , properties = [ SubTermRange elemrange ] ++
                                 if length _patterns_constraintslist > 1 then [] else [ HighlyTrusted  ]
                  }
        (_cinfoResult) =
            \tppair ->
            CInfo { info       = (NTPattern, AltList, 1, "result")
                  , location   = "pattern list"
                  , errorrange = _range_self
                  , sources    = [ sourcePattern _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint ]
                  }
        (_oneLineTree) =
            encloseSep "[" ", " "]" _patterns_oneLineTree
        ( _range_self) =
            (_range )
        ( _patterns_betaUnique,_patterns_betas,_patterns_constraintslist,_patterns_environment,_patterns_numberOfPatterns,_patterns_oneLineTree,_patterns_self) =
            (_patterns (_lhs_betaUnique + 2) (_lhs_importEnvironment))
    in  ( _beta
         ,_patterns_betaUnique
         ,_newcon .>.
          ctNode (zipWith3 _zipf _patterns_betas _childrenInfo _patterns_constraintslist)
         ,_patterns_environment
         ,_oneLineTree
         ,_self
         )
sem_Pattern_Literal :: (T_Range) ->
                       (T_Literal) ->
                       (T_Pattern)
sem_Pattern_Literal (_range) (_literal) (_lhs_betaUnique) (_lhs_importEnvironment) =
    let (_self) =
            Pattern_Literal _range_self _literal_self
        (_beta) =
            TVar _lhs_betaUnique
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTPattern, AltLiteral, 0, "")
                  , location   = "literal pattern"
                  , errorrange = _range_self
                  , sources    = [ sourcePattern _oneLineTree ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , HighlyTrusted
                                 , IsLiteral _literal_self
                                 ]
                  }
        (_oneLineTree) =
            _literal_oneLineTree
        ( _range_self) =
            (_range )
        ( _literal_literalType,_literal_oneLineTree,_literal_self) =
            (_literal )
    in  ( _beta,_lhs_betaUnique + 1,ctSingle [ (_literal_literalType .==. _beta) _cinfo ],noAssumptions,_oneLineTree,_self)
sem_Pattern_Negate :: (T_Range) ->
                      (T_Literal) ->
                      (T_Pattern)
sem_Pattern_Negate (_range) (_literal) (_lhs_betaUnique) (_lhs_importEnvironment) =
    let (_self) =
            Pattern_Negate _range_self _literal_self
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            [ (intType .==. _beta) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTPattern, AltNegate, 0, "")
                  , location   = "pattern negation"
                  , errorrange = _range_self
                  , sources    = [ sourcePattern _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint ]
                  }
        (_oneLineTree) =
            Node [ Text "-", _literal_oneLineTree ]
        ( _range_self) =
            (_range )
        ( _literal_literalType,_literal_oneLineTree,_literal_self) =
            (_literal )
    in  ( _beta,_lhs_betaUnique + 1,ctSingle _newcon,noAssumptions,_oneLineTree,_self)
sem_Pattern_NegateFloat :: (T_Range) ->
                           (T_Literal) ->
                           (T_Pattern)
sem_Pattern_NegateFloat (_range) (_literal) (_lhs_betaUnique) (_lhs_importEnvironment) =
    let (_self) =
            Pattern_NegateFloat _range_self _literal_self
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            [ (floatType .==. _beta) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTPattern, AltNegateFloat, 0, "")
                  , location   = "pattern negation"
                  , errorrange = _range_self
                  , sources    = [ sourcePattern _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , NegationResult
                                 ]
                  }
        (_oneLineTree) =
            Node [ Text "-." , _literal_oneLineTree ]
        ( _range_self) =
            (_range )
        ( _literal_literalType,_literal_oneLineTree,_literal_self) =
            (_literal )
    in  ( _beta,_lhs_betaUnique + 1,ctSingle _newcon,noAssumptions,_oneLineTree,_self)
sem_Pattern_Parenthesized :: (T_Range) ->
                             (T_Pattern) ->
                             (T_Pattern)
sem_Pattern_Parenthesized (_range) (_pattern) (_lhs_betaUnique) (_lhs_importEnvironment) =
    let (_self) =
            Pattern_Parenthesized _range_self _pattern_self
        (_oneLineTree) =
            parens _pattern_oneLineTree
        ( _range_self) =
            (_range )
        ( _pattern_beta,_pattern_betaUnique,_pattern_constraints,_pattern_environment,_pattern_oneLineTree,_pattern_self) =
            (_pattern (_lhs_betaUnique) (_lhs_importEnvironment))
    in  ( _pattern_beta,_pattern_betaUnique,_pattern_constraints,_pattern_environment,_oneLineTree,_self)
sem_Pattern_Record :: (T_Range) ->
                      (T_Name) ->
                      (T_RecordPatternBindings) ->
                      (T_Pattern)
sem_Pattern_Record (_range) (_name) (_recordPatternBindings) (_lhs_betaUnique) (_lhs_importEnvironment) =
    let (_self) =
            Pattern_Record _range_self _name_self _recordPatternBindings_self
        ((_beta,_constraints,_environment)) =
            internalError "PartialSyntax.ag" "n/a" "Pattern.Record"
        (_oneLineTree) =
            intErr "pattern" "record"
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _recordPatternBindings_self) =
            (_recordPatternBindings )
    in  ( _beta,_lhs_betaUnique,_constraints,_environment,_oneLineTree,_self)
sem_Pattern_Successor :: (T_Range) ->
                         (T_Name) ->
                         (T_Literal) ->
                         (T_Pattern)
sem_Pattern_Successor (_range) (_name) (_literal) (_lhs_betaUnique) (_lhs_importEnvironment) =
    let (_self) =
            Pattern_Successor _range_self _name_self _literal_self
        ((_beta,_constraints,_environment)) =
            internalError "PartialSyntax.ag" "n/a" "Pattern.Successor"
        (_oneLineTree) =
            intErr "pattern" "successor"
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _literal_literalType,_literal_oneLineTree,_literal_self) =
            (_literal )
    in  ( _beta,_lhs_betaUnique,_constraints,_environment,_oneLineTree,_self)
sem_Pattern_Tuple :: (T_Range) ->
                     (T_Patterns) ->
                     (T_Pattern)
sem_Pattern_Tuple (_range) (_patterns) (_lhs_betaUnique) (_lhs_importEnvironment) =
    let (_self) =
            Pattern_Tuple _range_self _patterns_self
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            [ (tupleType _patterns_betas .==. _beta) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTPattern, AltTuple, 0, "result")
                  , location   = "pattern tuple"
                  , errorrange = _range_self
                  , sources    = [ sourcePattern _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ FolkloreConstraint
                                 , IsTupleEdge
                                 ]
                  }
        (_oneLineTree) =
            encloseSep "(" ", " ")" _patterns_oneLineTree
        ( _range_self) =
            (_range )
        ( _patterns_betaUnique,_patterns_betas,_patterns_constraintslist,_patterns_environment,_patterns_numberOfPatterns,_patterns_oneLineTree,_patterns_self) =
            (_patterns (_lhs_betaUnique + 1) (_lhs_importEnvironment))
    in  ( _beta,_patterns_betaUnique,_newcon .>. ctNode _patterns_constraintslist,_patterns_environment,_oneLineTree,_self)
sem_Pattern_Variable :: (T_Range) ->
                        (T_Name) ->
                        (T_Pattern)
sem_Pattern_Variable (_range) (_name) (_lhs_betaUnique) (_lhs_importEnvironment) =
    let (_self) =
            Pattern_Variable _range_self _name_self
        (_beta) =
            TVar _lhs_betaUnique
        (_oneLineTree) =
            _name_oneLineTree
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( _beta,_lhs_betaUnique + 1,ctVariable _lhs_betaUnique,unitFM _name_self _beta,_oneLineTree,_self)
sem_Pattern_Wildcard :: (T_Range) ->
                        (T_Pattern)
sem_Pattern_Wildcard (_range) (_lhs_betaUnique) (_lhs_importEnvironment) =
    let (_self) =
            Pattern_Wildcard _range_self
        (_beta) =
            TVar _lhs_betaUnique
        (_oneLineTree) =
            Text "_"
        ( _range_self) =
            (_range )
    in  ( _beta,_lhs_betaUnique + 1,ctEmpty,noAssumptions,_oneLineTree,_self)
-- Patterns ----------------------------------------------------
-- semantic domain
type T_Patterns = (Int) ->
                  (ImportEnvironment) ->
                  ( (Int),(Tps),(ConstraintSets),(PatternAssumptions),(Int),( [ Tree] ),(Patterns))
-- cata
sem_Patterns :: (Patterns) ->
                (T_Patterns)
sem_Patterns (list) =
    (foldr (sem_Patterns_Cons) (sem_Patterns_Nil) ((map sem_Pattern list)))
sem_Patterns_Cons :: (T_Pattern) ->
                     (T_Patterns) ->
                     (T_Patterns)
sem_Patterns_Cons (_hd) (_tl) (_lhs_betaUnique) (_lhs_importEnvironment) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_beta,_hd_betaUnique,_hd_constraints,_hd_environment,_hd_oneLineTree,_hd_self) =
            (_hd (_lhs_betaUnique) (_lhs_importEnvironment))
        ( _tl_betaUnique,_tl_betas,_tl_constraintslist,_tl_environment,_tl_numberOfPatterns,_tl_oneLineTree,_tl_self) =
            (_tl (_hd_betaUnique) (_lhs_importEnvironment))
    in  ( _tl_betaUnique,_hd_beta : _tl_betas,_hd_constraints : _tl_constraintslist,_hd_environment `plusFM` _tl_environment,1 + _tl_numberOfPatterns,_hd_oneLineTree  :  _tl_oneLineTree,_self)
sem_Patterns_Nil :: (T_Patterns)
sem_Patterns_Nil (_lhs_betaUnique) (_lhs_importEnvironment) =
    let (_self) =
            []
    in  ( _lhs_betaUnique,[],[],noAssumptions,0,[],_self)
-- Position ----------------------------------------------------
-- semantic domain
type T_Position = ( (Position))
-- cata
sem_Position :: (Position) ->
                (T_Position)
sem_Position ((Position_Position (_filename) (_line) (_column))) =
    (sem_Position_Position (_filename) (_line) (_column))
sem_Position ((Position_Unknown )) =
    (sem_Position_Unknown )
sem_Position_Position :: (String) ->
                         (Int) ->
                         (Int) ->
                         (T_Position)
sem_Position_Position (_filename) (_line) (_column) =
    let (_self) =
            Position_Position _filename _line _column
    in  ( _self)
sem_Position_Unknown :: (T_Position)
sem_Position_Unknown  =
    let (_self) =
            Position_Unknown
    in  ( _self)
-- Qualifier ---------------------------------------------------
-- semantic domain
type T_Qualifier = ([((Expression, [String]), Core_TypingStrategy)]) ->
                   (Assumptions) ->
                   (Int) ->
                   ([(Name,Tps,Tp,Bool)]) ->
                   (ConstraintSet) ->
                   (ImportEnvironment) ->
                   (IO ()) ->
                   (Tps) ->
                   (TypeAnnotations) ->
                   (Int) ->
                   ( (Assumptions),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(IO ()),(Tps),(Tree),(Qualifier),(TypeAnnotations),(Int))
-- cata
sem_Qualifier :: (Qualifier) ->
                 (T_Qualifier)
sem_Qualifier ((Qualifier_Empty (_range))) =
    (sem_Qualifier_Empty ((sem_Range (_range))))
sem_Qualifier ((Qualifier_Generator (_range) (_pattern) (_expression))) =
    (sem_Qualifier_Generator ((sem_Range (_range))) ((sem_Pattern (_pattern))) ((sem_Expression (_expression))))
sem_Qualifier ((Qualifier_Guard (_range) (_guard))) =
    (sem_Qualifier_Guard ((sem_Range (_range))) ((sem_Expression (_guard))))
sem_Qualifier ((Qualifier_Let (_range) (_declarations))) =
    (sem_Qualifier_Let ((sem_Range (_range))) ((sem_Declarations (_declarations))))
sem_Qualifier_Empty :: (T_Range) ->
                       (T_Qualifier)
sem_Qualifier_Empty (_range) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Qualifier_Empty _range_self
        (_oneLineTree) =
            Text ""
        ( _range_self) =
            (_range )
    in  ( _lhs_assumptions,_lhs_betaUnique,_lhs_collectednotypedef,_lhs_constraints,_lhs_matchIO,_lhs_monos,_oneLineTree,_self,_lhs_typeAnnotations,_lhs_uniqueSecondRound)
sem_Qualifier_Generator :: (T_Range) ->
                           (T_Pattern) ->
                           (T_Expression) ->
                           (T_Qualifier)
sem_Qualifier_Generator (_range) (_pattern) (_expression) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Qualifier_Generator _range_self _pattern_self _expression_self
        ((_csetBinds,_assumptions')) =
            (_pattern_environment .===. _lhs_assumptions) _cinfoBind
        (_newcon) =
            [ (_expression_beta .==. listType _pattern_beta) _cinfoResult ]
        (_cinfoResult) =
            \tppair ->
            CInfo { info       = (NTQualifier,AltGenerator,0, "result")
                  , location   = "generator"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm _expression_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getExprRange _expression_self) ]
                  }
        (_cinfoBind) =
            variableBindingCInfo (NTQualifier,AltGenerator,1 )
        (_oneLineTree) =
            Node [ _pattern_oneLineTree, Text " <- ", _expression_oneLineTree ]
        ( _range_self) =
            (_range )
        ( _pattern_beta,_pattern_betaUnique,_pattern_constraints,_pattern_environment,_pattern_oneLineTree,_pattern_self) =
            (_pattern (_lhs_betaUnique) (_lhs_importEnvironment))
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_self,_expression_typeAnnotations,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_pattern_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) ([]) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _assumptions' `combine` _expression_assumptions
         ,_expression_betaUnique
         ,_expression_collectednotypedef
         ,_newcon .>. _csetBinds .>>.
          ctNode [ _pattern_constraints
                 , _expression_constraints
                 , _lhs_constraints
                 ]
         ,_expression_matchIO
         ,eltsFM _pattern_environment ++ _lhs_monos
         ,_oneLineTree
         ,_self
         ,_expression_typeAnnotations
         ,_expression_uniqueSecondRound
         )
sem_Qualifier_Guard :: (T_Range) ->
                       (T_Expression) ->
                       (T_Qualifier)
sem_Qualifier_Guard (_range) (_guard) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Qualifier_Guard _range_self _guard_self
        (_newcon) =
            [ (_guard_beta .==. boolType) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTQualifier,AltGuard,0, "")
                  , location   = "boolean qualifier"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree  ]
                  , typepair   = tppair
                  , properties = [ ]
                  }
        (_oneLineTree) =
            _guard_oneLineTree
        ( _range_self) =
            (_range )
        ( _guard_assumptions,_guard_beta,_guard_betaUnique,_guard_collectednotypedef,_guard_constraints,_guard_matchIO,_guard_matches,_guard_oneLineTree,_guard_self,_guard_typeAnnotations,_guard_uniqueSecondRound) =
            (_guard (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) ([]) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _lhs_assumptions `combine` _guard_assumptions
         ,_guard_betaUnique
         ,_guard_collectednotypedef
         ,ctNode [ _newcon .<. _guard_constraints
                 , _lhs_constraints
                 ]
         ,_guard_matchIO
         ,_lhs_monos
         ,_oneLineTree
         ,_self
         ,_guard_typeAnnotations
         ,_guard_uniqueSecondRound
         )
sem_Qualifier_Let :: (T_Range) ->
                     (T_Declarations) ->
                     (T_Qualifier)
sem_Qualifier_Let (_range) (_declarations) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Qualifier_Let _range_self _declarations_self
        ((_aset,_cset,_monoTable)) =
            performBindingGroup _lhs_monos _declarations_typeSignatures (_mybdggroup : _declarations_bindingGroups)
        (_mybdggroup) =
            (noAssumptions,_lhs_assumptions,[_lhs_constraints])
        ((_anns,_notypedefs)) =
            findTypeAnnotations False _lhs_monos _declarations_typeSignatures (_mybdggroup : _declarations_bindingGroups)
        ((_collectTypeConstructors,_collectValueConstructors,_collectTypeSynonyms,_collectConstructorEnv,_derivedFunctions,_operatorFixities)) =
            internalError "PartialSyntax.ag" "n/a" "toplevel Qualifier"
        (_oneLineTree) =
            Node [ Text "let ", encloseSep "{" "; " "}" _declarations_oneLineTree ]
        ( _range_self) =
            (_range )
        ( _declarations_betaUnique,_declarations_bindingGroups,_declarations_collectednotypedef,_declarations_matchIO,_declarations_oneLineTree,_declarations_self,_declarations_typeAnnotations,_declarations_typeSignatures,_declarations_uniqueSecondRound) =
            (_declarations (_lhs_allPatterns) (_lhs_betaUnique) ([]) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_monoTable) (_lhs_monos) (_lhs_typeAnnotations) (emptyFM) (_lhs_uniqueSecondRound))
    in  ( _aset,_declarations_betaUnique,_notypedefs ++ _declarations_collectednotypedef,_cset,_declarations_matchIO,_lhs_monos,_oneLineTree,_self,_anns ++ _declarations_typeAnnotations,_declarations_uniqueSecondRound)
-- Qualifiers --------------------------------------------------
-- semantic domain
type T_Qualifiers = ([((Expression, [String]), Core_TypingStrategy)]) ->
                    (Assumptions) ->
                    (Int) ->
                    ([(Name,Tps,Tp,Bool)]) ->
                    (ConstraintSet) ->
                    (ImportEnvironment) ->
                    (IO ()) ->
                    (Tps) ->
                    (TypeAnnotations) ->
                    (Int) ->
                    ( (Assumptions),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(IO ()),(Tps),( [ Tree] ),(Qualifiers),(TypeAnnotations),(Int))
-- cata
sem_Qualifiers :: (Qualifiers) ->
                  (T_Qualifiers)
sem_Qualifiers (list) =
    (foldr (sem_Qualifiers_Cons) (sem_Qualifiers_Nil) ((map sem_Qualifier list)))
sem_Qualifiers_Cons :: (T_Qualifier) ->
                       (T_Qualifiers) ->
                       (T_Qualifiers)
sem_Qualifiers_Cons (_hd) (_tl) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_assumptions,_hd_betaUnique,_hd_collectednotypedef,_hd_constraints,_hd_matchIO,_hd_monos,_hd_oneLineTree,_hd_self,_hd_typeAnnotations,_hd_uniqueSecondRound) =
            (_hd (_lhs_allPatterns) (_tl_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_tl_constraints) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _tl_assumptions,_tl_betaUnique,_tl_collectednotypedef,_tl_constraints,_tl_matchIO,_tl_monos,_tl_oneLineTree,_tl_self,_tl_typeAnnotations,_tl_uniqueSecondRound) =
            (_tl (_lhs_allPatterns) (_lhs_assumptions) (_hd_betaUnique) (_hd_collectednotypedef) (_lhs_constraints) (_lhs_importEnvironment) (_hd_matchIO) (_hd_monos) (_hd_typeAnnotations) (_hd_uniqueSecondRound))
    in  ( _hd_assumptions,_tl_betaUnique,_tl_collectednotypedef,_hd_constraints,_tl_matchIO,_tl_monos,_hd_oneLineTree  :  _tl_oneLineTree,_self,_tl_typeAnnotations,_tl_uniqueSecondRound)
sem_Qualifiers_Nil :: (T_Qualifiers)
sem_Qualifiers_Nil (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            []
    in  ( _lhs_assumptions,_lhs_betaUnique,_lhs_collectednotypedef,_lhs_constraints,_lhs_matchIO,_lhs_monos,[],_self,_lhs_typeAnnotations,_lhs_uniqueSecondRound)
-- Range -------------------------------------------------------
-- semantic domain
type T_Range = ( (Range))
-- cata
sem_Range :: (Range) ->
             (T_Range)
sem_Range ((Range_Range (_start) (_stop))) =
    (sem_Range_Range ((sem_Position (_start))) ((sem_Position (_stop))))
sem_Range_Range :: (T_Position) ->
                   (T_Position) ->
                   (T_Range)
sem_Range_Range (_start) (_stop) =
    let (_self) =
            Range_Range _start_self _stop_self
        ( _start_self) =
            (_start )
        ( _stop_self) =
            (_stop )
    in  ( _self)
-- RecordExpressionBinding -------------------------------------
-- semantic domain
type T_RecordExpressionBinding = ([(Name,Tps,Tp,Bool)]) ->
                                 (TypeAnnotations) ->
                                 ( ([(Name,Tps,Tp,Bool)]),(RecordExpressionBinding),(TypeAnnotations))
-- cata
sem_RecordExpressionBinding :: (RecordExpressionBinding) ->
                               (T_RecordExpressionBinding)
sem_RecordExpressionBinding ((RecordExpressionBinding_RecordExpressionBinding (_range) (_name) (_expression))) =
    (sem_RecordExpressionBinding_RecordExpressionBinding ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Expression (_expression))))
sem_RecordExpressionBinding_RecordExpressionBinding :: (T_Range) ->
                                                       (T_Name) ->
                                                       (T_Expression) ->
                                                       (T_RecordExpressionBinding)
sem_RecordExpressionBinding_RecordExpressionBinding (_range) (_name) (_expression) (_lhs_collectednotypedef) (_lhs_typeAnnotations) =
    let (_self) =
            RecordExpressionBinding_RecordExpressionBinding _range_self _name_self _expression_self
        ((_monos,_constructorenv,_betaUnique,_miscerrors,_warnings,_kindErrors,_valueConstructors,_allValueConstructors,_typeConstructors,_allTypeConstructors,_importEnvironment)) =
            internalError "PartialSyntax.ag" "n/a" "RecordExpressionBinding.RecordExpressionBinding"
        ((_allPatterns,_tryPatterns,_matchIO,_uniqueSecondRound)) =
            undefined
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_self,_expression_typeAnnotations,_expression_uniqueSecondRound) =
            (_expression (_allPatterns) (_betaUnique) (_lhs_collectednotypedef) (_importEnvironment) (_matchIO) (_monos) (_tryPatterns) (_lhs_typeAnnotations) (_uniqueSecondRound))
    in  ( _expression_collectednotypedef,_self,_expression_typeAnnotations)
-- RecordExpressionBindings ------------------------------------
-- semantic domain
type T_RecordExpressionBindings = ([(Name,Tps,Tp,Bool)]) ->
                                  (TypeAnnotations) ->
                                  ( ([(Name,Tps,Tp,Bool)]),(RecordExpressionBindings),(TypeAnnotations))
-- cata
sem_RecordExpressionBindings :: (RecordExpressionBindings) ->
                                (T_RecordExpressionBindings)
sem_RecordExpressionBindings (list) =
    (foldr (sem_RecordExpressionBindings_Cons) (sem_RecordExpressionBindings_Nil) ((map sem_RecordExpressionBinding list)))
sem_RecordExpressionBindings_Cons :: (T_RecordExpressionBinding) ->
                                     (T_RecordExpressionBindings) ->
                                     (T_RecordExpressionBindings)
sem_RecordExpressionBindings_Cons (_hd) (_tl) (_lhs_collectednotypedef) (_lhs_typeAnnotations) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_collectednotypedef,_hd_self,_hd_typeAnnotations) =
            (_hd (_lhs_collectednotypedef) (_lhs_typeAnnotations))
        ( _tl_collectednotypedef,_tl_self,_tl_typeAnnotations) =
            (_tl (_hd_collectednotypedef) (_hd_typeAnnotations))
    in  ( _tl_collectednotypedef,_self,_tl_typeAnnotations)
sem_RecordExpressionBindings_Nil :: (T_RecordExpressionBindings)
sem_RecordExpressionBindings_Nil (_lhs_collectednotypedef) (_lhs_typeAnnotations) =
    let (_self) =
            []
    in  ( _lhs_collectednotypedef,_self,_lhs_typeAnnotations)
-- RecordPatternBinding ----------------------------------------
-- semantic domain
type T_RecordPatternBinding = ( (RecordPatternBinding))
-- cata
sem_RecordPatternBinding :: (RecordPatternBinding) ->
                            (T_RecordPatternBinding)
sem_RecordPatternBinding ((RecordPatternBinding_RecordPatternBinding (_range) (_name) (_pattern))) =
    (sem_RecordPatternBinding_RecordPatternBinding ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Pattern (_pattern))))
sem_RecordPatternBinding_RecordPatternBinding :: (T_Range) ->
                                                 (T_Name) ->
                                                 (T_Pattern) ->
                                                 (T_RecordPatternBinding)
sem_RecordPatternBinding_RecordPatternBinding (_range) (_name) (_pattern) =
    let (_self) =
            RecordPatternBinding_RecordPatternBinding _range_self _name_self _pattern_self
        ((_constructorenv,_betaUnique,_miscerrors,_warnings,_valueConstructors,_allValueConstructors,_typeConstructors,_allTypeConstructors,_importEnvironment)) =
            internalError "PartialSyntax.ag" "n/a" "RecordPatternBinding.RecordPatternBinding"
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _pattern_beta,_pattern_betaUnique,_pattern_constraints,_pattern_environment,_pattern_oneLineTree,_pattern_self) =
            (_pattern (_betaUnique) (_importEnvironment))
    in  ( _self)
-- RecordPatternBindings ---------------------------------------
-- semantic domain
type T_RecordPatternBindings = ( (RecordPatternBindings))
-- cata
sem_RecordPatternBindings :: (RecordPatternBindings) ->
                             (T_RecordPatternBindings)
sem_RecordPatternBindings (list) =
    (foldr (sem_RecordPatternBindings_Cons) (sem_RecordPatternBindings_Nil) ((map sem_RecordPatternBinding list)))
sem_RecordPatternBindings_Cons :: (T_RecordPatternBinding) ->
                                  (T_RecordPatternBindings) ->
                                  (T_RecordPatternBindings)
sem_RecordPatternBindings_Cons (_hd) (_tl) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  ( _self)
sem_RecordPatternBindings_Nil :: (T_RecordPatternBindings)
sem_RecordPatternBindings_Nil  =
    let (_self) =
            []
    in  ( _self)
-- RightHandSide -----------------------------------------------
-- semantic domain
type T_RightHandSide = ([((Expression, [String]), Core_TypingStrategy)]) ->
                       (Int) ->
                       ([(Name,Tps,Tp,Bool)]) ->
                       (ImportEnvironment) ->
                       (IO ()) ->
                       (Tps) ->
                       (TypeAnnotations) ->
                       (Int) ->
                       ( (Assumptions),(Tp),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(IO ()),( String -> Tree ),(RightHandSide),(TypeAnnotations),(Int))
-- cata
sem_RightHandSide :: (RightHandSide) ->
                     (T_RightHandSide)
sem_RightHandSide ((RightHandSide_Expression (_range) (_expression) (_where))) =
    (sem_RightHandSide_Expression ((sem_Range (_range))) ((sem_Expression (_expression))) ((sem_MaybeDeclarations (_where))))
sem_RightHandSide ((RightHandSide_Guarded (_range) (_guardedexpressions) (_where))) =
    (sem_RightHandSide_Guarded ((sem_Range (_range))) ((sem_GuardedExpressions (_guardedexpressions))) ((sem_MaybeDeclarations (_where))))
sem_RightHandSide_Expression :: (T_Range) ->
                                (T_Expression) ->
                                (T_MaybeDeclarations) ->
                                (T_RightHandSide)
sem_RightHandSide_Expression (_range) (_expression) (_where) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            RightHandSide_Expression _range_self _expression_self _where_self
        (_oneLineTree) =
            \assign -> Node
                (  [ Text assign, _expression_oneLineTree ]
                ++ case _where_oneLineTree of
                    Nothing -> []
                    Just ds -> [ Text " where ", encloseSep "{" "; " "}" ds ]
                )
        ( _range_self) =
            (_range )
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_self,_expression_typeAnnotations,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) ([]) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _where_assumptions,_where_betaUnique,_where_collectednotypedef,_where_constraints,_where_matchIO,_where_oneLineTree,_where_self,_where_typeAnnotations,_where_uniqueSecondRound) =
            (_where (_lhs_allPatterns) (_expression_assumptions) (_expression_betaUnique) (_expression_collectednotypedef) (_expression_constraints) (_lhs_importEnvironment) (_expression_matchIO) (_lhs_monos) (_expression_typeAnnotations) (_expression_uniqueSecondRound))
    in  ( _where_assumptions,_expression_beta,_where_betaUnique,_where_collectednotypedef,_where_constraints,_where_matchIO,_oneLineTree,_self,_where_typeAnnotations,_where_uniqueSecondRound)
sem_RightHandSide_Guarded :: (T_Range) ->
                             (T_GuardedExpressions) ->
                             (T_MaybeDeclarations) ->
                             (T_RightHandSide)
sem_RightHandSide_Guarded (_range) (_guardedexpressions) (_where) (_lhs_allPatterns) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            RightHandSide_Guarded _range_self _guardedexpressions_self _where_self
        (_beta) =
            TVar _lhs_betaUnique
        (_oneLineTree) =
            \assign -> Node
                (  [ punctuate " " [ ge assign | ge <- _guardedexpressions_oneLineTree ] ]
                ++ case _where_oneLineTree of
                    Nothing -> []
                    Just ds -> [ Text " where ", encloseSep "{" "; " "}" ds ]
                )
        ( _range_self) =
            (_range )
        ( _guardedexpressions_assumptions,_guardedexpressions_betaUnique,_guardedexpressions_betas,_guardedexpressions_collectednotypedef,_guardedexpressions_constraintslist,_guardedexpressions_matchIO,_guardedexpressions_oneLineTree,_guardedexpressions_self,_guardedexpressions_typeAnnotations,_guardedexpressions_uniqueSecondRound) =
            (_guardedexpressions (_lhs_allPatterns) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (length _guardedexpressions_constraintslist) (_beta) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _where_assumptions,_where_betaUnique,_where_collectednotypedef,_where_constraints,_where_matchIO,_where_oneLineTree,_where_self,_where_typeAnnotations,_where_uniqueSecondRound) =
            (_where (_lhs_allPatterns) (_guardedexpressions_assumptions) (_guardedexpressions_betaUnique) (_guardedexpressions_collectednotypedef) (ctNode _guardedexpressions_constraintslist) (_lhs_importEnvironment) (_guardedexpressions_matchIO) (_lhs_monos) (_guardedexpressions_typeAnnotations) (_guardedexpressions_uniqueSecondRound))
    in  ( _where_assumptions,_beta,_where_betaUnique,_where_collectednotypedef,_where_constraints,_where_matchIO,_oneLineTree,_self,_where_typeAnnotations,_where_uniqueSecondRound)
-- SimpleType --------------------------------------------------
-- semantic domain
type T_SimpleType = ( (SimpleType))
-- cata
sem_SimpleType :: (SimpleType) ->
                  (T_SimpleType)
sem_SimpleType ((SimpleType_SimpleType (_range) (_name) (_typevariables))) =
    (sem_SimpleType_SimpleType ((sem_Range (_range))) ((sem_Name (_name))) ((sem_Names (_typevariables))))
sem_SimpleType_SimpleType :: (T_Range) ->
                             (T_Name) ->
                             (T_Names) ->
                             (T_SimpleType)
sem_SimpleType_SimpleType (_range) (_name) (_typevariables) =
    let (_self) =
            SimpleType_SimpleType _range_self _name_self _typevariables_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
        ( _typevariables_isIdentifier,_typevariables_isOperator,_typevariables_isSpecial,_typevariables_oneLineTree,_typevariables_self) =
            (_typevariables )
    in  ( _self)
-- Statement ---------------------------------------------------
-- semantic domain
type T_Statement = ([((Expression, [String]), Core_TypingStrategy)]) ->
                   (Assumptions) ->
                   (Int) ->
                   ([(Name,Tps,Tp,Bool)]) ->
                   (ConstraintSet) ->
                   (Maybe Tp) ->
                   (ImportEnvironment) ->
                   (IO ()) ->
                   (Tps) ->
                   (TypeAnnotations) ->
                   (Int) ->
                   ( (Assumptions),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(Maybe Tp),(IO ()),(Tps),(Tree),(Statement),(TypeAnnotations),(Int))
-- cata
sem_Statement :: (Statement) ->
                 (T_Statement)
sem_Statement ((Statement_Empty (_range))) =
    (sem_Statement_Empty ((sem_Range (_range))))
sem_Statement ((Statement_Expression (_range) (_expression))) =
    (sem_Statement_Expression ((sem_Range (_range))) ((sem_Expression (_expression))))
sem_Statement ((Statement_Generator (_range) (_pattern) (_expression))) =
    (sem_Statement_Generator ((sem_Range (_range))) ((sem_Pattern (_pattern))) ((sem_Expression (_expression))))
sem_Statement ((Statement_Let (_range) (_declarations))) =
    (sem_Statement_Let ((sem_Range (_range))) ((sem_Declarations (_declarations))))
sem_Statement_Empty :: (T_Range) ->
                       (T_Statement)
sem_Statement_Empty (_range) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_generatorBeta) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Statement_Empty _range_self
        (_oneLineTree) =
            Text ""
        ( _range_self) =
            (_range )
    in  ( _lhs_assumptions,_lhs_betaUnique,_lhs_collectednotypedef,_lhs_constraints,_lhs_generatorBeta,_lhs_matchIO,_lhs_monos,_oneLineTree,_self,_lhs_typeAnnotations,_lhs_uniqueSecondRound)
sem_Statement_Expression :: (T_Range) ->
                            (T_Expression) ->
                            (T_Statement)
sem_Statement_Expression (_range) (_expression) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_generatorBeta) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Statement_Expression _range_self _expression_self
        (_beta) =
            TVar _lhs_betaUnique
        (_newcon) =
            [ (_expression_beta .==. ioType _beta) _cinfo ]
        (_cinfo) =
            \tppair ->
            CInfo { info       = (NTStatement,AltExpression,0, "")
                  , location   = "generator"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree ]
                  , typepair   = tppair
                  , properties = [ ]
                  }
        (_oneLineTree) =
            _expression_oneLineTree
        ( _range_self) =
            (_range )
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_self,_expression_typeAnnotations,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_lhs_betaUnique + 1) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) ([]) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _lhs_assumptions `combine` _expression_assumptions
         ,_expression_betaUnique
         ,_expression_collectednotypedef
         ,ctNode [ _newcon .<. _expression_constraints
                 , _lhs_constraints
                 ]
         ,Just _beta
         ,_expression_matchIO
         ,_lhs_monos
         ,_oneLineTree
         ,_self
         ,_expression_typeAnnotations
         ,_expression_uniqueSecondRound
         )
sem_Statement_Generator :: (T_Range) ->
                           (T_Pattern) ->
                           (T_Expression) ->
                           (T_Statement)
sem_Statement_Generator (_range) (_pattern) (_expression) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_generatorBeta) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Statement_Generator _range_self _pattern_self _expression_self
        ((_csetBinds,_assumptions')) =
            (_pattern_environment .===. _lhs_assumptions) _cinfoBind
        (_newcon) =
            [ (_expression_beta .==. ioType _pattern_beta) _cinfoResult ]
        (_cinfoResult) =
            \tppair ->
            CInfo { info       = (NTStatement, AltGenerator, 0, "result")
                  , location   = "generator"
                  , errorrange = _range_self
                  , sources    = [ sourceExpression _oneLineTree, sourceTerm _expression_oneLineTree ]
                  , typepair   = tppair
                  , properties = [ SubTermRange (getExprRange _expression_self) ]
                  }
        (_cinfoBind) =
            variableBindingCInfo (NTStatement, AltGenerator, 1)
        (_oneLineTree) =
            Node [ _pattern_oneLineTree, Text " <- ", _expression_oneLineTree ]
        ( _range_self) =
            (_range )
        ( _pattern_beta,_pattern_betaUnique,_pattern_constraints,_pattern_environment,_pattern_oneLineTree,_pattern_self) =
            (_pattern (_lhs_betaUnique) (_lhs_importEnvironment))
        ( _expression_assumptions,_expression_beta,_expression_betaUnique,_expression_collectednotypedef,_expression_constraints,_expression_matchIO,_expression_matches,_expression_oneLineTree,_expression_self,_expression_typeAnnotations,_expression_uniqueSecondRound) =
            (_expression (_lhs_allPatterns) (_pattern_betaUnique) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) ([]) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
    in  ( _assumptions' `combine` _expression_assumptions
         ,_expression_betaUnique
         ,_expression_collectednotypedef
         ,_newcon .>. _csetBinds .>>.
          ctNode [ _pattern_constraints
                 , _expression_constraints
                 , _lhs_constraints
                 ]
         ,Nothing
         ,_expression_matchIO
         ,eltsFM _pattern_environment ++ _lhs_monos
         ,_oneLineTree
         ,_self
         ,_expression_typeAnnotations
         ,_expression_uniqueSecondRound
         )
sem_Statement_Let :: (T_Range) ->
                     (T_Declarations) ->
                     (T_Statement)
sem_Statement_Let (_range) (_declarations) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_generatorBeta) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            Statement_Let _range_self _declarations_self
        ((_aset,_cset,_monoTable)) =
            performBindingGroup _lhs_monos _declarations_typeSignatures (_mybdggroup : _declarations_bindingGroups)
        (_mybdggroup) =
            (noAssumptions ,_lhs_assumptions,[_lhs_constraints])
        ((_anns,_notypedefs)) =
            findTypeAnnotations False _lhs_monos _declarations_typeSignatures (_mybdggroup : _declarations_bindingGroups)
        ((_collectTypeConstructors,_collectValueConstructors,_collectTypeSynonyms,_collectConstructorEnv,_derivedFunctions,_operatorFixities)) =
            internalError "PartialSyntax.ag" "n/a" "toplevel Statement"
        (_oneLineTree) =
            Node [ Text "let ", encloseSep "{" "; " "}" _declarations_oneLineTree ]
        ( _range_self) =
            (_range )
        ( _declarations_betaUnique,_declarations_bindingGroups,_declarations_collectednotypedef,_declarations_matchIO,_declarations_oneLineTree,_declarations_self,_declarations_typeAnnotations,_declarations_typeSignatures,_declarations_uniqueSecondRound) =
            (_declarations (_lhs_allPatterns) (_lhs_betaUnique) ([]) (_lhs_collectednotypedef) (_lhs_importEnvironment) (_lhs_matchIO) (_monoTable) (_lhs_monos) (_lhs_typeAnnotations) (emptyFM) (_lhs_uniqueSecondRound))
    in  ( _aset,_declarations_betaUnique,_notypedefs ++ _declarations_collectednotypedef,_cset,Nothing,_declarations_matchIO,_lhs_monos,_oneLineTree,_self,_anns ++ _declarations_typeAnnotations,_declarations_uniqueSecondRound)
-- Statements --------------------------------------------------
-- semantic domain
type T_Statements = ([((Expression, [String]), Core_TypingStrategy)]) ->
                    (Assumptions) ->
                    (Int) ->
                    ([(Name,Tps,Tp,Bool)]) ->
                    (ConstraintSet) ->
                    (Maybe Tp) ->
                    (ImportEnvironment) ->
                    (IO ()) ->
                    (Tps) ->
                    (TypeAnnotations) ->
                    (Int) ->
                    ( (Assumptions),(Int),([(Name,Tps,Tp,Bool)]),(ConstraintSet),(Maybe Tp),(IO ()),( [ Tree] ),(Statements),(TypeAnnotations),(Int))
-- cata
sem_Statements :: (Statements) ->
                  (T_Statements)
sem_Statements (list) =
    (foldr (sem_Statements_Cons) (sem_Statements_Nil) ((map sem_Statement list)))
sem_Statements_Cons :: (T_Statement) ->
                       (T_Statements) ->
                       (T_Statements)
sem_Statements_Cons (_hd) (_tl) (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_generatorBeta) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_assumptions,_hd_betaUnique,_hd_collectednotypedef,_hd_constraints,_hd_generatorBeta,_hd_matchIO,_hd_monos,_hd_oneLineTree,_hd_self,_hd_typeAnnotations,_hd_uniqueSecondRound) =
            (_hd (_lhs_allPatterns) (_tl_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_tl_constraints) (_lhs_generatorBeta) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound))
        ( _tl_assumptions,_tl_betaUnique,_tl_collectednotypedef,_tl_constraints,_tl_generatorBeta,_tl_matchIO,_tl_oneLineTree,_tl_self,_tl_typeAnnotations,_tl_uniqueSecondRound) =
            (_tl (_lhs_allPatterns) (_lhs_assumptions) (_hd_betaUnique) (_hd_collectednotypedef) (_lhs_constraints) (_hd_generatorBeta) (_lhs_importEnvironment) (_hd_matchIO) (_hd_monos) (_hd_typeAnnotations) (_hd_uniqueSecondRound))
    in  ( _hd_assumptions,_tl_betaUnique,_tl_collectednotypedef,_hd_constraints,_tl_generatorBeta,_tl_matchIO,_hd_oneLineTree  :  _tl_oneLineTree,_self,_tl_typeAnnotations,_tl_uniqueSecondRound)
sem_Statements_Nil :: (T_Statements)
sem_Statements_Nil (_lhs_allPatterns) (_lhs_assumptions) (_lhs_betaUnique) (_lhs_collectednotypedef) (_lhs_constraints) (_lhs_generatorBeta) (_lhs_importEnvironment) (_lhs_matchIO) (_lhs_monos) (_lhs_typeAnnotations) (_lhs_uniqueSecondRound) =
    let (_self) =
            []
    in  ( _lhs_assumptions,_lhs_betaUnique,_lhs_collectednotypedef,_lhs_constraints,_lhs_generatorBeta,_lhs_matchIO,[],_self,_lhs_typeAnnotations,_lhs_uniqueSecondRound)
-- Strings -----------------------------------------------------
-- semantic domain
type T_Strings = ( ( [ Tree] ),(Strings))
-- cata
sem_Strings :: (Strings) ->
               (T_Strings)
sem_Strings (list) =
    (foldr (sem_Strings_Cons) (sem_Strings_Nil) (list))
sem_Strings_Cons :: (String) ->
                    (T_Strings) ->
                    (T_Strings)
sem_Strings_Cons (_hd) (_tl) =
    let (_self) =
            (:) _hd _tl_self
        ( _tl_oneLineTree,_tl_self) =
            (_tl )
    in  ( _tl_oneLineTree,_self)
sem_Strings_Nil :: (T_Strings)
sem_Strings_Nil  =
    let (_self) =
            []
    in  ( [],_self)
-- Type --------------------------------------------------------
-- semantic domain
type T_Type = ( (Type))
-- cata
sem_Type :: (Type) ->
            (T_Type)
sem_Type ((Type_Application (_range) (_prefix) (_function) (_arguments))) =
    (sem_Type_Application ((sem_Range (_range))) (_prefix) ((sem_Type (_function))) ((sem_Types (_arguments))))
sem_Type ((Type_Constructor (_range) (_name))) =
    (sem_Type_Constructor ((sem_Range (_range))) ((sem_Name (_name))))
sem_Type ((Type_Exists (_range) (_typevariables) (_type))) =
    (sem_Type_Exists ((sem_Range (_range))) ((sem_Names (_typevariables))) ((sem_Type (_type))))
sem_Type ((Type_Forall (_range) (_typevariables) (_type))) =
    (sem_Type_Forall ((sem_Range (_range))) ((sem_Names (_typevariables))) ((sem_Type (_type))))
sem_Type ((Type_Parenthesized (_range) (_type))) =
    (sem_Type_Parenthesized ((sem_Range (_range))) ((sem_Type (_type))))
sem_Type ((Type_Qualified (_range) (_context) (_type))) =
    (sem_Type_Qualified ((sem_Range (_range))) ((sem_ContextItems (_context))) ((sem_Type (_type))))
sem_Type ((Type_Variable (_range) (_name))) =
    (sem_Type_Variable ((sem_Range (_range))) ((sem_Name (_name))))
sem_Type_Application :: (T_Range) ->
                        (Bool) ->
                        (T_Type) ->
                        (T_Types) ->
                        (T_Type)
sem_Type_Application (_range) (_prefix) (_function) (_arguments) =
    let (_self) =
            Type_Application _range_self _prefix _function_self _arguments_self
        ( _range_self) =
            (_range )
        ( _function_self) =
            (_function )
        ( _arguments_self) =
            (_arguments )
    in  ( _self)
sem_Type_Constructor :: (T_Range) ->
                        (T_Name) ->
                        (T_Type)
sem_Type_Constructor (_range) (_name) =
    let (_self) =
            Type_Constructor _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( _self)
sem_Type_Exists :: (T_Range) ->
                   (T_Names) ->
                   (T_Type) ->
                   (T_Type)
sem_Type_Exists (_range) (_typevariables) (_type) =
    let (_self) =
            Type_Exists _range_self _typevariables_self _type_self
        ( _range_self) =
            (_range )
        ( _typevariables_isIdentifier,_typevariables_isOperator,_typevariables_isSpecial,_typevariables_oneLineTree,_typevariables_self) =
            (_typevariables )
        ( _type_self) =
            (_type )
    in  ( _self)
sem_Type_Forall :: (T_Range) ->
                   (T_Names) ->
                   (T_Type) ->
                   (T_Type)
sem_Type_Forall (_range) (_typevariables) (_type) =
    let (_self) =
            Type_Forall _range_self _typevariables_self _type_self
        ( _range_self) =
            (_range )
        ( _typevariables_isIdentifier,_typevariables_isOperator,_typevariables_isSpecial,_typevariables_oneLineTree,_typevariables_self) =
            (_typevariables )
        ( _type_self) =
            (_type )
    in  ( _self)
sem_Type_Parenthesized :: (T_Range) ->
                          (T_Type) ->
                          (T_Type)
sem_Type_Parenthesized (_range) (_type) =
    let (_self) =
            Type_Parenthesized _range_self _type_self
        ( _range_self) =
            (_range )
        ( _type_self) =
            (_type )
    in  ( _self)
sem_Type_Qualified :: (T_Range) ->
                      (T_ContextItems) ->
                      (T_Type) ->
                      (T_Type)
sem_Type_Qualified (_range) (_context) (_type) =
    let (_self) =
            Type_Qualified _range_self _context_self _type_self
        ( _range_self) =
            (_range )
        ( _context_self) =
            (_context )
        ( _type_self) =
            (_type )
    in  ( _self)
sem_Type_Variable :: (T_Range) ->
                     (T_Name) ->
                     (T_Type)
sem_Type_Variable (_range) (_name) =
    let (_self) =
            Type_Variable _range_self _name_self
        ( _range_self) =
            (_range )
        ( _name_isIdentifier,_name_isOperator,_name_isSpecial,_name_oneLineTree,_name_self) =
            (_name )
    in  ( _self)
-- Types -------------------------------------------------------
-- semantic domain
type T_Types = ( (Types))
-- cata
sem_Types :: (Types) ->
             (T_Types)
sem_Types (list) =
    (foldr (sem_Types_Cons) (sem_Types_Nil) ((map sem_Type list)))
sem_Types_Cons :: (T_Type) ->
                  (T_Types) ->
                  (T_Types)
sem_Types_Cons (_hd) (_tl) =
    let (_self) =
            (:) _hd_self _tl_self
        ( _hd_self) =
            (_hd )
        ( _tl_self) =
            (_tl )
    in  ( _self)
sem_Types_Nil :: (T_Types)
sem_Types_Nil  =
    let (_self) =
            []
    in  ( _self)

