-------------------------------------------------------------------------------
--
--   *** The Helium Compiler : Static Analysis ***
--               ( Bastiaan Heeren )
--
-- TypeInferenceInfo.ag : Additional information (a local attribute) is
--    provided for each type constraint.
--
-------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
-- Constraint Information : Body

SEM Body | Body loc . cinfo =
  \var tppair ->
  CInfo { info       = (NTBody, AltBody, 0, show var)
        , location   = "variable"
        , errorrange = getNameRange var
        , sources    = [ sourceExpression (Text (show var)) ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted
                       , IsImported var
                       ]
        }

---------------------------------------------------------------------------------------
-- Constraint Information : Declaration

SEM Declaration | FunctionBindings loc . cinfo =
  \tppair ->
  CInfo { info       = (NTDeclaration, AltFunctionBindings, 0, show @bindings.name)
        , location   = "function bindings (INTERNAL ERROR)"
        , errorrange = @range.self
        , sources    = [ ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , SuperHighlyTrusted
                       , FuntionBindingEdge @bindings.numberOfPatterns
                       ]
        }

SEM Declaration | PatternBinding loc . cinfo =
  \tppair ->
  CInfo { info       = (NTDeclaration, AltPatternBinding, 0, "")
        , location   = "right hand side"
        , errorrange = getRHSRange @righthandside.self
        , sources    = [ sourceExpression (@righthandside.oneLineTree "") ]
        , typepair   = tppair
        , properties = [ ]
        }

---------------------------------------------------------------------------------------
-- Type Inferencing : FunctionBinding
SEM FunctionBinding | FunctionBinding loc . cinfoLeft =
  \num txt tppair ->
  CInfo { info       = (NTFunctionBinding, AltFunctionBinding, 0, "left "++show num)
        , location   = "pattern of function binding"
        , errorrange = @range.self
        , sources    = [ sourcePattern txt ]
        , typepair   = tppair
        , properties = [ ]
        }

SEM FunctionBinding | FunctionBinding loc . cinfoRight =
  \tppair ->
  CInfo { info       = (NTFunctionBinding, AltFunctionBinding, 1, "right")
        , location   = "right hand side"
        , errorrange = @range.self
        , sources    = [ sourceTerm (@righthandside.oneLineTree "") ]
        , typepair   = tppair
        , properties = [ SubTermRange (getRHSRange @righthandside.self) ]                       
        }

SEM FunctionBinding | FunctionBinding loc . cinfoBind =
   variableBindingCInfo (NTFunctionBinding, AltFunctionBinding, 2)

---------------------------------------------------------------------------------------
-- Type Inferencing : Expression

-- Expression.Literal
SEM Expression | Literal loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression, AltLiteral, 0, "")
        , location   = "literal"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted
                       , IsLiteral @literal.self
                       ]
        }

-- Expression.Constructor
SEM Expression | Constructor loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression, AltConstructor, 0, "")
        , location   = "constructor"
        , errorrange = @range.self
        , sources    = [ sourceExpression @name.oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted
                       , IsImported @name.self
                       ]
        }

-- Expression.NormalApplication
SEM Expression | NormalApplication loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression, AltNormalApplication, 0, "")
        , location   = "application"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @function.oneLineTree ]
        , typepair   = tppair
        , properties = [ ApplicationEdge False (zip3 @arguments.oneLineTree
                                                     @arguments.betas
                                                     (map getExprRange @arguments.self)
                                               )
                       , SubTermRange (getExprRange @function.self)
                       ]
        }

-- Expression.InfixApplication
SEM Expression | InfixApplication loc . cinfoOperator =
  \tppair ->
  CInfo { info       = (NTExpression, AltInfixApplication, 0, "operator")
        , location   = "infix application"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceOperator @operatorName ]
        , typepair   = tppair
        , properties = (if @leftExpression.section || @rightExpression.section
                          then [ HighlyTrusted ]
                          else [ ApplicationEdge True
                                         [ ( convertMaybeOneLineTree @leftExpression.oneLineTree 
                                           , @leftExpression.beta
                                           , getMaybeExprRange @leftExpression.self
                                           )
                                         , ( convertMaybeOneLineTree @rightExpression.oneLineTree
                                           , @rightExpression.beta
                                           , getMaybeExprRange @rightExpression.self
                                           )
                                         ] ])
                       ++
                       [ SubTermRange (getExprRange @operator.self) ]
        }

SEM Expression | InfixApplication loc . cinfoComplete =
  \tppair ->
  CInfo { info       = (NTExpression, AltInfixApplication, 1, "")
        , location   = "infix application (INTERNAL ERROR)"
        , errorrange = @range.self
        , sources    = [ ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , SuperHighlyTrusted
                       ]
        }

SEM Expression | InfixApplication loc . cinfoLeftSection =
  \tppair ->
  CInfo { info       = (NTExpression, AltInfixApplication, 2, "left")
        , location   = "left section"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree ]
        , typepair   = tppair
        , properties = [ ]
        }

SEM Expression | InfixApplication loc . cinfoRightSection =
  \tppair ->
  CInfo { info       = (NTExpression, AltInfixApplication, 3, "right")
        , location   = "right section"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree ]
        , typepair   = tppair
        , properties = [ ]
        }

SEM Expression | InfixApplication loc . cinfoEmpty =
  \tppair ->
  CInfo { info       = (NTExpression, AltInfixApplication, 4, "empty")
        , location   = "infix application"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted
                       ]
        }

-- Expression.If
SEM Expression | If loc . cinfoGuard =
  \tppair ->
  CInfo { info       = (NTExpression, AltIf, 0, "guard")
        , location   = "conditional"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @guardExpression.oneLineTree  ]
        , typepair   = tppair
        , properties = [ SubTermRange (getExprRange @guardExpression.self) ]
        }

SEM Expression | If loc . cinfoThen =
  \tppair ->
  CInfo { info       = (NTExpression, AltIf, 1, "then")
        , location   = "then branch of conditional"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @thenExpression.oneLineTree ]
        , typepair   = tppair
        , properties = [ SubTermRange (getExprRange @thenExpression.self) 
                       , Unifier (tpToInt @beta) ]
        }

SEM Expression | If loc . cinfoElse =
  \tppair ->
  CInfo { info       = (NTExpression, AltIf,2, "else")
        , location   = "else branch of conditional"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @elseExpression.oneLineTree ]
        , typepair   = tppair
        , properties = [ SubTermRange (getExprRange @elseExpression.self) 
                       , Unifier (tpToInt @beta) ]
        }

-- Expression.Lambda
SEM Expression | Lambda loc . cinfoBind =
   variableBindingCInfo (NTExpression, AltLambda, 0)

SEM Expression | Lambda loc . cinfoType =
  \tppair ->
  CInfo { info       = (NTExpression, AltLambda, 1, "type")
        , location   = "lambda abstraction"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint ]
        }

-- Expression.Case
SEM Expression | Case loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression, AltCase, 0, "")
        , location   = "scrutinee of case expression"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @expression.oneLineTree ]
        , typepair   = tppair
        , properties = [ SubTermRange (getExprRange @expression.self) ]
        }

-- Expression.Let
SEM Expression | Let loc . cinfoType =
  \tppair ->
  CInfo { info       = (NTExpression, AltLet, 0, "")
        , location   = "let expression (INTERNAL ERROR)"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @expression.oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , SuperHighlyTrusted
                       , SubTermRange (getExprRange @expression.self)
                       ]
        }

-- Expression.Do
SEM Expression | Do loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression, AltDo, 0, "")
        , location   = "do-expression"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint ]
        }

-- Expression.List
SEM Expression | List loc . cinfoElem =
  \(elemtext, elemrange) tppair ->
  CInfo { info       = (NTExpression, AltList, 0, "element")
        , location   = "element of list"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm elemtext ]
        , typepair   = tppair
        , properties = [ SubTermRange elemrange ] ++
                       if length @expressions.betas > 1 then [] else [ HighlyTrusted ]
        }

SEM Expression | List loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTExpression, AltList, 1, "result")
        , location   = "list"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint ]
        }

-- Expression.Tuple   
SEM Expression | Tuple loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression, AltTuple, 0, "")
        , location   = "tuple"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , IsTupleEdge ]
        }
        
-- Expression.Comprehension   
SEM Expression | Comprehension loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression, AltComprehension, 0, "")
        , location   = "list comprehension"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint ]
        }

-- Expression.Typed
SEM Expression | Typed loc . cinfoExpr =
  \tppair ->
  CInfo { info       = (NTExpression, AltTyped, 0, "expression")
        , location   = "type annotation"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @expression.oneLineTree  ]
        , typepair   = tppair
        , properties = [ SubTermRange (getExprRange @expression.self) ]
        }

SEM Expression | Typed loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTExpression, AltTyped, 1, "result")
        , location   = "type annotation"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint ]     {- ??? -}
        }

-- Expression.Enum
SEM Expression | Enum loc . cinfoFrom =
  \tppair ->
  CInfo { info       = (NTExpression, AltEnum, 0, "from")
        , location   = "enumeration"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @from.oneLineTree ]
        , typepair   = tppair
        , properties = [ SubTermRange (getExprRange @from.self) ]
        }

SEM Expression | Enum loc . cinfoThen =
  \tppair ->
  CInfo { info       = (NTExpression, AltEnum, 1, "then")
        , location   = "enumeration"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm (convertMaybeOneLineTree @then.oneLineTree) ]
        , typepair   = tppair
        , properties = [ SubTermRange (getMaybeExprRange @then.self) ]
        }

SEM Expression | Enum loc . cinfoTo =
  \tppair ->
  CInfo { info       = (NTExpression, AltEnum, 2, "to")
        , location   = "enumeration"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm (convertMaybeOneLineTree @to.oneLineTree) ]
        , typepair   = tppair
        , properties = [ SubTermRange (getMaybeExprRange @to.self) ]
        }

SEM Expression | Enum loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTExpression, AltEnum, 3, "result")
        , location   = "enumeration"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint ]
        }

SEM Expression | Negate loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression, AltNegate, 0, "")
        , location   = "negation"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceOperator (Text "-") ]
        , typepair   = tppair
        , properties = [ Negation True ]
        }

SEM Expression | NegateFloat loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression, AltNegateFloat, 0, "")
        , location   = "negation"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceOperator (Text "-.") ]
        , typepair   = tppair
        , properties = [ Negation False ]
        }

---------------------------------------------------------------------------------------
-- Type Inferencing : GuardedExpression

SEM GuardedExpression | GuardedExpression loc . cinfoGuard =
  \tppair ->
  CInfo { info       = (NTGuardedExpression, AltGuardedExpression, 0, "guard")
        , location   = "guard"
        , errorrange = getExprRange @guard.self
        , sources    = [ sourceExpression @guard.oneLineTree ]
        , typepair   = tppair
        , properties = [ ]
        }

SEM GuardedExpression | GuardedExpression loc . cinfoExpr =
  \tppair ->
  CInfo { info       = (NTGuardedExpression, AltGuardedExpression, 1, "expression")
        , location   = "guarded expression"
        , errorrange = @range.self
        , sources    = [ sourceExpression @expression.oneLineTree ]
        , typepair   = tppair
        , properties = if @lhs.numberOfGuards > 1 then [] else [ HighlyTrusted ]
        }

---------------------------------------------------------------------------------------
-- Type Inferencing : Pattern

-- Pattern.Literal
SEM Pattern | Literal loc . cinfo =
  \tppair ->
  CInfo { info       = (NTPattern, AltLiteral, 0, "")
        , location   = "literal pattern"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted
                       , IsLiteral @literal.self
                       ]
        }

-- Pattern.Constructor
SEM Pattern | Constructor loc . cinfoConstructor =
  \tppair ->
  CInfo { info       = (NTPattern, AltConstructor, 0, "")
        , location   = "pattern constructor"
        , errorrange = getNameRange @name.self
        , sources    = [ sourcePattern @oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted
                       ]
        }

SEM Pattern | Constructor loc . cinfoApply =
  \tppair ->
  CInfo { info       = (NTPattern, AltConstructor, 1, "apply")
        , location   = if @patterns.numberOfPatterns == 0
                         then "pattern constructor"
                         else "pattern application"
        , errorrange = @range.self
        , sources    = if @patterns.numberOfPatterns == 0
                         then [ sourcePattern @oneLineTree                            ]
                         else [ sourcePattern @oneLineTree, sourceConstructor @name.oneLineTree ]
        , typepair   = tppair
        , properties = [ SubTermRange (getNameRange @name.self) ] ++
                       if @patterns.numberOfPatterns == 0
                         then [HighlyTrusted]          
                         else [ ApplicationEdge False (zip3 @patterns.oneLineTree 
                                                            @patterns.betas
                                                            (map getPatRange (@patterns.self))
                                                      )]
                           
        }

-- Pattern.InfixConstructor
SEM Pattern | InfixConstructor loc . cinfoConstructor =
  \tppair ->
  CInfo { info       = (NTPattern, AltInfixConstructor, 0, "")
        , location   = "pattern constructor"
        , errorrange = getNameRange @constructorOperator.self
        , sources    = [ sourceOperator @constructorOperator.oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted
                       , SubTermRange (getNameRange @constructorOperator.self)
                       ]
        }

SEM Pattern | InfixConstructor loc . cinfoApply =
  \tppair ->
  CInfo { info       = (NTPattern, AltInfixConstructor, 1, "apply")
        , location   = "infix pattern application"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree, sourceConstructor (Text (showNameAsOperator @constructorOperator.self))]
        , typepair   = tppair
        , properties = [ SubTermRange (getNameRange @constructorOperator.self)
                       , ApplicationEdge True
                                         [ (@leftPattern.oneLineTree ,@leftPattern.beta ,getPatRange (@leftPattern.self))
                                         , (@rightPattern.oneLineTree,@rightPattern.beta,getPatRange (@rightPattern.self))
                                         ]
                       ]  
        }

-- Pattern.List
SEM Pattern | List loc . cinfoElem =
  \(elemtext, elemrange) tppair ->
  CInfo { info       = (NTPattern, AltList, 0, "element")
        , location   = "element of pattern list"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree, sourceTerm elemtext ]
        , typepair   = tppair
        , properties = [ SubTermRange elemrange ] ++
                       if length @patterns.constraintslist > 1 then [] else [ HighlyTrusted  ]
        }

SEM Pattern | List loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTPattern, AltList, 1, "result")
        , location   = "pattern list"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint ]
        }

-- Pattern.Tuple
SEM Pattern | Tuple loc . cinfo =
  \tppair ->
  CInfo { info       = (NTPattern, AltTuple, 0, "result")
        , location   = "pattern tuple"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , IsTupleEdge
                       ]
        }

-- Pattern.Negate
SEM Pattern | Negate loc . cinfo =
  \tppair ->
  CInfo { info       = (NTPattern, AltNegate, 0, "")
        , location   = "pattern negation"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint ]
        }

-- Pattern.As
SEM Pattern |  As loc . cinfo =
  \tppair ->
  CInfo { info       = (NTPattern, AltAs, 0, "")
        , location   = "as pattern"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm (Text (show @name.self)) ]
        , typepair   = tppair
        , properties = [ SubTermRange (getNameRange @name.self) ]
        }

-- Pattern.NegateFloat
SEM Pattern | NegateFloat loc . cinfo =
  \tppair ->
  CInfo { info       = (NTPattern, AltNegateFloat, 0, "")
        , location   = "pattern negation"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , NegationResult
                       ]
        }

---------------------------------------------------------------------------------------
-- Type Inferencing : Alternative

SEM Alternative | Alternative loc . cinfoLeft =
  \tppair ->
  CInfo { info       = (NTAlternative, AltAlternative, 0, "left")
        , location   = "case pattern"
        , errorrange = @range.self
        , sources    = [ sourcePattern @pattern.oneLineTree ]
        , typepair   = tppair
        , properties = [ SubTermRange (getPatRange @pattern.self) ]
        }

SEM Alternative | Alternative loc . cinfoRight =
  \tppair ->
  CInfo { info       = (NTAlternative, AltAlternative, 1, "right")
        , location   = "right-hand side of case alternative"
        , errorrange = @range.self
        , sources    = [ sourceExpression (@righthandside.oneLineTree "") ]
        , typepair   = tppair
        , properties = [ SubTermRange (getRHSRange @righthandside.self) ] ++
                       if @lhs.nrOfAlternatives > 1 then [] else [ HighlyTrusted ]
        }

SEM Alternative | Alternative loc . cinfoBind =
   variableBindingCInfo (NTAlternative, AltAlternative, 2)

---------------------------------------------------------------------------------------
-- Type Inferencing : Statement

SEM Statement | Expression loc . cinfo =
  \tppair ->
  CInfo { info       = (NTStatement,AltExpression,0, "")
        , location   = "generator"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree ]
        , typepair   = tppair
        , properties = [ ]
        }

SEM Statement | Generator loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTStatement, AltGenerator, 0, "result")
        , location   = "generator"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @expression.oneLineTree ]
        , typepair   = tppair
        , properties = [ SubTermRange (getExprRange @expression.self) ]
        }

SEM Statement | Generator loc . cinfoBind =
   variableBindingCInfo (NTStatement, AltGenerator, 1)

---------------------------------------------------------------------------------------
-- Type Inferencing : Qualifier

SEM Qualifier | Guard loc . cinfo =
  \tppair ->
  CInfo { info       = (NTQualifier,AltGuard,0, "")
        , location   = "boolean qualifier"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ ]
        }

SEM Qualifier | Generator loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTQualifier,AltGenerator,0, "result")
        , location   = "generator"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @expression.oneLineTree ]
        , typepair   = tppair
        , properties = [ SubTermRange (getExprRange @expression.self) ]
        }

SEM Qualifier | Generator loc . cinfoBind =
   variableBindingCInfo (NTQualifier,AltGenerator,1 )

----------------------------------------------------------------------------------------------------------------------------------
-- Constraint Info : Variable Binding

{
cinfoBindingGroupExplicitTypedBinding :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoBindingGroupExplicitTypedBinding =
  \name tppair ->
  CInfo { info       = (NTBindingGroup,AltBindingGroup,3, "explicit typed binding, "++show name)
        , location   = "explicitly typed binding"
        , errorrange = getNameRange name
        , sources    = [ sourceTerm (Text (show name))]
        , typepair   = tppair
        , properties = [ {- FolkloreConstraint -}
                         ExplicitTypedBinding
                       , HighlyTrusted 
                       ]
        }

variableBindingCInfo :: (InfoNT, InfoAlt, Int) -> Name -> (Tp,Tp) -> HeliumConstraintInfo
variableBindingCInfo (infoNT,infoAlt,i) var tppair =
  CInfo { info       = (infoNT,infoAlt,i,show var) 
        , location   = "variable"
        , errorrange = getNameRange var
        , sources    = [ sourceExpression (Text (show var)) ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint ]  
        }

cinfoSameBindingGroup :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoSameBindingGroup var = variableBindingCInfo (NTBindingGroup,AltBindingGroup,0) var

cinfoBindingGroupImplicit :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoBindingGroupImplicit =
  \var tppair ->   
  CInfo { info       = (NTBindingGroup,AltBindingGroup,1,"implicit, "++show var)
        , location   = "variable"
        , errorrange = getNameRange var
        , sources    = [ sourceExpression (Text (show var)) ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted ]
        }

cinfoBindingGroupExplicit :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoBindingGroupExplicit =
  \var tppair ->
  CInfo { info       = (NTBindingGroup,AltBindingGroup,2, "explicit, "++show var)
        , location   = "variable"
        , errorrange = getNameRange var
        , sources    = [ sourceExpression (Text (show var)) ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint ]  
        }
}

----------------------------------------------------------------------------------------------------------------------------------
-- Several utility functions

SEM LeftHandSide [ | | patternTrees:{[Tree]} ]
    | Function      lhs . patternTrees = @patterns.oneLineTree
    | Infix         lhs . patternTrees = [@leftPattern.oneLineTree, @rightPattern.oneLineTree]
    | Parenthesized lhs . patternTrees = @lefthandside.patternTrees ++ @patterns.oneLineTree
{
convertMaybeOneLineTree :: Maybe Tree -> Tree
convertMaybeOneLineTree = maybe (Text "") id
    
getRHSRange :: RightHandSide -> Range
getRHSRange (RightHandSide_Expression r _ _) = r
getRHSRange (RightHandSide_Guarded r _ _) = r

getMaybeExprRange :: MaybeExpression -> Range
getMaybeExprRange (MaybeExpression_Just expr) = getExprRange expr
getMaybeExprRange (MaybeExpression_Nothing)   = noRange

tpToInt :: Tp -> Int
tpToInt tp = case ftv tp of
               [i] -> i
               _   -> (-1)

sourceTerm, sourceExpression, sourcePattern, sourceOperator :: Tree -> (String, Tree)
sourceTerm        = (,) "term"
sourceExpression  = (,) "expression"
sourcePattern     = (,) "pattern"
sourceOperator    = (,) "operator"
sourceConstructor = (,) "constructor"
}
