-------------------------------------------------------------------------------
--
--   *** The Helium Compiler : Static Analysis ***
--               ( Bastiaan Heeren )
--
-- TypeInferenceInfo.ag : Additional information (a local attribute) is 
--    provided for each type constraint.
--
-------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
-- Constraint Information : Body

SEM Body | Body loc . cinfo =
  \var tppair ->
  CInfo { info       = (NTBody, AltBody, 0, show var)
        , location   = "variable"
        , errorrange = getNameRange var
        , sources    = [ sourceExpression (Text (show var)) ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted
                       , IsImported var
                       , Size @declarations.size ]
        }

---------------------------------------------------------------------------------------
-- Constraint Information : Declaration

SEM Declaration | FunctionBindings loc . cinfo =
  \tppair ->
  CInfo { info       = (NTDeclaration, AltFunctionBindings, 0, show @bindings.name)
        , location   = "function bindings (INTERNAL ERROR)"
        , errorrange = @range.self
        , sources    = [ ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , SuperHighlyTrusted
                       , FuntionBindingEdge @bindings.numberOfPatterns 
                       , Size @bindings.size ]
        }
        
SEM Declaration | PatternBinding loc . cinfo =
  \tppair ->
  CInfo { info       = (NTDeclaration, AltPatternBinding, 0, "")
        , location   = "right hand side"
        , errorrange = getRHSRange @righthandside.self
        , sources    = [ sourceExpression (@righthandside.oneLineTree "") ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }        

---------------------------------------------------------------------------------------
-- Type Inferencing : FunctionBinding
SEM FunctionBinding | FunctionBinding loc . cinfoLeft =
  \num txt tppair ->
  CInfo { info       = (NTFunctionBinding, AltFunctionBinding, 0, "left "++show num)
        , location   = "pattern of function binding"
        , errorrange = @range.self
        , sources    = [ sourcePattern txt ]
        , typepair   = tppair
        , properties = [ Size @size ] 
        }
        
SEM FunctionBinding | FunctionBinding loc . cinfoRight =
  \tppair ->
  CInfo { info       = (NTFunctionBinding, AltFunctionBinding, 1, "right")
        , location   = "right hand side"
        , errorrange = @range.self
        , sources    = [ sourceTerm (@righthandside.oneLineTree "") ]
        , typepair   = tppair
        , properties = [ Size @size ]
        }

SEM FunctionBinding | FunctionBinding loc . cinfoBind = 
   variableBindingCInfo (NTFunctionBinding, AltFunctionBinding, 2)        
   
---------------------------------------------------------------------------------------
-- Type Inferencing : Expression

-- Expression.Literal     
SEM Expression | Literal loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression, AltLiteral, 0, "")
        , location   = "literal"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted
                       , IsLiteral @literal.self 
                       , Size @size ]  
        }                                     

-- Expression.Constructor       
SEM Expression | Constructor loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression, AltConstructor, 0, "")
        , location   = "constructor"
        , errorrange = @range.self
        , sources    = [ sourceExpression @name.oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted
                       , IsImported @name.self 
                       , Size @size ]
        }
        
-- Expression.NormalApplication    
SEM Expression | NormalApplication loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression, AltNormalApplication, 0, "")
        , location   = "application"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @function.oneLineTree ]
        , typepair   = tppair
        , properties = [ ApplicationEdge False (zip @arguments.oneLineTree @arguments.betas)  
                       , Size @size ]  
        }
        
-- Expression.InfixApplication
SEM Expression | InfixApplication loc . cinfoOperator =
  \tppair ->
  CInfo { info       = (NTExpression, AltInfixApplication, 0, "operator")
        , location   = "infix application"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm (@operator.oneLineTree)]
        , typepair   = tppair
        , properties = (if @leftExpression.section || @rightExpression.section 
                          then [ HighlyTrusted ] 
                          else [ ApplicationEdge True
                                         [ (convertMaybeOneLineTree @leftExpression.oneLineTree ,@leftExpression.beta )
                                         , (convertMaybeOneLineTree @rightExpression.oneLineTree,@rightExpression.beta)
                                         ] ]) 
                       ++
                       [ Size @size ]
        }

SEM Expression | InfixApplication loc . cinfoComplete =
  \tppair ->
  CInfo { info       = (NTExpression, AltInfixApplication, 1, "")
        , location   = "infix application (INTERNAL ERROR)"
        , errorrange = @range.self
        , sources    = [ ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , SuperHighlyTrusted 
                       , Size @size ]  
        }

SEM Expression | InfixApplication loc . cinfoLeftSection = 
  \tppair ->
  CInfo { info       = (NTExpression, AltInfixApplication, 2, "left")
        , location   = "left section"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]  
        }
        
SEM Expression | InfixApplication loc . cinfoRightSection = 
  \tppair ->
  CInfo { info       = (NTExpression, AltInfixApplication, 3, "right")
        , location   = "right section"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]  
        }        

SEM Expression | InfixApplication loc . cinfoEmpty =
  \tppair ->
  CInfo { info       = (NTExpression, AltInfixApplication, 4, "empty")
        , location   = "infix application"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted 
                       , Size @size ]  
        }
                
-- Expression.If
SEM Expression | If loc . cinfoGuard =
  \tppair ->
  CInfo { info       = (NTExpression, AltIf, 0, "guard")
        , location   = "conditional"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @guardExpression.oneLineTree  ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }

SEM Expression | If loc . cinfoThen =
  \tppair ->
  CInfo { info       = (NTExpression, AltIf, 1, "then")
        , location   = "then branch of conditional"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @thenExpression.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }

SEM Expression | If loc . cinfoElse =
  \tppair ->
  CInfo { info       = (NTExpression, AltIf,2, "else")
        , location   = "else branch of conditional"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @elseExpression.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]   
        }
                
-- Expression.Lambda                
SEM Expression | Lambda loc . cinfoBind = 
   variableBindingCInfo (NTExpression, AltLambda, 0)

SEM Expression | Lambda loc . cinfoType =
  \tppair ->
  CInfo { info       = (NTExpression, AltLambda, 1, "type")
        , location   = "lambda abstraction"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint 
                       , Size @size ]    
        }
           
-- Expression.Case              
SEM Expression | Case loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression, AltCase, 0, "")
        , location   = "scrutinee of case expression"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @expression.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }
        
-- Expression.Let                 
SEM Expression | Let loc . cinfoType =
  \tppair ->
  CInfo { info       = (NTExpression, AltLet, 0, "")
        , location   = "let expression (INTERNAL ERROR)"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @expression.oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , SuperHighlyTrusted 
                       , Size @size ]  
        }
        
-- Expression.Do    
SEM Expression | Do loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression, AltDo, 0, "")
        , location   = "do-expression"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , Size @size ]
        }
        
-- Expression.List  
SEM Expression | List loc . cinfoElem =
  \elemtext tppair ->
  CInfo { info       = (NTExpression, AltList, 0, "element") 
        , location   = "element of list"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm elemtext ]
        , typepair   = tppair
        , properties = [ Size @size ]
        }
        
SEM Expression | List loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTExpression, AltList, 1, "result")
        , location   = "list"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ Size @size 
                       , FolkloreConstraint ]   
        }
                        
-- Expression.Tuple   
SEM Expression | Tuple loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression, AltTuple, 0, "")
        , location   = "tuple"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ Size @size 
                       , FolkloreConstraint
                       , IsTupleEdge ]   
        }
        
-- Expression.Comprehension   
SEM Expression | Comprehension loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression, AltComprehension, 0, "")
        , location   = "list comprehension"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint 
                       , Size @size ]    
        }
        
-- Expression.Typed                       
SEM Expression | Typed loc . cinfoExpr =
  \tppair ->
  CInfo { info       = (NTExpression, AltTyped, 0, "expression")
        , location   = "type annotation"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @expression.oneLineTree  ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }
        
SEM Expression | Typed loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTExpression, AltTyped, 1, "result")
        , location   = "type annotation"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ Size @size, FolkloreConstraint ]     {- ??? -}
        }
              
-- Expression.Enum                   
SEM Expression | Enum loc . cinfoFrom =
  \tppair ->
  CInfo { info       = (NTExpression, AltEnum, 0, "from")
        , location   = "enumeration"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @from.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size]    
        }

SEM Expression | Enum loc . cinfoThen =
  \tppair ->
  CInfo { info       = (NTExpression, AltEnum, 1, "then")
        , location   = "enumeration"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm (convertMaybeOneLineTree @then.oneLineTree) ]
        , typepair   = tppair
        , properties = [ Size @size]    
        }

SEM Expression | Enum loc . cinfoTo =
  \tppair ->
  CInfo { info       = (NTExpression, AltEnum, 2, "to")
        , location   = "enumeration"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm (convertMaybeOneLineTree @to.oneLineTree) ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }

SEM Expression | Enum loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTExpression, AltEnum, 3, "result")
        , location   = "enumeration"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , Size @size ]    
        }
                
-- Expression.Negate
SEM Expression | Negate loc . cinfoExpr =
  \tppair ->
  CInfo { info       = (NTExpression, AltNegate, 0, "expression")
        , location   = "negation"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @expression.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size
                       , Negation (tpToInt @beta) ]    
        }
        
SEM Expression | Negate loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTExpression, AltNegate, 1, "result")
        , location   = "negation"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint 
                       , Size @size
                       , NegationResult ]    
        }
        
-- Expression.NegateFloat          
SEM Expression | NegateFloat loc . cinfoExpr =
  \tppair ->
  CInfo { info       = (NTExpression, AltNegateFloat, 0, "expression")
        , location   = "negation"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @expression.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size 
                       , Negation (tpToInt @beta) ]    
        }  

SEM Expression | NegateFloat loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTExpression, AltNegateFloat, 1, "result")
        , location   = "negation"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint 
                       , Size @size 
                       , NegationResult ]    
        }

---------------------------------------------------------------------------------------
-- Type Inferencing : GuardedExpression

SEM GuardedExpression | GuardedExpression loc . cinfoGuard =
  \tppair ->
  CInfo { info       = (NTGuardedExpression, AltGuardedExpression, 0, "guard")
        , location   = "guard"
        , errorrange = getExprRange @guard.self
        , sources    = [ sourceExpression @guard.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }

SEM GuardedExpression | GuardedExpression loc . cinfoExpr =
  \tppair ->
  CInfo { info       = (NTGuardedExpression, AltGuardedExpression, 1, "expression")
        , location   = "guarded expression"
        , errorrange = @range.self
        , sources    = [ sourceExpression @expression.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]   
        }

---------------------------------------------------------------------------------------
-- Type Inferencing : Pattern

-- Pattern.Literal
SEM Pattern | Literal loc . cinfo =
  \tppair ->
  CInfo { info       = (NTPattern, AltLiteral, 0, "")
        , location   = "literal pattern"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted
                       , IsLiteral @literal.self
                       , Size @size ]   
        }   
        
-- Pattern.Constructor
SEM Pattern | Constructor loc . cinfoConstructor =
  \tppair ->
  CInfo { info       = (NTPattern, AltConstructor, 0, "")
        , location   = "pattern constructor"
        , errorrange = getNameRange @name.self
        , sources    = [ sourcePattern @oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint,HighlyTrusted 
                        {- ,ApplicationEdge False (zip @patterns.oneLineTree @patterns.betas) -} 
                       , Size @size ]  
        }

SEM Pattern | Constructor loc . cinfoApply =
  \tppair ->
  CInfo { info       = (NTPattern, AltConstructor, 1, "apply")
        , location   = if @patterns.numberOfPatterns == 0 
                         then "pattern constructor"
                         else "pattern application"
        , errorrange = @range.self
        , sources    = if @patterns.numberOfPatterns == 0 
                         then [ sourcePattern @oneLineTree                            ]
                         else [ sourcePattern @oneLineTree, sourceTerm @name.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }
                
-- Pattern.InfixConstructor
SEM Pattern | InfixConstructor loc . cinfoConstructor =
  \tppair ->
  CInfo { info       = (NTPattern, AltInfixConstructor, 0, "")
        , location   = "pattern constructor"
        , errorrange = getNameRange @constructorOperator.self
        , sources    = [ sourcePattern @constructorOperator.oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted
                       , Size @size ]   
        }

SEM Pattern | InfixConstructor loc . cinfoApply =
  \tppair ->
  CInfo { info       = (NTPattern, AltInfixConstructor, 1, "apply")
        , location   = "infix pattern application"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree, sourceTerm (Text (show @constructorOperator.self))]
        , typepair   = tppair
        , properties = [ Size @size ]   
                          {- ApplicationEdge True
                                 [ (@leftPattern.oneLineTree ,@leftPattern.beta )
                                 , (@rightPattern.oneLineTree,@rightPattern.beta)
                                 ] -}       
        }
        
-- Pattern.List
SEM Pattern | List loc . cinfoElem =
  \elemtext tppair ->
  CInfo { info       = (NTPattern, AltList, 0, "element")
        , location   = "element of pattern list"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree, sourceTerm elemtext ]
        , typepair   = tppair
        , properties = [ Size @patterns.size
                       ]
        } 
        
SEM Pattern | List loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTPattern, AltList, 1, "result")
        , location   = "pattern list"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint 
                       , Size @patterns.size ]   
        }
                
-- Pattern.Tuple
SEM Pattern | Tuple loc . cinfo =
  \tppair ->
  CInfo { info       = (NTPattern, AltTuple, 0, "result")
        , location   = "pattern tuple"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , IsTupleEdge
                       , Size @patterns.size ]    
        }
        
-- Pattern.Negate
SEM Pattern | Negate loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTPattern, AltNegate, 0, "result")
        , location   = "pattern negation"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , Size @size
                       , NegationResult ] 
        } 

SEM Pattern | Negate loc . cinfoPat =
  \tppair ->
   CInfo { info       = (NTPattern, AltNegate, 1, "pattern")
        , location   = "pattern negation "
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree, sourceTerm @literal.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size 
                       , Negation (tpToInt @beta) ]    
        }
        
-- Pattern.As 
SEM Pattern |  As loc . cinfo =
  \tppair ->
  CInfo { info       = (NTPattern, AltAs, 0, "")
        , location   = "as pattern"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm (Text (show @name.self)) ]
        , typepair   = tppair
        , properties = [ Size @size ] 
        }
       
-- Pattern.NegateFloat  
SEM Pattern | NegateFloat loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTPattern, AltNegateFloat, 0, "result")
        , location   = "pattern negation"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , Size @size 
                       , NegationResult ] 
        } 

SEM Pattern | NegateFloat loc . cinfoPat =
  \tppair ->
  CInfo { info       = (NTPattern, AltNegateFloat, 1, "pattern")
        , location   = "pattern negation "
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree, sourceTerm @literal.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size 
                       , Negation (tpToInt @beta) ]    
        }

---------------------------------------------------------------------------------------
-- Type Inferencing : Alternative

SEM Alternative | Alternative loc . cinfoLeft =
  \tppair ->
  CInfo { info       = (NTAlternative, AltAlternative, 0, "left")
        , location   = "case pattern"
        , errorrange = @range.self
        , sources    = [ sourcePattern @pattern.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }

SEM Alternative | Alternative loc . cinfoRight =
  \tppair ->
  CInfo { info       = (NTAlternative, AltAlternative, 1, "right")
        , location   = "right-hand side of case alternative"
        , errorrange = @range.self
        , sources    = [ sourceExpression (@righthandside.oneLineTree "") ]
        , typepair   = tppair
        , properties = [ Size @size ]  
        }

SEM Alternative | Alternative loc . cinfoBind = 
   variableBindingCInfo (NTAlternative, AltAlternative, 2)
        
---------------------------------------------------------------------------------------
-- Type Inferencing : Statement

SEM Statement | Expression loc . cinfo =
  \tppair ->
  CInfo { info       = (NTStatement,AltExpression,0, "") 
        , location   = "generator"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @expression.size ] 
        }

SEM Statement | Generator loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTStatement, AltGenerator, 0, "result")
        , location   = "generator"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @expression.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }
        
SEM Statement | Generator loc . cinfoBind = 
   variableBindingCInfo (NTStatement, AltGenerator, 1)

---------------------------------------------------------------------------------------
-- Type Inferencing : Qualifier
        
SEM Qualifier | Guard loc . cinfo =
  \tppair ->
  CInfo { info       = (NTQualifier,AltGuard,0, "")
        , location   = "boolean qualifier"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ Size @guard.size ]  
        }

SEM Qualifier | Generator loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTQualifier,AltGenerator,0, "result")
        , location   = "generator"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @expression.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }

SEM Qualifier | Generator loc . cinfoBind = 
   variableBindingCInfo (NTQualifier,AltGenerator,1 )

----------------------------------------------------------------------------------------------------------------------------------
-- Constraint Info : Variable Binding

{
cinfoBindingGroupExplicitTypedBinding :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoBindingGroupExplicitTypedBinding =
  \name tppair ->
  CInfo { info       = (NTBindingGroup,AltBindingGroup,3, "explicit typed binding, "++show name)
        , location   = "explicitly typed binding"
        , errorrange = getNameRange name
        , sources    = [ sourceTerm (Text (show name))]
        , typepair   = tppair
        , properties = [ {- FolkloreConstraint -}
                         ExplicitTypedBinding
                       , HighlyTrusted
                       , Size 1 ]  
        }

variableBindingCInfo :: (InfoNT, InfoAlt, Int) -> Name -> (Tp,Tp) -> HeliumConstraintInfo
variableBindingCInfo (infoNT,infoAlt,i) var tppair =
  CInfo { info       = (infoNT,infoAlt,i,show var) 
        , location   = "variable"
        , errorrange = getNameRange var
        , sources    = [ sourceExpression (Text (show var)) ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , Size 1 ]  
        }
        
cinfoSameBindingGroup :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoSameBindingGroup var = variableBindingCInfo (NTBindingGroup,AltBindingGroup,0) var

cinfoBindingGroupImplicit :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoBindingGroupImplicit =
  \var tppair ->   
  CInfo { info       = (NTBindingGroup,AltBindingGroup,1,"implicit, "++show var)
        , location   = "variable"
        , errorrange = getNameRange var
        , sources    = [ sourceExpression (Text (show var)) ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted
                       , Size 1 ]   
        }

cinfoBindingGroupExplicit :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoBindingGroupExplicit =
  \var tppair ->
  CInfo { info       = (NTBindingGroup,AltBindingGroup,2, "explicit, "++show var)
        , location   = "variable"
        , errorrange = getNameRange var
        , sources    = [ sourceExpression (Text (show var)) ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , Size 1 ]  
        }
}

----------------------------------------------------------------------------------------------------------------------------------
-- Several utility functions

SEM LeftHandSide [ | | patternTrees:{[Tree]} ]
    | Function      lhs . patternTrees = @patterns.oneLineTree
    | Infix         lhs . patternTrees = [@leftPattern.oneLineTree, @rightPattern.oneLineTree]
    | Parenthesized lhs . patternTrees = @lefthandside.patternTrees ++ @patterns.oneLineTree
{
convertMaybeOneLineTree :: Maybe Tree -> Tree
convertMaybeOneLineTree = maybe (Text "") id
    
getRHSRange :: RightHandSide -> Range
getRHSRange (RightHandSide_Expression r _ _) = r
getRHSRange (RightHandSide_Guarded r _ _) = r

getMaybeExprRange :: MaybeExpression -> Range
getMaybeExprRange (MaybeExpression_Just expr) = getExprRange expr
getMaybeExprRange (MaybeExpression_Nothing)   = noRange

tpToInt :: Tp -> Int
tpToInt tp = case ftv tp of 
               [i] -> i
               _   -> (-1)
               
sourceTerm, sourceExpression, sourcePattern :: Tree -> (String, Tree)
sourceTerm       = (,) "Term" 
sourceExpression = (,) "Expression"
sourcePattern    = (,) "Pattern"
}
