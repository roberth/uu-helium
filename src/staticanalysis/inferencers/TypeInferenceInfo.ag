-------------------------------------------------------------------------------
--
--   *** The Helium Compiler : Static Analysis ***
--               ( Bastiaan Heeren )
--
-- TypeInferenceInfo.ag : Additional information (a local attribute) is 
--    provided for each type constraint.
--
-------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
-- Constraint Information : Body

SEM Body | Body loc . cinfo =
  \var tppair ->
  CInfo { info       = (NTBody,AltBody,show var)
        , location   = "variable"
        , errorrange = getNameRange var
        , sources    = [ sourceExpression (Text (show var)) ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted
                       , IsImported var
                       , Size @declarations.size ]
        }

---------------------------------------------------------------------------------------
-- Constraint Information : Declaration

SEM Declaration | FunctionBindings loc . cinfo =
  \tppair ->
  CInfo { info       = (NTDeclaration,AltFunctionBindings,show @bindings.name)
        , location   = "function bindings (INTERNAL ERROR)"
        , errorrange = @range.self
        , sources    = [ ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , SuperHighlyTrusted
                       , FuntionBindingEdge @bindings.numberOfPatterns 
                       , Size @bindings.size ]
        }
        
SEM Declaration | PatternBinding loc . cinfo =
  \tppair ->
  CInfo { info       = (NTDeclaration,AltPatternBinding,"")
        , location   = "right hand side"
        , errorrange = getRHSRange @righthandside.self
        , sources    = [ sourceExpression (@righthandside.oneLineTree "") ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }        

---------------------------------------------------------------------------------------
-- Type Inferencing : FunctionBinding

SEM FunctionBinding | FunctionBinding loc . cinfoBind = 
   variableBindingCInfo (NTFunctionBinding,AltFunctionBinding)

SEM FunctionBinding | FunctionBinding loc . cinfoRight =
  \tppair ->
  CInfo { info       = (NTFunctionBinding,AltFunctionBinding,"right")
        , location   = "right hand side"
        , errorrange = @range.self
        , sources    = [ sourceTerm (@righthandside.oneLineTree "") ]
        , typepair   = tppair
        , properties = [ Size @size ]
        }

SEM FunctionBinding | FunctionBinding loc . cinfoLeft =
  \num txt tppair ->
  CInfo { info       = (NTFunctionBinding,AltFunctionBinding,"left "++show num)
        , location   = "pattern of function binding"
        , errorrange = @range.self
        , sources    = [ sourcePattern txt ]
        , typepair   = tppair
        , properties = [ Size @size ] 
        }
        
---------------------------------------------------------------------------------------
-- Type Inferencing : Expression

-- Expression.Literal     
SEM Expression | Literal loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression,AltLiteral,"")
        , location   = "literal"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted
                       , IsLiteral @literal.self 
                       , Size @size ]  
        }
                       
-- Expression.Variable                  

-- Expression.Constructor       
SEM Expression | Constructor loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression,AltConstructor,"")
        , location   = "constructor"
        , errorrange = @range.self
        , sources    = [ sourceExpression @name.oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted
                       , IsImported @name.self 
                       , Size @size ]
        }
        
-- Expression.NormalApplication    
SEM Expression | NormalApplication loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression,AltNormalApplication,"")
        , location   = "application"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @function.oneLineTree ]
        , typepair   = tppair
        , properties = [ ApplicationEdge False (zip @arguments.oneLineTree @arguments.betas)  
                       , Size @size ]  
        }
        
-- Expression.InfixApplication
SEM Expression | InfixApplication loc . cinfoComplete =
  \tppair ->
  CInfo { info       = (NTExpression,AltInfixApplication,"")
        , location   = "infix application (INTERNAL ERROR)"
        , errorrange = @range.self
        , sources    = [ ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , SuperHighlyTrusted 
                       , Size @size ]  
        }

SEM Expression | InfixApplication loc . cinfoEmpty =
  \tppair ->
  CInfo { info       = (NTExpression,AltInfixApplication,"empty")
        , location   = "infix application"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted 
                       , Size @size ]  
        }

SEM Expression | InfixApplication loc . cinfoLeftSection = 
  \tppair ->
  CInfo { info       = (NTExpression,AltInfixApplication,"left")
        , location   = "left section"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]  
        }
        
SEM Expression | InfixApplication loc . cinfoRightSection = 
  \tppair ->
  CInfo { info       = (NTExpression,AltInfixApplication,"right")
        , location   = "right section"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]  
        }        

SEM Expression | InfixApplication loc . cinfoOperator =
  \tppair ->
  CInfo { info       = (NTExpression,AltInfixApplication,"operator")
        , location   = "infix application"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm (@operator.oneLineTree)]
        , typepair   = tppair
        , properties = (if @leftExpression.section || @rightExpression.section 
                          then [ HighlyTrusted ] 
                          else [ ApplicationEdge True
                                         [ (convertMaybeOneLineTree @leftExpression.oneLineTree ,@leftExpression.beta )
                                         , (convertMaybeOneLineTree @rightExpression.oneLineTree,@rightExpression.beta)
                                         ] ]) 
                       ++
                       [ Size @size ]
        }
        
-- Expression.If
SEM Expression | If loc . cinfoGuard =
  \tppair ->
  CInfo { info       = (NTExpression,AltIf,"guard")
        , location   = "conditional"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @guardExpression.oneLineTree  ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }

SEM Expression | If loc . cinfoThen =
  \tppair ->
  CInfo { info       = (NTExpression,AltIf,"then")
        , location   = "then branch of conditional"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @thenExpression.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }

SEM Expression | If loc . cinfoElse =
  \tppair ->
  CInfo { info       = (NTExpression,AltIf,"else")
        , location   = "else branch of conditional"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @elseExpression.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]   
        }
                
-- Expression.Lambda                
SEM Expression | Lambda loc . cinfoBind = 
   variableBindingCInfo (NTExpression,AltLambda)

SEM Expression | Lambda loc . cinfoType =
  \tppair ->
  CInfo { info       = (NTExpression,AltLambda,"type")
        , location   = "lambda abstraction"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint 
                       , Size @size ]    
        }
           
-- Expression.Case              
SEM Expression | Case loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression,AltCase,"")
        , location   = "scrutinee of case expression"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @expression.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }
        
-- Expression.Let                 
SEM Expression | Let loc . cinfoType =
  \tppair ->
  CInfo { info       = (NTExpression,AltLet,"")
        , location   = "let expression (INTERNAL ERROR)"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @expression.oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , SuperHighlyTrusted 
                       , Size @size ]  
        }
        
-- Expression.Do    
SEM Expression | Do loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression,AltDo,"")
        , location   = "do-expression (INTERNAL ERROR)"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , SuperHighlyTrusted 
                       , Size @size ]
        }
        
-- Expression.List  
SEM Expression | List loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTExpression,AltList,"result")
        , location   = "list"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ Size @size 
                       , FolkloreConstraint ]   
        }
        
SEM Expression | List loc . cinfoElem =
  \elemtext tppair ->
  CInfo { info       = (NTExpression,AltList,"element") 
        , location   = "element of list"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm elemtext ]
        , typepair   = tppair
        , properties = [ Size @size ]
        }
                
-- Expression.Tuple   
SEM Expression | Tuple loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression,AltTuple,"")
        , location   = "tuple"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ Size @size 
                       , FolkloreConstraint
                       , IsTupleEdge ]   
        }
        
-- Expression.Comprehension   
SEM Expression | Comprehension loc . cinfo =
  \tppair ->
  CInfo { info       = (NTExpression,AltComprehension,"")
        , location   = "list comprehension"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint 
                       , Size @size ]    
        }
        
-- Expression.Typed                       
SEM Expression | Typed loc . cinfoExpr =
  \tppair ->
  CInfo { info       = (NTExpression,AltTyped,"expression")
        , location   = "type annotation"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @expression.oneLineTree  ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }
        
SEM Expression | Typed loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTExpression,AltTyped,"result")
        , location   = "type annotation"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ Size @size, FolkloreConstraint ]     {- ??? -}
        }
              
-- Expression.Enum                   
SEM Expression | Enum loc . cinfoFrom =
  \tppair ->
  CInfo { info       = (NTExpression,AltEnum,"from")
        , location   = "enumeration"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @from.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size]    
        }

SEM Expression | Enum loc . cinfoThen =
  \tppair ->
  CInfo { info       = (NTExpression,AltEnum,"then")
        , location   = "enumeration"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm (convertMaybeOneLineTree @then.oneLineTree) ]
        , typepair   = tppair
        , properties = [ Size @size]    
        }

SEM Expression | Enum loc . cinfoTo =
  \tppair ->
  CInfo { info       = (NTExpression,AltEnum,"to")
        , location   = "enumeration"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm (convertMaybeOneLineTree @to.oneLineTree) ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }

SEM Expression | Enum loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTExpression,AltEnum,"result")
        , location   = "enumeration"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , Size @size ]    
        }
                
-- Expression.Negate
SEM Expression | Negate loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTExpression,AltNegate,"result")
        , location   = "negation"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint 
                       , Size @size
                       , NegationResult ]    
        }

SEM Expression | Negate loc . cinfoExpr =
  \tppair ->
  CInfo { info       = (NTExpression,AltNegate,"expression")
        , location   = "negation"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @expression.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size
                       , Negation (tpToInt @beta) ]    
        }
        
-- Expression.NegateFloat          
SEM Expression | NegateFloat loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTExpression,AltNegateFloat,"result")
        , location   = "negation"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint 
                       , Size @size 
                       , NegationResult ]    
        }

SEM Expression | NegateFloat loc . cinfoExpr =
  \tppair ->
  CInfo { info       = (NTExpression,AltNegateFloat,"expression")
        , location   = "negation"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @expression.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size 
                       , Negation (tpToInt @beta) ]    
        }  

---------------------------------------------------------------------------------------
-- Type Inferencing : GuardedExpression

SEM GuardedExpression | GuardedExpression loc . cinfoGuard =
  \tppair ->
  CInfo { info       = (NTGuardedExpression,AltGuardedExpression,"guard")
        , location   = "guard"
        , errorrange = getExprRange @guard.self
        , sources    = [ sourceExpression @guard.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }

SEM GuardedExpression | GuardedExpression loc . cinfoExpr =
  \tppair ->
  CInfo { info       = (NTGuardedExpression,AltGuardedExpression,"expression")
        , location   = "guarded expression"
        , errorrange = @range.self
        , sources    = [ sourceExpression @expression.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]   
        }

---------------------------------------------------------------------------------------
-- Type Inferencing : Pattern

-- Pattern.Literal
SEM Pattern | Literal loc . cinfo =
  \tppair ->
  CInfo { info       = (NTPattern,AltLiteral,"")
        , location   = "literal pattern"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted
                       , IsLiteral @literal.self
                       , Size @size ]   
        }   
        
-- Pattern.Constructor
SEM Pattern | Constructor loc . cinfoConstructor =
  \tppair ->
  CInfo { info       = (NTPattern,AltConstructor,"") 
        , location   = "pattern constructor"
        , errorrange = getNameRange @name.self
        , sources    = [ sourcePattern @oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint,HighlyTrusted 
                        {- ,ApplicationEdge False (zip @patterns.oneLineTree @patterns.betas) -} 
                       , Size @size ]  
        }

SEM Pattern | Constructor loc . cinfoApply =
  \tppair ->
  CInfo { info       = (NTPattern,AltConstructor,"apply")
        , location   = if @patterns.numberOfPatterns == 0 
                         then "pattern constructor"
                         else "pattern application"
        , errorrange = @range.self
        , sources    = if @patterns.numberOfPatterns == 0 
                         then [ sourcePattern @oneLineTree                            ]
                         else [ sourcePattern @oneLineTree, sourceTerm @name.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }
                
-- Pattern.InfixConstructor
SEM Pattern | InfixConstructor loc . cinfoConstructor =
  \tppair ->
  CInfo { info       = (NTPattern,AltInfixConstructor,"")
        , location   = "pattern constructor"
        , errorrange = getNameRange @constructorOperator.self
        , sources    = [ sourcePattern @constructorOperator.oneLineTree ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted
                       , Size @size ]   
        }

SEM Pattern | InfixConstructor loc . cinfoApply =
  \tppair ->
  CInfo { info       = (NTPattern,AltInfixConstructor,"apply")
        , location   = "infix pattern application"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree, sourceTerm (Text (show @constructorOperator.self))]
        , typepair   = tppair
        , properties = [ Size @size ]   
                          {- ApplicationEdge True
                                 [ (@leftPattern.oneLineTree ,@leftPattern.beta )
                                 , (@rightPattern.oneLineTree,@rightPattern.beta)
                                 ] -}       
        }
        
-- Pattern.List
SEM Pattern | List loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTPattern,AltList,"result")
        , location   = "pattern list"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint 
                       , Size @patterns.size ]   
        }
        
SEM Pattern | List loc . cinfoElem =
  \elemtext tppair ->
  CInfo { info       = (NTPattern,AltList,"element")
        , location   = "element of pattern list"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree, sourceTerm elemtext ]
        , typepair   = tppair
        , properties = [ Size @patterns.size
                       ]
        } 
        
-- Pattern.Tuple
SEM Pattern | Tuple loc . cinfo =
  \tppair ->
  CInfo { info       = (NTPattern,AltTuple,"result")
        , location   = "pattern tuple"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , IsTupleEdge
                       , Size @patterns.size ]    
        }
        
-- Pattern.Negate
SEM Pattern | Negate loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTPattern,AltNegate,"result")
        , location   = "pattern negation"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , Size @size
                       , NegationResult ] 
        } 

SEM Pattern | Negate loc . cinfoPat =
  \tppair ->
   CInfo { info       = (NTPattern,AltNegate,"pattern")
        , location   = "pattern negation "
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree, sourceTerm @literal.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size 
                       , Negation (tpToInt @beta) ]    
        }
        
-- Pattern.As 
SEM Pattern |  As loc . cinfo =
  \tppair ->
  CInfo { info       = (NTPattern,AltAs,"")
        , location   = "as pattern"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm (Text (show @name.self)) ]
        , typepair   = tppair
        , properties = [ Size @size ] 
        }
       
-- Pattern.NegateFloat  
SEM Pattern | NegateFloat loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTPattern,AltNegateFloat,"result")
        , location   = "pattern negation"
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree  ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , Size @size 
                       , NegationResult ] 
        } 

SEM Pattern | NegateFloat loc . cinfoPat =
  \tppair ->
   CInfo { info       = (NTPattern,AltNegateFloat,"pattern")
        , location   = "pattern negation "
        , errorrange = @range.self
        , sources    = [ sourcePattern @oneLineTree, sourceTerm @literal.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size 
                       , Negation (tpToInt @beta) ]    
        }

---------------------------------------------------------------------------------------
-- Type Inferencing : Alternative

SEM Alternative | Alternative loc . cinfoBind = 
   variableBindingCInfo (NTAlternative,AltAlternative)

SEM Alternative | Alternative loc . cinfoLeft =
  \tppair ->
  CInfo { info       = (NTAlternative,AltAlternative,"left")
        , location   = "case pattern"
        , errorrange = @range.self
        , sources    = [ sourcePattern @pattern.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }

SEM Alternative | Alternative loc . cinfoRight =
  \tppair ->
  CInfo { info       = (NTAlternative,AltAlternative,"right")
        , location   = "right-hand side of case alternative"
        , errorrange = @range.self
        , sources    = [ sourceExpression (@righthandside.oneLineTree "") ]
        , typepair   = tppair
        , properties = [ Size @size ]  
        }

---------------------------------------------------------------------------------------
-- Type Inferencing : Statement

SEM Statement | Expression loc . cinfo =
  \tppair ->
  CInfo { info       = (NTStatement,AltExpression,"") 
        , location   = "generator"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @expression.size ] 
        }

SEM Statement | Generator loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTStatement,AltGenerator,"result")
        , location   = "generator"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @expression.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }
        
SEM Statement | Generator loc . cinfoBind = 
   variableBindingCInfo (NTStatement,AltGenerator)

---------------------------------------------------------------------------------------
-- Type Inferencing : Qualifier
        
SEM Qualifier | Guard loc . cinfo =
  \tppair ->
  CInfo { info       = (NTQualifier,AltGuard,"")
        , location   = "boolean qualifier"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree  ]
        , typepair   = tppair
        , properties = [ Size @guard.size ]  
        }

SEM Qualifier | Generator loc . cinfoResult =
  \tppair ->
  CInfo { info       = (NTQualifier,AltGenerator,"result")
        , location   = "generator"
        , errorrange = @range.self
        , sources    = [ sourceExpression @oneLineTree, sourceTerm @expression.oneLineTree ]
        , typepair   = tppair
        , properties = [ Size @size ]    
        }

SEM Qualifier | Generator loc . cinfoBind = 
   variableBindingCInfo (NTQualifier,AltGenerator)

----------------------------------------------------------------------------------------------------------------------------------
-- Constraint Info : Variable Binding

{
cinfoBindingGroupExplicitTypedBinding :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoBindingGroupExplicitTypedBinding =
  \name tppair ->
  CInfo { info       = (NTBindingGroup,AltBindingGroup,"explicit typed binding, "++show name)
        , location   = "explicitly typed binding"
        , errorrange = getNameRange name
        , sources    = [ sourceTerm (Text (show name))]
        , typepair   = tppair
        , properties = [ {- FolkloreConstraint -}
                         ExplicitTypedBinding
                       , HighlyTrusted
                       , Size 1 ]  
        }

variableBindingCInfo :: (InfoNT,InfoAlt) -> Name -> (Tp,Tp) -> HeliumConstraintInfo
variableBindingCInfo (infoNT,infoAlt) var tppair =
  CInfo { info       = (infoNT,infoAlt,show var) 
        , location   = "variable"
        , errorrange = getNameRange var
        , sources    = [ sourceExpression (Text (show var)) ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , Size 1 ]  
        }
        
cinfoSameBindingGroup :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoSameBindingGroup var = variableBindingCInfo (NTBindingGroup,AltBindingGroup) var

cinfoBindingGroupImplicit :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoBindingGroupImplicit =
  \var tppair ->   
  CInfo { info       = (NTBindingGroup,AltBindingGroup,"implicit, "++show var)
        , location   = "variable"
        , errorrange = getNameRange var
        , sources    = [ sourceExpression (Text (show var)) ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , HighlyTrusted
                       , Size 1 ]   
        }

cinfoBindingGroupExplicit :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoBindingGroupExplicit =
  \var tppair ->
  CInfo { info       = (NTBindingGroup,AltBindingGroup,"explicit, "++show var)
        , location   = "variable"
        , errorrange = getNameRange var
        , sources    = [ sourceExpression (Text (show var)) ]
        , typepair   = tppair
        , properties = [ FolkloreConstraint
                       , Size 1 ]  
        }
}

----------------------------------------------------------------------------------------------------------------------------------
-- Several utility functions

SEM LeftHandSide [ | | patternTrees:{[Tree]} ]
    | Function      lhs . patternTrees = @patterns.oneLineTree
    | Infix         lhs . patternTrees = [@leftPattern.oneLineTree, @rightPattern.oneLineTree]
    | Parenthesized lhs . patternTrees = @lefthandside.patternTrees ++ @patterns.oneLineTree
{
convertMaybeOneLineTree :: Maybe Tree -> Tree
convertMaybeOneLineTree = maybe (Text "") id
    
getRHSRange :: RightHandSide -> Range
getRHSRange (RightHandSide_Expression r _ _) = r
getRHSRange (RightHandSide_Guarded r _ _) = r

getMaybeExprRange :: MaybeExpression -> Range
getMaybeExprRange (MaybeExpression_Just expr) = getExprRange expr
getMaybeExprRange (MaybeExpression_Nothing)   = noRange

tpToInt :: Tp -> Int
tpToInt tp = case ftv tp of 
               [i] -> i
               _   -> (-1)
               
sourceTerm, sourceExpression, sourcePattern :: Tree -> (String, Tree)
sourceTerm       = (,) "Term" 
sourceExpression = (,) "Expression"
sourcePattern    = (,) "Pattern"
}
