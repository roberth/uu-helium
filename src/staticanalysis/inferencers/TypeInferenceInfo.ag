-------------------------------------------------------------------------------
--
--   *** The Helium Compiler : Static Analysis ***
--               ( Bastiaan Heeren )
--
-- TypeInferenceInfo.ag : Additional information (a local attribute) is
--    provided for each type constraint.
--
-------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
-- Constraint Information : Body

SEM Body | Body loc . cinfo = 
  \name -> variableConstraint "variable" (nameToSelfExpr name) 
     [ FolkloreConstraint, HasTrustFactor 10.0, IsImported name ]

---------------------------------------------------------------------------------------
-- Constraint Information : Declaration

SEM Declaration | FunctionBindings loc . cinfo =
  resultConstraint "function bindings (INTERNAL ERROR)" @parentTree
     [ FolkloreConstraint, HasTrustFactor 10000.0, FuntionBindingEdge @bindings.numberOfPatterns ]

SEM Declaration | PatternBinding loc . cinfo =
  orphanConstraint 1 "right hand side" @parentTree
     []

---------------------------------------------------------------------------------------
-- Type Inferencing : FunctionBinding

SEM FunctionBinding | FunctionBinding loc . cinfoLeft =
  \num  -> 
  orphanConstraint num "pattern of function binding" @parentTree
     []                      

SEM FunctionBinding | FunctionBinding loc . cinfoBind =
  \name -> variableConstraint "variable" (nameToSelfExpr name) 
     [FolkloreConstraint]

---------------------------------------------------------------------------------------
-- Type Inferencing : RightHandSide

-- RightHandSide.Expression
SEM RightHandSide | Expression loc . cinfo = 
  resultConstraint "right-hand side" @expression.infoTree
     []

---------------------------------------------------------------------------------------
-- Type Inferencing : Expression

-- Expression.Literal
SEM Expression | Literal loc . cinfo =
  resultConstraint "literal" @parentTree
     [ FolkloreConstraint, HasTrustFactor 10.0, IsLiteral (literalType @literal.self) ]

-- Expression.Constructor
SEM Expression | Constructor loc . cinfo =
  resultConstraint "constructor" @parentTree       
     [ FolkloreConstraint, HasTrustFactor 10.0, IsImported @name.self ]

-- Expression.NormalApplication
SEM Expression | NormalApplication loc . cinfo =
  childConstraint 0 "application" @parentTree
     [ ApplicationEdge False (map attribute @arguments.infoTrees) ]

-- Expression.InfixApplication
SEM Expression | InfixApplication loc . operatorNr    = length @leftExpression.infoTrees
                                  loc . cinfoOperator =
  childConstraint @operatorNr "infix application" @parentTree $
     if @leftExpression.section || @rightExpression.section 
     then [ HasTrustFactor 10.0 ]
     else [ ApplicationEdge True (map attribute (@leftExpression.infoTrees ++ @rightExpression.infoTrees)) ] 

SEM Expression | InfixApplication loc . cinfoComplete =
  specialConstraint "infix application (INTERNAL ERROR)" @parentTree
     (self @localInfo, Nothing)
     [ FolkloreConstraint, HasTrustFactor 10000.0 ]

SEM Expression | InfixApplication loc . cinfoLeftSection =
  specialConstraint "left section" @parentTree
     (self @localInfo, Nothing)
     [ ]

SEM Expression | InfixApplication loc . cinfoRightSection =
  specialConstraint "right section" @parentTree        
     (self @localInfo, Nothing)
     [ ]

SEM Expression | InfixApplication loc . cinfoEmpty =
  specialConstraint "infix application" @parentTree
    (self @localInfo, Nothing)
    [ FolkloreConstraint, HasTrustFactor 10.0, IsEmptyInfixApplication ]
    
-- Expression.If
SEM Expression | If loc . cinfoGuard =
  childConstraint 0 "conditional" @parentTree 
     []   

SEM Expression | If loc . cinfoThen =
  childConstraint 1 "then branch of conditional" @parentTree 
     []

SEM Expression | If loc . cinfoElse =
  childConstraint 2 "else branch of conditional" @parentTree 
     []

-- Expression.Lambda
SEM Expression | Lambda loc . cinfoBind =
  \name -> variableConstraint "variable" (nameToSelfExpr name)
     [FolkloreConstraint]

SEM Expression | Lambda loc . cinfoType =
  resultConstraint "lambda abstraction" @parentTree 
     [ FolkloreConstraint ]

-- Expression.Case
SEM Expression | Case loc . cinfo =
  childConstraint 0 "scrutinee of case expression" @parentTree
     [ ]

-- Expression.Let
SEM Expression | Let loc . cinfoType =
  resultConstraint "let expression (INTERNAL ERROR)" @thisTree
     [ FolkloreConstraint, HasTrustFactor 10000.0 ]
     
-- Expression.Do
SEM Expression | Do loc . cinfo =
  resultConstraint "do-expression" @parentTree
     [ FolkloreConstraint ]

-- Expression.List
SEM Expression | List loc . cinfoElem =
  \elemNr ->
  childConstraint elemNr "element of list" @parentTree
  [ HasTrustFactor 10.0 | length @expressions.betas < 2 ]


SEM Expression | List loc . cinfoResult =
  resultConstraint "list" @parentTree
  [ FolkloreConstraint ]

-- Expression.Tuple   
SEM Expression | Tuple loc . cinfo =
  resultConstraint "tuple" @parentTree 
     [ FolkloreConstraint, IsTupleEdge ]
        
-- Expression.Comprehension   
SEM Expression | Comprehension loc . cinfo =
  resultConstraint "list comprehension" @parentTree
     [ FolkloreConstraint ]

-- Expression.Typed
SEM Expression | Typed loc . cinfoExpr =
  childConstraint 0 "type annotation" @parentTree 
     []

SEM Expression | Typed loc . cinfoResult =
  resultConstraint "type annotation" @parentTree 
     [ FolkloreConstraint ]     {- ??? -}
       
-- Expression.Enum
SEM Expression | Enum loc . cinfoFrom =
  childConstraint 0 "enumeration" @parentTree 
     []

SEM Expression | Enum loc . cinfoThen =
  childConstraint 1 "enumeration" @parentTree                      
     []

SEM Expression | Enum loc . toChildNr = 1 + length @then.infoTrees
                      loc . cinfoTo =
  childConstraint @toChildNr "enumeration" @parentTree
     []

SEM Expression | Enum loc . cinfoResult =
  resultConstraint "enumeration" @parentTree
     [ FolkloreConstraint ]       

-- Expression.Negate
SEM Expression | Negate loc . cinfo =
  specialConstraint "negation" @parentTree 
     (self @localInfo, Just $ nameToSelfExpr (Name_Operator @range [] "-")) 
     [ Negation True ]

SEM Expression | NegateFloat loc . cinfo =
  specialConstraint "negation" @parentTree 
     (self @localInfo, Just $ nameToSelfExpr (Name_Operator @range [] "-."))
     [ Negation False ]        

---------------------------------------------------------------------------------------
-- Type Inferencing : GuardedExpression

SEM GuardedExpression | GuardedExpression loc . cinfoGuard =
  resultConstraint "guard" @guard.infoTree
     []       

SEM GuardedExpression | GuardedExpression loc . cinfoExpr =
  resultConstraint "guarded expression" @expression.infoTree
     [ HasTrustFactor 10.0 | @lhs.numberOfGuards < 2 ]

---------------------------------------------------------------------------------------
-- Type Inferencing : Pattern

-- Pattern.Literal
SEM Pattern | Literal loc . cinfo =
  resultConstraint "literal pattern" @parentTree
     [ FolkloreConstraint, HasTrustFactor 10.0, IsLiteral (literalType @literal.self) ]        

-- Pattern.Constructor
SEM Pattern | Constructor loc . cinfoConstructor =
  resultConstraint "pattern constructor" @parentTree
     [ FolkloreConstraint, HasTrustFactor 10.0 ]

SEM Pattern | Constructor loc . cinfoApply =
  specialConstraint "pattern application" @parentTree
     (self @localInfo, Just $ nameToSelfPat @name.self)
     [ ApplicationEdge False (map attribute @patterns.infoTrees) ]    
                                   
SEM Pattern | Constructor loc . cinfoEmpty =
  resultConstraint "pattern constructor" @parentTree
     [ HasTrustFactor 10.0 ]
                                
-- Pattern.InfixConstructor
SEM Pattern | InfixConstructor loc . cinfoConstructor =
  variableConstraint "pattern constructor" (nameToSelfPat @constructorOperator.self) 
     [ FolkloreConstraint, HasTrustFactor 10.0 ] 

SEM Pattern | InfixConstructor loc . cinfoApply =
  specialConstraint "infix pattern application" @parentTree 
     (self @localInfo, Just $ nameToSelfPat  @constructorOperator.self)
     [ ApplicationEdge True (map attribute [@leftPattern.infoTree, @rightPattern.infoTree]) ] 

-- Pattern.List
SEM Pattern | List loc . cinfoElem =
  \elemNr ->
  childConstraint elemNr "element of pattern list" @parentTree
     [ HasTrustFactor 10.0 | length @patterns.constraintslist < 2 ]

SEM Pattern | List loc . cinfoResult =
  resultConstraint "pattern list" @parentTree
     [ FolkloreConstraint ]

-- Pattern.Tuple
SEM Pattern | Tuple loc . cinfo =
  resultConstraint "pattern tuple" @parentTree
  [ FolkloreConstraint, IsTupleEdge ]

-- Pattern.Negate
SEM Pattern | Negate loc . cinfo =
  resultConstraint "pattern negation" @parentTree
     [ FolkloreConstraint ]

-- Pattern.As
SEM Pattern |  As loc . cinfo =
  specialConstraint "as pattern" @parentTree
     (self @localInfo, Just $ nameToSelfPat @name.self)
     []

-- Pattern.NegateFloat
SEM Pattern | NegateFloat loc . cinfo =
  resultConstraint "pattern negation" @parentTree
     [ FolkloreConstraint, NegationResult ]

---------------------------------------------------------------------------------------
-- Type Inferencing : Alternative

SEM Alternative | Alternative loc . cinfoLeft =
  resultConstraint "case pattern" @pattern.infoTree
     []     

SEM Alternative | Alternative loc . cinfoBind =
  \name -> variableConstraint "variable" (nameToSelfExpr name) 
     [FolkloreConstraint]

---------------------------------------------------------------------------------------
-- Type Inferencing : Statement

SEM Statement | Expression loc . cinfo =
  orphanConstraint 0 "generator" @parentTree
     []

SEM Statement | Generator loc . cinfoResult =
  childConstraint 1 "generator" @parentTree
     []
     
SEM Statement | Generator loc . cinfoBind =
  \name -> variableConstraint "variable" (nameToSelfExpr name)
     [FolkloreConstraint]

---------------------------------------------------------------------------------------
-- Type Inferencing : Qualifier

SEM Qualifier | Guard loc . cinfo =
  orphanConstraint 0 "boolean qualifier" @parentTree
     []

SEM Qualifier | Generator loc . cinfoResult =
  childConstraint 1 "generator" @parentTree
     []
     
SEM Qualifier | Generator loc . cinfoBind =
  \name -> variableConstraint "variable" (nameToSelfExpr name) 
     [FolkloreConstraint]
  
-----------------------------------------------------------------
-- Smart constructors

{
childConstraint :: Int -> String -> InfoTree -> Properties -> (Tp, Tp) -> HeliumConstraintInfo
childConstraint childNr theLocation infoTree theProperties tppair =
  CInfo { location   = theLocation
        , sources    = ( (self . attribute) infoTree
                       , Just $ (self . attribute . selectChild childNr) infoTree
                       )
        , typepair   = tppair
        , localInfo  = infoTree        
        , properties = theProperties
        }

specialConstraint :: String -> InfoTree -> (UHA_Source, Maybe UHA_Source) -> Properties -> (Tp, Tp) -> HeliumConstraintInfo
specialConstraint theLocation infoTree theSources theProperties tppair =
  CInfo { location   = theLocation
        , sources    = theSources
        , typepair   = tppair
        , localInfo  = infoTree        
        , properties = theProperties
        }
        
orphanConstraint :: Int -> String -> InfoTree -> Properties -> (Tp, Tp) -> HeliumConstraintInfo
orphanConstraint childNr theLocation infoTree theProperties tppair =
  CInfo { location   = theLocation
        , sources    = ( (self . attribute . selectChild childNr) infoTree
                       , Nothing
                       )
        , typepair   = tppair
        , localInfo  = infoTree        
        , properties = theProperties
        }        
        
resultConstraint :: String -> InfoTree -> Properties -> (Tp, Tp) -> HeliumConstraintInfo
resultConstraint theLocation infoTree theProperties tppair =
  CInfo { location   = theLocation
        , sources    = ( (self . attribute) infoTree 
                       , Nothing
                       )
        , typepair   = tppair
        , localInfo  = infoTree    
        , properties = theProperties
        }        

variableConstraint :: String -> UHA_Source -> Properties -> (Tp, Tp) -> HeliumConstraintInfo
variableConstraint theLocation theSource theProperties tppair =
  CInfo { location   = theLocation
        , sources    = (theSource, Nothing)
        , typepair   = tppair
        , localInfo  = root (LocalInfo { self = theSource, assignedType = Just (snd tppair) }) []
        , properties = theProperties
        }               
        
cinfoBindingGroupExplicitTypedBinding :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoSameBindingGroup                 :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoBindingGroupImplicit             :: Name -> (Tp,Tp) -> HeliumConstraintInfo
cinfoBindingGroupExplicit             :: Name -> (Tp,Tp) -> HeliumConstraintInfo

cinfoBindingGroupExplicitTypedBinding name = 
   variableConstraint "explicitly typed binding" (nameToSelfExpr name) [ FromBindingGroup, ExplicitTypedBinding, HasTrustFactor 10.0 ]
cinfoSameBindingGroup name = 
   variableConstraint "variable" (nameToSelfExpr name) [ FromBindingGroup, FolkloreConstraint ]
cinfoBindingGroupImplicit name = 
   variableConstraint "variable" (nameToSelfExpr name) [ FromBindingGroup, FolkloreConstraint, HasTrustFactor 10.0 ]
cinfoBindingGroupExplicit name = 
   variableConstraint "variable" (nameToSelfExpr name) [ FromBindingGroup, FolkloreConstraint ]      
                           
nameToSelfExpr :: Name -> UHA_Source
nameToSelfExpr name = UHA_Expr (Expression_Variable (getNameRange name) name)

nameToSelfPat :: Name -> UHA_Source
nameToSelfPat name = UHA_Pat (Pattern_Variable (getNameRange name) name)

literalType :: Literal -> String
literalType x = 
   case x of   
      Literal_Int    _ _ -> "Int"
      Literal_Char   _ _ -> "Char"
      Literal_String _ _ -> "String"
      Literal_Float  _ _ -> "Float"
}   