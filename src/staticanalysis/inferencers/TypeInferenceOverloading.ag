-----------------------------------------------------------------------------
-- |The Helium Compiler : Static Analysis
-- 
-- Maintainer  :  bastiaan@cs.uu.nl
-- Stability   :  experimental
-- Portability :  unknown
--
-- Extra information for overloading (for code generation)
--
-----------------------------------------------------------------------------

ATTR Declarations Declaration Expressions Expression Statements Statement
     Qualifiers Qualifier GuardedExpressions GuardedExpression 
     Alternatives Alternative FunctionBindings FunctionBinding
     RightHandSide MaybeDeclarations MaybeExpression RecordExpressionBinding
     RecordExpressionBindings Body
        [ availablePredicates   : Predicates 
        | dictionaryEnvironment : DictionaryEnvironment          
        | 
        ]
ATTR Module -> Expression [ | unresolvedErrors:TypeErrors | ]
	
SEM Module
  | Module
       -- return an empty dictionary environment for the non-overloading setting
       lhs  . dictionaryEnvironment = if Overloading `elem` @lhs.options 
                                        then @body.dictionaryEnvironment
					else emptyDictionaryEnvironment
       loc  . unresolvedErrors      = if Overloading `elem` @lhs.options 
                                        then @body.unresolvedErrors
					else []
       body . dictionaryEnvironment = emptyDictionaryEnvironment
	    . availablePredicates   = []
	    . unresolvedErrors      = []

-- collecting the unresolved overloading errors 
SEM Expression
  | Variable   lhs . unresolvedErrors = @overloadingErrors ++ @lhs.unresolvedErrors
  | Negate     lhs . unresolvedErrors = @overloadingErrors ++ @expression.unresolvedErrors
	    
SEM Declaration   
 
  | FunctionBindings
       loc      . declPredicates        = let scheme     = lookupWithDefaultFM @lhs.inferredTypes err (NameWithRange @bindings.name)
                                              predicates = qualifiers (unquantify scheme)
                                              err = internalError "TypeInferenceOverloading.ag" "n/a" "could not find type for function binding"
                                          in expandPredicates @lhs.orderedTypeSynonyms predicates      
       bindings . availablePredicates   = @declPredicates ++ @lhs.availablePredicates
       lhs      . dictionaryEnvironment = addForDeclaration @bindings.name @declPredicates @bindings.dictionaryEnvironment
       
  | PatternBinding 
       loc           . declPredicates = case @pattern.self of
                                          Pattern_Variable _ name -> 
                                             let scheme     = lookupWithDefaultFM @lhs.inferredTypes err (NameWithRange name)
                                                 predicates = qualifiers (unquantify scheme)
                                                 err = internalError "TypeInferenceOverloading.ag" "n/a" "could not find type for pattern binding"
                                             in Just (name, expandPredicates @lhs.orderedTypeSynonyms predicates)
                                          _                  -> Nothing
       righthandside . availablePredicates = case @declPredicates of
                                                Just (n, ps) -> ps ++ @lhs.availablePredicates
                                                Nothing      -> @lhs.availablePredicates
       lhs           . dictionaryEnvironment = case @declPredicates of
                                                  Just (n, ps) -> addForDeclaration n ps @righthandside.dictionaryEnvironment
                                                  Nothing      -> @righthandside.dictionaryEnvironment
       
SEM Expression 

  | Variable   lhs . dictionaryEnvironment = @newDEnv              
               loc . nameInScope           = case filter (@name.self==) @lhs.namesInScope of 
                                                [name] -> NameWithRange name
                                                _      -> internalError "TypeInferenceOverloading.ag" "n/a" "name not in scope"
		   . maybeInferredType     = lookupFM @lhs.inferredTypes @nameInScope
                   . requiredDictionaries  = -- if not in finitemap then this is bound by a monomorphic pattern variable
                                             case @maybeInferredType of
                                                Nothing     -> [] 
                                                Just scheme -> getRequiredDictionaries 
                                                                  (getOrderedTypeSynonyms @lhs.importEnvironment) 
                                                                  @usedAsType
                                                                  scheme
                   . (newDEnv, overloadingErrors) = resolveOverloading (classEnvironment @lhs.importEnvironment)
                                                                       @name.self 
                                                                       @lhs.availablePredicates 
								       @requiredDictionaries 
								       @unresolvedMessage
								       @lhs.dictionaryEnvironment 
                   . usedAsType        = @lhs.substitution |-> @beta
		   . unresolvedMessage = makeUnresolvedOverloadingError (self @localInfo) "overloaded function" 
		                            (maybe (internalError "TypeInferenceOverloading.ag" "n/a" "inferred type is unknown") id @maybeInferredType, toTpScheme @usedAsType)
		   
  | Negate   lhs . dictionaryEnvironment = @newDEnv
             loc . localName             = setNameRange intUnaryMinusName @range.self
                 . negateTypeScheme      = case lookupFM (typeEnvironment @lhs.importEnvironment) @localName of 
                                              Just scheme -> scheme
                                              Nothing     -> internalError "TypeInferenceOverloading.ag" "n/a" "type of negate unknown"
                 . requiredDictionaries  = getRequiredDictionaries 
                                              (getOrderedTypeSynonyms @lhs.importEnvironment) 
                                              @usedAsType
                                              @negateTypeScheme
                 . usedAsType      = @lhs.substitution |-> (@expression.beta .->. @beta)
                 . unresolvedMessage = makeUnresolvedOverloadingError (nameToUHA_Expr (nameFromString "-")) "negation"
                                          (@negateTypeScheme, toTpScheme @usedAsType)
                 . (newDEnv, overloadingErrors) = resolveOverloading (classEnvironment @lhs.importEnvironment)  @localName 
		                                                     @lhs.availablePredicates 
								     @requiredDictionaries 
								     @unresolvedMessage
								     @expression.dictionaryEnvironment                                              
             
{         
getRequiredDictionaries :: OrderedTypeSynonyms -> Tp -> TpScheme -> Predicates
getRequiredDictionaries synonyms useType defType = 
   let i  = nextFTV useType
       (instantiatedPreds, instantiatedType) = split (snd (instantiate i defType))
   in -- one-way unification is necessary!
      case mguWithTypeSynonyms synonyms instantiatedType useType of
         Left _ -> internalError "TypeInferenceOverloading.ag" "getRequiredDictionaries" "no unification"
         Right (_, sub) -> 
            expandPredicates synonyms (sub |-> instantiatedPreds)
            
resolveOverloading :: ClassEnvironment -> Name -> Predicates -> Predicates -> TypeError -> DictionaryEnvironment 
                         -> (DictionaryEnvironment, [TypeError])
resolveOverloading classEnv name availablePredicates predicates message dEnv = 
   let maybeTrees = map (makeDictionaryTree classEnv availablePredicates) predicates
   in if all isJust maybeTrees
        then (addForVariable name (map fromJust maybeTrees) dEnv, [])
        else (dEnv, [message])

expandPredicates :: OrderedTypeSynonyms -> Predicates -> Predicates
expandPredicates synonyms = map (expandPredicate synonyms)

expandPredicate :: OrderedTypeSynonyms -> Predicate -> Predicate
expandPredicate (_, synonyms) (Predicate className tp) = Predicate className (expandType synonyms tp)
}
