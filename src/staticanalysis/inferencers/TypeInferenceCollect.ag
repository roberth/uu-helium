ATTR Expression Expressions MaybeExpression Patterns Pattern Alternative Alternatives
     Statement Statements Declaration Declarations MaybeDeclarations 
     LeftHandSide RightHandSide Body Qualifier Qualifiers   
     GuardedExpression GuardedExpressions  FunctionBinding FunctionBindings          
     RecordExpressionBinding RecordExpressionBindings RecordPatternBinding RecordPatternBindings        
        [ importEnvironment : ImportEnvironment 
          substitution      : FixpointSubstitution  
          predicates        : Predicates 
          inferredTypes     : {FiniteMap NameWithRange TpScheme}
        | 
        | 
        ]

SEM Module
  | Module
       loc . inferredTypes = addListToFM @body.localTypes [ (NameWithRange n, ts) | (n, ts) <- fmToList @body.toplevelTypes]

-------------------------------------------
-- Collecting Type Signatures

ATTR Declaration Declarations [ | typeSignatures:{FiniteMap Name TpScheme} | ]

SEM Body              | Body    declarations . typeSignatures = emptyFM
SEM Expression        | Let     declarations . typeSignatures = emptyFM
SEM Statement         | Let     declarations . typeSignatures = emptyFM
SEM Qualifier         | Let     declarations . typeSignatures = emptyFM
SEM MaybeDeclarations | Just    declarations . typeSignatures = emptyFM

SEM Declaration
  | TypeSignature
      lhs . typeSignatures = addListToFM @lhs.typeSignatures [ (name, @typeScheme) | name <- @names.self ]
      loc . typeScheme     = makeTpSchemeFromType @type.self

-------------------------------------------
-- Collecting all Type Annotations (or: explicit type signatures)
-- These collected type annotations are checked afterwards.

ATTR Declarations Expression MaybeDeclarations RightHandSide Statement Statements
     RecordExpressionBindings RecordExpressionBinding Qualifier Qualifiers MaybeExpression
     GuardedExpression FunctionBinding FunctionBindings GuardedExpressions
     Expressions Declaration Alternative Alternatives Body
     [ | typeAnnotations : TypeAnnotations | ]

SEM Module
  | Module   body . typeAnnotations = []

SEM Expression
  | Typed  lhs . typeAnnotations = ((@lhs.monos,@expression.beta),@typeScheme,(@expression.oneLineTree,@range.self)) : @expression.typeAnnotations
  | Let    lhs . typeAnnotations = @anns ++ @expression.typeAnnotations

SEM MaybeDeclarations
  | Just   lhs . typeAnnotations = @anns ++ @declarations.typeAnnotations

SEM Body
  | Body   lhs . typeAnnotations = @anns ++ @declarations.typeAnnotations

SEM Statement
  | Let    lhs . typeAnnotations = @anns ++ @declarations.typeAnnotations

SEM Qualifier
  | Let    lhs . typeAnnotations = @anns ++ @declarations.typeAnnotations

-------------------------------------------
-- Collecting NoTypeDefs

ATTR Declarations Expression MaybeDeclarations RightHandSide Statement Statements
     RecordExpressionBindings RecordExpressionBinding Qualifier Qualifiers MaybeExpression
     GuardedExpression FunctionBinding FunctionBindings GuardedExpressions
     Expressions Declaration Alternative Alternatives Body
     [ | collectednotypedef : {[(Name,Tps,Tp,Bool)]} | ]

SEM Module
  | Module  body . collectednotypedef = [] 

SEM Body
  | Body  lhs . collectednotypedef = @notypedefs ++ @declarations.collectednotypedef

SEM MaybeDeclarations
  | Just  lhs . collectednotypedef = @notypedefs ++ @declarations.collectednotypedef

SEM Expression 
  | Let   lhs . collectednotypedef = @notypedefs ++ @declarations.collectednotypedef

SEM Statement
  | Let   lhs . collectednotypedef = @notypedefs ++ @declarations.collectednotypedef

SEM Qualifier  
  | Let   lhs . collectednotypedef = @notypedefs ++ @declarations.collectednotypedef
  
SEM Module 
  | Module loc . warnings  = 
        -- only a warning for top-level type definitions without 
        -- monomorphic type variables 
        let f (n,ms,t,isToplevel) = 
                           let ms'    = @substitution |-> ms
                               t'     = @substitution |-> t
                               scheme = generalize (ftv ms') @predicates t'
                           in if null (ftv scheme) && isToplevel
                                then [NoTypeDef n scheme isToplevel] 
                                else []
        in concatMap f @body.collectednotypedef

----------------------------------------------------------------------------------------
-- Collecting inferred top level types

ATTR Body [ |  | toplevelTypes : TypeEnvironment ]   
  
SEM Body
  | Body   lhs . toplevelTypes = convertToplevelTypes @lhs.monos @lhs.substitution @lhs.predicates @declarations.bindingGroups
  
{
convertToplevelTypes :: Substitution substitution => Tps -> substitution -> Predicates -> BindingGroups -> TypeEnvironment
convertToplevelTypes monos substitution predicates groups = 
   let (environment, _, _) = concatBindingGroups groups
       monos' = ftv (substitution |-> monos)      
   in listToFM [ (name, generalize monos' predicates tp')
      | (name, tp) <- fmToList environment 
      , let  tp' = substitution |-> tp
      ]
}
             
----------------------------------------------------------------------------------------
-- Collecting inferred local types

ATTR Body Declarations Declaration MaybeDeclarations MaybeExpression Expression Expressions 
     Statement Statements Qualifier Qualifiers RecordExpressionBindings GuardedExpression GuardedExpressions
     FunctionBinding FunctionBindings Alternative Alternatives RightHandSide RecordExpressionBinding
        [ | localTypes : {FiniteMap NameWithRange TpScheme} | ]
        
SEM Module 
  | Module  body . localTypes = emptyFM
 
SEM MaybeDeclarations
  | Just    lhs  . localTypes = convertLocalTypes @lhs.monos @lhs.substitution @lhs.predicates @declarations.bindingGroups
                                `plusFM` @declarations.localTypes 
SEM Expression                    
  | Let     lhs  . localTypes = convertLocalTypes @lhs.monos @lhs.substitution @lhs.predicates @declarations.bindingGroups
                                `plusFM` @expression.localTypes 
SEM Statement                  
  | Let     lhs  . localTypes = convertLocalTypes @lhs.monos @lhs.substitution @lhs.predicates @declarations.bindingGroups
                                `plusFM` @declarations.localTypes 
SEM Qualifier                    
  | Let     lhs  . localTypes = convertLocalTypes @lhs.monos @lhs.substitution @lhs.predicates @declarations.bindingGroups
                                `plusFM` @declarations.localTypes
                                
{
convertLocalTypes :: Substitution substitution => Tps -> substitution -> Predicates -> BindingGroups -> FiniteMap NameWithRange TpScheme
convertLocalTypes monos substitution predicates groups = 
   let (environment, _, _) = concatBindingGroups groups
       monos' = ftv (substitution |-> monos)      
   in listToFM [ (NameWithRange name, generalize monos' predicates tp')
               | (name, tp) <- fmToList environment 
               , let  tp' = substitution |-> tp
               ]
}  


SEM Body
  | Body   loc . (anns,notypedefs) = findTypeAnnotations True [] @declarations.typeSignatures @declarations.bindingGroups
SEM MaybeDeclarations
  | Just   loc . (anns,notypedefs) = findTypeAnnotations False @lhs.monos @declarations.typeSignatures @declarations.bindingGroups
SEM Expression                    
  | Let    loc . (anns,notypedefs) = findTypeAnnotations False @lhs.monos @declarations.typeSignatures @declarations.bindingGroups
SEM Statement                    
  | Let    loc . (anns,notypedefs) = findTypeAnnotations False @lhs.monos @declarations.typeSignatures @declarations.bindingGroups
SEM Qualifier                    
  | Let    loc . (anns,notypedefs) = findTypeAnnotations False @lhs.monos @declarations.typeSignatures @declarations.bindingGroups   

{ 
type TypeAnnotations = [((Tps,Tp),TpScheme,(OneLineTree,Range))]
type NoTypeDefs      = [(Name,Tps,Tp,Bool)]

findTypeAnnotations :: Bool -> Tps -> FiniteMap Name TpScheme -> BindingGroups -> (TypeAnnotations,NoTypeDefs)
findTypeAnnotations toplevel monos typeSignatures bdgs =
   let (environment,_,_) = concatBindingGroups bdgs
       typeAnnotations   = [ ((monos,tp),ts,(OneLineText (show n),getNameRange n))
                           | (n,(tp,ts)) <- fmToList (intersectFM_C (,) environment typeSignatures)
                           ]
       noTypeDefs        = [ (n,monos,tp,toplevel)
                           | (n,tp) <- fmToList (delListFromFM environment (keysFM typeSignatures))
                           ]
   in (typeAnnotations,noTypeDefs)  
}

--------------------------------
-- Chunks

ATTR Expression Expressions MaybeExpression
     Statement Statements Qualifier Qualifiers  Alternative Alternatives
     Declaration Declarations MaybeDeclarations Body
     RightHandSide GuardedExpression GuardedExpressions
     FunctionBinding FunctionBindings  
     RecordExpressionBinding RecordExpressionBindings        
        [ currentChunk        : Int  
          chunkNumberMap      : ChunkNumberMap
        | uniqueChunk         : Int  
          collectChunkNumbers : ChunkNumberMap
        |
        ]         

SEM Module
  | Module   body . currentChunk        = 0
                  . uniqueChunk         = 1
                  . collectChunkNumbers = emptyFM 
                  . chunkNumberMap      = @body.collectChunkNumbers 

SEM Body              | Body   lhs . uniqueChunk = @chunkNr -- from binding groups                                   
SEM MaybeDeclarations | Just   lhs . uniqueChunk = @chunkNr  
SEM Expression        | Let    lhs . uniqueChunk = @chunkNr  
SEM Statement         | Let    lhs . uniqueChunk = @chunkNr  
SEM Qualifier         | Let    lhs . uniqueChunk = @chunkNr

SEM Declaration 
  | FunctionBindings   bindings      . currentChunk = findCurrentChunk @bindings.name @lhs.inheritedBDG -- from binding groups
  | PatternBinding     righthandside . currentChunk = findCurrentChunk (head (keysFM @pattern.environment)) @lhs.inheritedBDG  
  
SEM Expression 
  | Variable   lhs . collectChunkNumbers = addToFM @lhs.collectChunkNumbers @lhs.betaUnique @lhs.currentChunk
     
{
type ChunkNumberMap = FiniteMap Int Int

lookupChunkNumber :: Int -> ChunkNumberMap -> Int
lookupChunkNumber i fm = 
   let err = error ("could not find beta in lookupChunkNumber [i="++show i++"] [fm="++show (fmToList fm)++"]")
   in lookupWithDefaultFM fm err i

dependencyBinds :: ChunkNumberMap -> TypeConstraints a -> [(Int, TypeConstraint a)]
dependencyBinds fm cs = 
   let err = error "could not find variable of a constraint"
   in [ (lookupChunkNumber i fm, c) | c <- cs, let i = maybe err id (variableInConstraint c)]   
} 
