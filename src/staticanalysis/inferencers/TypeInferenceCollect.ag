-----------------------------------------------------------------------------
-- |The Helium Compiler : Static Analysis
-- 
-- Maintainer  :  bastiaan@cs.uu.nl
-- Stability   :  experimental
-- Portability :  unknown
--
-- Distributition of 
--   * import environment
--   * substitution   (result of solving the type constraints)
--   * predicates     (already substituted)
--   * inferred types
--   * ordered type synonyms
--
-----------------------------------------------------------------------------

ATTR Expression Expressions MaybeExpression Alternative Alternatives
     Statement Statements Declaration Declarations MaybeDeclarations 
     RightHandSide Body Qualifier Qualifiers   
     GuardedExpression GuardedExpressions  FunctionBinding FunctionBindings          
     RecordExpressionBinding RecordExpressionBindings      
        [ importEnvironment   : ImportEnvironment 
          substitution        : FixpointSubstitution  
          predicates          : Predicates 
          inferredTypes       : {FiniteMap NameWithRange TpScheme}
          orderedTypeSynonyms : OrderedTypeSynonyms
        | collectErrors       : TypeErrors
          collectWarnings     : Warnings
        | 
        ]

ATTR LeftHandSide Pattern Patterns [ importEnvironment : ImportEnvironment | | ]

----------------------------------------------------------------------------------------
-- Collecting inferred top level types

ATTR Body [ |  | toplevelTypes : TypeEnvironment ]   
  
SEM Body
  | Body   lhs . toplevelTypes = let (environment, _, _) = concatBindingGroups @declarations.bindingGroups
                                     monos' = ftv (@lhs.substitution |-> @lhs.monos)
                                     make _ = makeScheme monos' @lhs.predicates . (@lhs.substitution |->)
                                 in mapFM make environment
 
---------------------------------------------------------
-- Collecting (polymorphic) inferred types (that are in scope)

{- bug fix 10 september: the inferred types for where-declarations are also "visible" in the expression of the 
   right-hand side. Therefore, MaybeDeclarations should return a (synthesized) list of localTypes, and then 
   RightHandSide should distribute it down -}

ATTR MaybeDeclarations [ | | localTypes : {[(NameWithRange, TpScheme)]} ]

SEM Module 
  | Module  body . inferredTypes = listToFM [ (NameWithRange name, scheme)
                                            | (name, scheme) <- fmToList (typeEnvironment @lhs.importEnvironment)
                                            ]

SEM Body
  | Body   loc . inferredTypes = addListToFM @lhs.inferredTypes @localTypes
               . localTypes    = getInferredTypes @lhs.monos @lhs.substitution @lhs.predicates @declarations.bindingGroups 

SEM MaybeDeclarations
  | Just     loc . localTypes  = getInferredTypes @lhs.monos @lhs.substitution @lhs.predicates @declarations.bindingGroups 
  | Nothing  loc . localTypes  = []

SEM RightHandSide
  | Expression  loc . inferredTypes = addListToFM @lhs.inferredTypes @where.localTypes
  | Guarded     loc . inferredTypes = addListToFM @lhs.inferredTypes @where.localTypes

SEM Expression                    
  | Let    loc . inferredTypes = addListToFM @lhs.inferredTypes @localTypes
               . localTypes    = getInferredTypes @lhs.monos @lhs.substitution @lhs.predicates @declarations.bindingGroups 
                                     
SEM Statement                  
  | Let    loc . inferredTypes = addListToFM @lhs.inferredTypes @localTypes
               . localTypes    = getInferredTypes @lhs.monos @lhs.substitution @lhs.predicates @declarations.bindingGroups 

SEM Qualifier                    
  | Let    loc . inferredTypes = addListToFM @lhs.inferredTypes @localTypes
               . localTypes    = getInferredTypes @lhs.monos @lhs.substitution @lhs.predicates @declarations.bindingGroups 

{
getInferredTypes :: Substitution substitution => Monos -> substitution -> Predicates -> BindingGroups -> [(NameWithRange, TpScheme)]
getInferredTypes monos substitution predicates groups = 
   let (environment, _, _) = concatBindingGroups groups
       monos' = ftv (substitution |-> monos)
   in [ (NameWithRange name, makeScheme monos' predicates tp')
      | (name, tp) <- fmToList environment 
      , let  tp' = substitution |-> tp
      ]
}

----------------------------------------------------------------------------------------
-- Collecting additional type errors and warnings

SEM Module
  | Module  body . collectErrors   = []
                 . collectWarnings = []

-- declared type too general / missing type signature
SEM Body
  | Body   loc . (errors, warnings) = checkAnnotations True @lhs.orderedTypeSynonyms @declarations.typeSignatures @localTypes
           lhs . collectErrors      = @errors ++ @declarations.collectErrors
               . collectWarnings    = @warnings ++ @declarations.collectWarnings

SEM MaybeDeclarations
  | Just   loc . (errors, warnings) = checkAnnotations False @lhs.orderedTypeSynonyms @declarations.typeSignatures @localTypes
           lhs . collectErrors      = @errors ++ @declarations.collectErrors
               . collectWarnings    = @warnings ++ @declarations.collectWarnings 

SEM Expression
  | Let    loc . (errors, warnings) = checkAnnotations False @lhs.orderedTypeSynonyms @declarations.typeSignatures @localTypes
           lhs . collectErrors      = @errors ++ @expression.collectErrors
               . collectWarnings    = @warnings ++ @expression.collectWarnings

  | Typed  loc . errors             = let scheme = makeScheme monos' @lhs.predicates tp'
                                          monos' = ftv (@lhs.substitution |-> @lhs.monos)
                                          tp'    = @lhs.substitution |-> @expression.beta
                                          info   = (self . attribute) @expression.infoTree
                                      in checkNotTooGeneral True (Right info) @lhs.orderedTypeSynonyms @typeScheme scheme
           lhs . collectErrors      = @errors ++ @expression.collectErrors

                                     
SEM Statement                  
  | Let    loc . (errors, warnings) = checkAnnotations False @lhs.orderedTypeSynonyms @declarations.typeSignatures @localTypes
           lhs . collectErrors      = @errors ++ @declarations.collectErrors
               . collectWarnings    = @warnings ++ @declarations.collectWarnings

SEM Qualifier                    
  | Let    loc . (errors, warnings) = checkAnnotations False @lhs.orderedTypeSynonyms @declarations.typeSignatures @localTypes
           lhs . collectErrors      = @errors ++ @declarations.collectErrors
               . collectWarnings    = @warnings ++ @declarations.collectWarnings

{
checkAnnotations :: Bool -> OrderedTypeSynonyms -> FiniteMap Name TpScheme -> [(NameWithRange, TpScheme)] -> (TypeErrors, Warnings)
checkAnnotations topLevel synonyms typeSignatures = foldr op ([], [])
   where   
       op (nameWR, scheme) pair@(errors, warnings) =
          case lookupFM typeSignatures (nameWithRangeToName nameWR) of
          
             Just signature ->
                -- is the signature not too general?
                let -- this name has a different range!
                    nameOfSignature = head [ n | n <- keysFM typeSignatures, n == nameWithRangeToName nameWR ]      
                    newErrors = checkNotTooGeneral False (Left nameOfSignature) synonyms signature scheme             
                in (newErrors ++ errors, warnings)               
                       
             Nothing 
                -- issue a warning for missing type signature (unless monomorphic)
                | null (ftv scheme) && topLevel ->
                     let warning = NoTypeDef (nameWithRangeToName nameWR) scheme topLevel
                     in (errors, warning : warnings)
                     
             _ -> pair      

checkNotTooGeneral :: Bool -> Either Name UHA_Source -> OrderedTypeSynonyms -> TpScheme -> TpScheme -> TypeErrors
checkNotTooGeneral isAnnotation mySource synonyms signature scheme
   | genericInstanceOf synonyms standardClasses signature scheme = []
   | genericInstanceOf synonyms standardClasses (removePredicates signature) (removePredicates scheme) = 
        [makeMissingConstraintTypeError mySource scheme signature]
   | otherwise = 
        [makeNotGeneralEnoughTypeError isAnnotation source scheme signature]

 where 
   source = either nameToUHA_Expr id mySource
   removePredicates :: TpScheme ->  TpScheme
   removePredicates (Quantification (is, qm, a)) = 
      Quantification (is, qm, [] .=>. unqualify a)
      
}

-------------------------------------------
-- Collecting Type Signatures

ATTR Declaration Declarations [ | typeSignatures:{FiniteMap Name TpScheme} | ]

SEM Body              | Body    declarations . typeSignatures = emptyFM
SEM Expression        | Let     declarations . typeSignatures = emptyFM
SEM Statement         | Let     declarations . typeSignatures = emptyFM
SEM Qualifier         | Let     declarations . typeSignatures = emptyFM
SEM MaybeDeclarations | Just    declarations . typeSignatures = emptyFM

SEM Declaration
  | TypeSignature
      lhs . typeSignatures = addListToFM @lhs.typeSignatures [ (name, @typeScheme) | name <- @names.self ]
      loc . typeScheme     = makeTpSchemeFromType @type.self
           
--------------------------------
-- Chunks

ATTR Expression Expressions MaybeExpression
     Statement Statements Qualifier Qualifiers  Alternative Alternatives
     Declaration Declarations MaybeDeclarations Body
     RightHandSide GuardedExpression GuardedExpressions
     FunctionBinding FunctionBindings  
     RecordExpressionBinding RecordExpressionBindings        
        [ currentChunk        : Int  
          chunkNumberMap      : ChunkNumberMap
        | uniqueChunk         : Int  
          collectChunkNumbers : ChunkNumberMap
        |
        ]         

SEM Module
  | Module   body . currentChunk        = 0
                  . uniqueChunk         = 1
                  . collectChunkNumbers = emptyFM 
                  . chunkNumberMap      = @body.collectChunkNumbers 

SEM Body              | Body   lhs . uniqueChunk = @chunkNr -- from binding groups                                   
SEM MaybeDeclarations | Just   lhs . uniqueChunk = @chunkNr  
SEM Expression        | Let    lhs . uniqueChunk = @chunkNr  
SEM Statement         | Let    lhs . uniqueChunk = @chunkNr  
SEM Qualifier         | Let    lhs . uniqueChunk = @chunkNr

SEM Declaration 
  | FunctionBindings   bindings      . currentChunk = findCurrentChunk @bindings.name @lhs.inheritedBDG -- from binding groups
  | PatternBinding     righthandside . currentChunk = findCurrentChunk (head (keysFM @pattern.environment)) @lhs.inheritedBDG  
  
SEM Expression 
  | Variable   lhs . collectChunkNumbers = addToFM @lhs.collectChunkNumbers @lhs.betaUnique @lhs.currentChunk
