{
typingStrategyToCore :: TypingStrategy -> Core_TypingStrategy
typingStrategyToCore = fst . sem_TypingStrategy
}

INCLUDE "TS_Syntax.ag"
INCLUDE "TS_Collect.ag"
INCLUDE "../../../syntax/UHA_Syntax.ag"

imports {

import TS_Syntax
import TS_CoreSyntax
import Messages
import Top.Types
import HeliumConstraintInfo
import UHA_Range (noRange)
import UHA_Utils (getNameName)
import qualified UHA_OneLine 
import UHA_Source
import TypeConversion
import Utils (internalError)
import List
import TypeErrors
import OneLiner
import TS_Attributes
import LiftedConstraints
}

SEM TypingStrategy [ | | core : Core_TypingStrategy ]
  | Siblings
      lhs . core = Siblings (map getNameName @names.self)
  | TypingStrategy
      lhs . core = TypingStrategy @typerule.core @statements.core    
      loc . nameMap = zip @uniqueTypevariables (map TVar [0..])

SEM TypeRule [ | | core : Core_TypeRule ]
  | TypeRule 
      lhs . core = TypeRule @premises.core @conclusion.core

SEM Judgement [ | | core : Core_Judgement ]
  | Judgement
       lhs . core = Judgement (showOneLine 10000 $ fst $ UHA_OneLine.sem_Expression @expression.self) (makeTpFromType @lhs.nameMap @type.self)   

SEM SimpleJudgements [ | | core : Core_Judgements ]
  | Cons  lhs . core = @hd.core : @tl.core
  | Nil   lhs . core = []

SEM SimpleJudgement [ | | core : Core_Judgement ] 
  | SimpleJudgement 
       lhs . core = Judgement (show @name.self) (makeTpFromType @lhs.nameMap @type.self)              
       
SEM UserStatements [ | | core : Core_UserStatements ]
  | Cons  lhs . core = @hd.core : @tl.core
  | Nil   lhs . core = []

SEM UserStatement [ | | core : Core_UserStatement ]
  | Constraint                lhs . core = Constraint 
                                             (makeTpFromType @lhs.nameMap @leftType.self) 
                                             (makeTpFromType @lhs.nameMap @rightType.self) 
                                             (concat (substituteAttributes (algebraFromNameMap @lhs.nameMap) @message))
  | MetaVariableConstraints   lhs . core = MetaVariableConstraints (show @name.self)
  | Phase                     lhs . core = CorePhase @phase
       
{
algebraFromNameMap :: [(Name, Tp)] -> AttributeAlgebra String
algebraFromNameMap table = ( id
                           , [ ((show name, Nothing), showAttribute (show i, Nothing)) | (name, TVar i) <- table ]
                           , showAttribute
                           )
}
