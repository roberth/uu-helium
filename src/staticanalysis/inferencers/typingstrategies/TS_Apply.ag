INCLUDE "TS_CoreData.ag"

imports {
import UHA_Syntax
import LiftedConstraints
import HeliumConstraintInfo
import Top.Types
import List
import UHA_Range (noRange)
import Utils (internalError, fst3)
import OneLiner
import Messages
import TypeErrors
import ImportEnvironment
import OperatorTable (OperatorTable)
import Parser (exp_)
import Lexer (strategiesLexer)
import ParseLibrary (runHParser)
import qualified ResolveOperators
import TS_Attributes
import TS_CoreSyntax
import Top.ComposedSolvers.Tree
import UHA_Source
import Data.FiniteMap
import DoublyLinkedTree (root)
}

{
type MetaVariableTable info = [(String, (ConstraintSet, info))]
type MetaVariableInfo = (Tp, UHA_Source, Range)

applyTypingStrategy :: Core_TypingStrategy -> (ConstraintSet, MetaVariableInfo) -> MetaVariableTable MetaVariableInfo -> Int -> (ConstraintSet, IO (), Int)
applyTypingStrategy = sem_Core_TypingStrategy

matchInformation :: ImportEnvironment -> Core_TypingStrategy -> [(Expression, [String])]
matchInformation importEnvironment typingStrategy = 
   case typingStrategy of 
      TypingStrategy (TypeRule premises conclusion) _ -> 
         let Judgement exprstring _ = conclusion
             expression = expressionParser (operatorTable importEnvironment) exprstring
             metas      = [ s | Judgement s t <- premises ]
         in [(expression, metas)]
      _ -> []
      
expressionParser :: OperatorTable -> String -> Expression
expressionParser operatorTable string = 
    case strategiesLexer "TS_Apply" string of 
        Left lexErr -> intErr
        Right (tokens, _) ->
            case runHParser exp_ "TS_Apply" tokens True {- wait for EOF -} of
                Left parseError  -> intErr
                Right expression -> 
                    ResolveOperators.expression operatorTable expression
  where
    intErr = internalError "TS_Apply.ag" "n/a" ("unparsable expression: "++show string)
}

ATTR Core_TypingStrategy 
     [ infoTuple         : {(ConstraintSet, MetaVariableInfo)}
       metaVariableTable : {MetaVariableTable MetaVariableInfo}  
     | unique            : Int 
     | constraintSet     : ConstraintSet
       debugIO           : {IO ()}
     ] 
          
SEM Core_TypingStrategy 
  | Siblings     
       lhs . constraintSet = emptyTree
           . debugIO       = return ()
  | TypingStrategy     
       lhs . constraintSet = Node @allConstraintTrees
           . unique        = length @normalTV + @lhs.unique
           . debugIO       = putStrLn "applying typing strategy"
       loc . substitution  = listToSubstitution (@standardSubst ++ @specialSubst)
           . allTV         = @typerule.ftv `union` @statements.ftv

{- type variables that occur exactly once in a judgement should not introduce a new constraint -}           
           . specialTV     = concat . exactlyOnce . map ftv . filter isTVar . map snd $ @typerule.judgements
           . normalTV      = @allTV \\ @specialTV
           
           . standardSubst = zip @normalTV (map TVar [@lhs.unique..])
           . specialSubst  = let conclusionVar = case snd (last @typerule.judgements) of
                                                    TVar i -> Just i
                                                    _      -> Nothing
                                 find i | Just i == conclusionVar = [(i, fst3 (snd @lhs.infoTuple))]
                                        | otherwise               = [ (i,tp)
                                                                    | (s1, TVar j)       <- @typerule.judgements
                                                                    , i == j
                                                                    , (s2, (_,(tp,_,_))) <- @lhs.metaVariableTable
                                                                    , s1 == s2
                                                                    ]
                             in concatMap find @specialTV
                             

ATTR Core_TypeRule
     Core_Judgements Core_Judgement
     Core_UserStatements Core_UserStatement 
     [ substitution      : FiniteMapSubstitution 
       infoTuple         : {(ConstraintSet, MetaVariableInfo)}
       metaVariableTable : {MetaVariableTable MetaVariableInfo} 
     | 
     | ftv USE {++} {[]} : {[Int]} 
     ]

SEM Core_UserStatement 
  | Constraint  lhs . ftv = ftv [@leftType, @rightType]

SEM Core_Judgement
  | Judgement   lhs . ftv = ftv @type

ATTR Core_UserStatements Core_UserStatement 
     [ attributeTable     : {[((String, Maybe String), MessageBlock)]}
     | collectConstraints : {Trees (TypeConstraint HeliumConstraintInfo)} 
       currentPhase       : {Maybe Int} 
       currentPosition    : {(Int, Int)}
       metavarConstraints : {[(String,Tree (TypeConstraint HeliumConstraintInfo))]}
     | 
     ]

SEM Core_TypingStrategy 
  | TypingStrategy
       loc        . allConstraintTrees = listTree (reverse @typerule.constraints) :
                                         (map snd @statements.metavarConstraints) ++
                                         (reverse @statements.collectConstraints)
       statements . collectConstraints = []
                  . currentPhase       = Nothing
                  . currentPosition    = (@lhs.unique, 0)
                  . metavarConstraints = [ (s,cs) | (s,(cs,_)) <- @lhs.metaVariableTable ] 
                  . attributeTable     = makeAttributeTable (snd @lhs.infoTuple) @lhs.metaVariableTable @substitution

SEM Core_UserStatement
  | Constraint
       lhs . currentPosition    = (\(x, y) -> (x, y+1)) @lhs.currentPosition 
           . collectConstraints = case @lhs.currentPhase of
                                     Just phase | phase /= 5 
                                                -> Phase phase [ @newConstraint ] : @lhs.collectConstraints
                                     _          -> unitTree @newConstraint : @lhs.collectConstraints
       
  | MetaVariableConstraints        
       lhs . metavarConstraints = filter ((@name /=) . fst) @lhs.metavarConstraints
           . collectConstraints = case lookup @name @lhs.metavarConstraints of
                                      Just tree -> tree : @lhs.collectConstraints
                                      Nothing   -> internalError "TS_Apply.ag" "n/a" "unknown constraint set"
                                      
  | CorePhase 
       lhs . currentPhase = Just @phase                  

SEM Core_UserStatement
  | Constraint  
       loc . newConstraint = 
          let cinfo   = addProperty (WithTypeError (CustomTypeError [] message)) . 
                        addProperty (uncurry IsUserConstraint @lhs.currentPosition) .
                        standardConstraintInfo @lhs.currentPosition
                           -- (setCustomTypeError (snd @lhs.infoTuple) . standardConstraintInfo)
              message = [MessageOneLiner (MessageCompose (substituteAttributes (makeMessageAlgebra @lhs.attributeTable) @message))]                       
          in (@lhs.substitution |-> @leftType .==. @lhs.substitution |-> @rightType) cinfo

{
standardConstraintInfo :: (Int, Int) -> (Tp, Tp) -> HeliumConstraintInfo
standardConstraintInfo pos tppair =
   CInfo { location   = "Typing Strategy"
         , sources    = (UHA_Decls [], Nothing)
         , typepair   = tppair
         , localInfo  = root (LocalInfo (UHA_Decls []) Nothing emptyFM) []
         , properties = [ ]
         }
}

ATTR Core_TypeRule [ | | constraints : {TypeConstraints HeliumConstraintInfo} ]

SEM Core_TypeRule             
  | TypeRule        
       lhs .  constraints = let infoTuple@(localType, localTree, _) = snd @lhs.infoTuple
                                localLocation = "expression" -- not very precise
                            in [ (@lhs.substitution |-> tp1 .==. localType) 
                                    (typeRuleCInfo localLocation Nothing infoTuple)
                               | (s1, tp1) <- @conclusion.judgements
                               ]
                               ++
                               [ (tp2 .==. @lhs.substitution |-> tp1) 
                                    (typeRuleCInfo localLocation (Just (s1, localTree)) mvinfo)
                               | (s1, tp1)                   <- @premises.judgements 
                               , (s2, (_, mvinfo@(tp2,_,_))) <- @lhs.metaVariableTable
                               , s1 == s2
                               ]

{
typeRuleCInfo :: String -> Maybe (String, UHA_Source) -> MetaVariableInfo -> (Tp, Tp) -> HeliumConstraintInfo
typeRuleCInfo loc mTuple (tp1,tree,range) tppair =
   CInfo { location   = loc
         , sources    = (UHA_Decls [], Nothing)
         , typepair   = tppair
         , properties = []
         }
-- where (infoString, srcs, props) = case mTuple of 
--          Just (s,t) -> ("meta variable "++s, [sourceExpression t, sourceTerm tree], [])
--          Nothing    -> ("conclusion", [sourceExpression tree], [FolkloreConstraint])

-- see TypeInferenceInfo.ag
sourceTerm, sourceExpression :: OneLineTree -> (String, OneLineTree)
sourceTerm        = (,) "term"
sourceExpression  = (,) "expression"

exactlyOnce :: Eq a => [a] -> [a]
exactlyOnce []     = []
exactlyOnce (x:xs) | x `elem` xs = exactlyOnce . filter (/= x) $ xs
                   | otherwise   = x : exactlyOnce xs

setCustomTypeError :: MetaVariableInfo -> HeliumConstraintInfo -> HeliumConstraintInfo
setCustomTypeError (tp, source, range) cinfo =
   addProperty (WithTypeError customTypeError) cinfo        

     where customTypeError = CustomTypeError [range] message
           message = [ MessageOneLiner (MessageString ("Type error in "++"Typing Strategy")) -- !!!
                     , MessageTable
                       [ (MessageString "Expression", MessageOneLineTree (oneLinerSource source)) ]                     
                     , MessageOneLiner (MessageString "   implies that the following types are equal:")
                     , MessageTable 
                       [ (MessageString "Type 1", MessageType ([] .=>. fst (typepair cinfo)))
                       , (MessageString "Type 2", MessageType ([] .=>. snd (typepair cinfo)))
                       ]                     
                     ]  

makeMessageAlgebra :: AttributeTable MessageBlock -> AttributeAlgebra MessageBlock
makeMessageAlgebra table = ( MessageString
                           , table
                           , \attribute -> internalError 
                                              "TS_Apply" "makeMessageAlgebra"
                                              ("unknown attribute " ++ showAttribute attribute ++
                                               "; known attributes are " ++ show (map (showAttribute . fst) table))
                           )

makeAttributeTable :: MetaVariableInfo -> MetaVariableTable MetaVariableInfo -> FiniteMapSubstitution -> [((String, Maybe String), MessageBlock)]
makeAttributeTable local table substitution = 
   let f :: String -> MetaVariableInfo -> [((String, Maybe String), MessageBlock)]
       f string (tp, source, range) = [ ((string, Just "type" ), MessageType ([] .=>. tp))
                                      , ((string, Just "pp"   ), MessageOneLineTree (oneLinerSource source))
                                      , ((string, Just "range"), MessageRange range)
                                      ]
   in f "expr" local 
   ++ concatMap (\(s,(_,info)) -> f s info) table 
   ++ [ ((show i, Nothing), MessageType ([] .=>. (substitution |-> TVar i))) | i <- dom substitution ]  
}

ATTR Core_Judgements Core_Judgement Core_TypeRule [ | | judgements USE {++} {[]} : {[(String, Tp)]} ]

SEM Core_Judgement
  | Judgement
       lhs . judgements = [(@expression, @type)]     
