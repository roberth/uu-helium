INCLUDE "TS_AG_CoreSyntax.ag"

imports {
import UHA_Syntax
import TS_CoreSyntax
import ConstraintTree
import Constraints
import HeliumConstraintInfo
import TypeGraphConstraintInfo
import Types
import List
import UHA_Range (noRange)
import Utils (internalError)
import OneLiner
import Messages
import TypeErrors
import ImportEnvironment
import OperatorTable (OperatorTable)
import Parser (exp_)
import Lexer (strategiesLexer)
import ParseLibrary (runHParser)
import qualified ResolveOperators
import TS_Attributes
}

{
type MetaVariableTable info = [(String, (ConstraintSet, info))]
type MetaVariableInfo = (Tp, Tree, Range)

applyTypingStrategy :: Core_TypingStrategy -> (ConstraintSet, MetaVariableInfo) -> MetaVariableTable MetaVariableInfo -> Int -> (ConstraintSet, IO (), Int)
applyTypingStrategy = sem_Core_TypingStrategy

matchInformation :: ImportEnvironment -> Core_TypingStrategy -> (Expression, [String])
matchInformation importEnvironment typingStrategy = 
   case typingStrategy of 
      TypingStrategy (TypeRule premises conclusion) _ -> 
         let Judgement exprstring _ = conclusion
             expression = expressionParser (operatorTable importEnvironment) exprstring
             metas      = [ s | Judgement s t <- premises ]
         in (expression, metas)
      _ -> internalError "TS_Apply.ag" "n/a" "unknown TypingStrategy"
      
expressionParser :: OperatorTable -> String -> Expression
expressionParser operatorTable string = 
    case strategiesLexer "TS_Apply" string of 
        Left lexErr -> intErr
        Right (tokens, _) ->
            case runHParser exp_ "TS_Apply" tokens True {- wait for EOF -} of
                Left parseError  -> intErr
                Right expression -> 
                    ResolveOperators.expression operatorTable expression
  where
    intErr = internalError "TS_Apply.ag" "n/a" ("unparsable expression: "++show string)
}


ATTR Core_TypingStrategy 
     [ localInfo         : {(ConstraintSet, MetaVariableInfo)}
       metaVariableTable : {MetaVariableTable MetaVariableInfo}  
     | unique            : Int 
     | constraintSet     : ConstraintSet
       debugIO           : {IO ()}
     ] 
          
SEM Core_TypingStrategy 
  | TypingStrategy     
       lhs . constraintSet = ctNode @allConstraintTrees
           . unique        = length @ftv + @lhs.unique
           . debugIO       = putStrLn "applying typing strategy"
       loc . substitution  = listToSubstitution (zip @ftv (map TVar [@lhs.unique..]))
           . ftv           = @typerule.ftv `union` @statements.ftv

ATTR Core_TypeRule
     Core_Judgements Core_Judgement
     Core_UserStatements Core_UserStatement 
     [ substitution      : FiniteMapSubstitution 
       localInfo         : {(ConstraintSet, MetaVariableInfo)}
       metaVariableTable : {MetaVariableTable MetaVariableInfo} 
     | 
     | ftv USE {++} {[]} : {[Int]} 
     ]

SEM Core_UserStatement 
  | Constraint  lhs . ftv = ftv [@leftType, @rightType]

SEM Core_Judgement
  | Judgement   lhs . ftv = ftv @type

ATTR Core_UserStatements Core_UserStatement 
     [ attributeTable     : {[((String, Maybe String), MessageBlock)]}
     | collectConstraints : {ConstraintTrees HeliumConstraintInfo} 
       currentPhase       : {Maybe Int} 
       currentPosition    : {(Int, Int)}
       metavarConstraints : {[(String,ConstraintTree HeliumConstraintInfo)]}
     | 
     ]

SEM Core_TypingStrategy 
  | TypingStrategy
       loc        . allConstraintTrees = ctSingle (reverse @typerule.constraints) :
                                         (map snd @statements.metavarConstraints) ++
                                         (reverse @statements.collectConstraints)
       statements . collectConstraints = []
                  . currentPhase       = Nothing
                  . currentPosition    = (@lhs.unique, 0)
                  . metavarConstraints = [ (s,cs) | (s,(cs,_)) <- @lhs.metaVariableTable ] 
                  . attributeTable     = makeAttributeTable (snd @lhs.localInfo) @lhs.metaVariableTable @substitution

SEM Core_UserStatement
  | Constraint
       lhs . currentPosition    = (\(x, y) -> (x, y+1)) @lhs.currentPosition 
           . collectConstraints = case @lhs.currentPhase of
                                     Just phase -> ctPhased phase [ @newConstraint ] : @lhs.collectConstraints
                                     Nothing    -> ctSingle       [ @newConstraint ] : @lhs.collectConstraints
       
  | MetaVariableConstraints        
       lhs . metavarConstraints = filter ((@name /=) . fst) @lhs.metavarConstraints
           . collectConstraints = case lookup @name @lhs.metavarConstraints of
                                      Just tree -> tree : @lhs.collectConstraints
                                      Nothing   -> internalError "TS_Apply.ag" "n/a" "unknown constraint set"
                                      
  | Phase 
       lhs . currentPhase = Just @phase                  

SEM Core_UserStatement
  | Constraint  
       loc . newConstraint = 
          let cinfo   = addProperty (WithTypeError (CustomTypeError [] message)) . 
                        addProperty (uncurry IsUserConstraint @lhs.currentPosition) .
                        standardConstraintInfo @lhs.currentPosition
                           -- (setCustomTypeError (snd @lhs.localInfo) . standardConstraintInfo)
              message = [MessageOneLiner (MessageCompose (substituteAttributes (makeMessageAlgebra @lhs.attributeTable) @message))]                       
          in (@lhs.substitution |-> @leftType .==. @lhs.substitution |-> @rightType) cinfo

{
standardConstraintInfo :: (Int, Int) -> (Tp, Tp) -> HeliumConstraintInfo
standardConstraintInfo pos tppair =
   CInfo { info       = (NTBody, AltBody, (-1), "Strategy, user constraint, "++show pos)
         , location   = "Typing Strategy"
         , errorrange = noRange
         , sources    = [ ]
         , typepair   = tppair
         , properties = [ ]
         }
}

ATTR Core_TypeRule [ | | constraints : {Constraints HeliumConstraintInfo} ]

SEM Core_TypeRule             
  | TypeRule        
       lhs .  constraints = [ (@lhs.substitution |-> tp1 .==. tp2) (typeRuleCInfo "conclusion" mvinfo)
                            | (s1, tp1) <- @conclusion.judgements
                            , let (_, mvinfo@(tp2,_,_)) = @lhs.localInfo
                            ]
                            ++
                            [ (@lhs.substitution |-> tp1 .==. tp2) (typeRuleCInfo s1 mvinfo)
                            | (s1, tp1)                   <- @premises.judgements 
                            , (s2, (_, mvinfo@(tp2,_,_))) <- @lhs.metaVariableTable
                            , s1 == s2
                            ]

{
typeRuleCInfo :: String -> MetaVariableInfo -> (Tp, Tp) -> HeliumConstraintInfo
typeRuleCInfo = 
   \string (tp1,tree,range) tppair ->
      CInfo { info       = (NTBody, AltBody, (-1), "Typing Strategy, meta-typevariable " ++ string)
            , location   = "Typing Strategy"
            , errorrange = noRange
            , sources    = [ ]
            , typepair   = tppair
            , properties = [ HighlyTrusted ] 
            }

setCustomTypeError :: MetaVariableInfo -> HeliumConstraintInfo -> HeliumConstraintInfo
setCustomTypeError (tp, tree, range) cinfo =
   addProperty (WithTypeError customTypeError) cinfo        

     where customTypeError = CustomTypeError [range] message
           message = [ MessageOneLiner (MessageString ("Type error in "++"Typing Strategy")) -- !!!
                     , MessageTable
                       [ (MessageString "Expression", MessageOneLineTree tree) ]                     
                     , MessageOneLiner (MessageString "   implies that the following types are equal:")
                     , MessageTable 
                       [ (MessageString "Type 1", MessageType (fst (typepair cinfo)))
                       , (MessageString "Type 2", MessageType (snd (typepair cinfo)))
                       ]                     
                     ]  

makeMessageAlgebra :: AttributeTable MessageBlock -> AttributeAlgebra MessageBlock
makeMessageAlgebra table = ( MessageString
                           , table
                           , \attribute -> internalError 
                                              "TS_Apply" "makeMessageAlgebra"
                                              ("unknown attribute " ++ showAttribute attribute ++
                                               "; known attributes are " ++ show (map (showAttribute . fst) table))
                           )

makeAttributeTable :: MetaVariableInfo -> MetaVariableTable MetaVariableInfo -> FiniteMapSubstitution -> [((String, Maybe String), MessageBlock)]
makeAttributeTable local table substitution = 
   let f :: String -> MetaVariableInfo -> [((String, Maybe String), MessageBlock)]
       f string (tp, tree, range) = [ ((string, Just "type" ), MessageType tp)
                                    , ((string, Just "pp"   ), MessageOneLineTree tree)
                                    , ((string, Just "range"), MessageRange range)
                                    ]
   in f "expr" local 
   ++ concatMap (\(s,(_,info)) -> f s info) table 
   ++ [ ((show i, Nothing), MessageType (substitution |-> TVar i)) | i <- dom substitution ]  
}

ATTR Core_Judgements Core_Judgement [ | | judgements USE {++} {[]} : {[(String, Tp)]} ]



SEM Core_Judgement
  | Judgement
       lhs . judgements = [(@expression, @type)]
