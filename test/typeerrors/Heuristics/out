[H[2J---------------------------------------------
module AppInsert1 where

main :: [Int]
main = filter [1..]
---------------------------------------------
--- Algorithm W:
Compiling ./AppInsert1.hs
(4,8): Type error in application
*** Expression     : filter [ 1 ..  ]
*** Term           : filter
*** Type           : (a -> Bool) -> [a] -> [a]
*** Does not match : [Int]       -> [Int]

--- Algorithm M:
Compiling ./AppInsert1.hs
(4,8): Type error in variable
*** Expression     : filter
*** Type           : (a -> Bool) -> [a] -> [a]
*** Expected type  : [Int]       -> [Int]

--- TypeGraphs:
Compiling ./AppInsert1.hs
(4,8): Type error in application
*** Expression     : filter [ 1 ..  ]
*** Term           : filter
*** Type           : (a -> Bool) -> [a] -> [a]
*** Does not match : [Int]       -> [Int]
*** Probable fix   : insert a first argument

---------------------------------------------
module AppInsert2 where

sumInts :: [Int] -> Int
sumInts xs = foldr (+) xs
---------------------------------------------
--- Algorithm W:
Compiling ./AppInsert2.hs
(4,14): Type error in application
*** Expression     : foldr (+) xs
*** Term           : foldr
*** Type           : (a   -> b   -> b)   -> b     -> [a] -> b
*** Does not match : (Int -> Int -> Int) -> [Int] -> Int

--- Algorithm M:
Compiling ./AppInsert2.hs
(4,14): Type error in variable
*** Expression     : foldr
*** Type           : (a   -> b   -> b)   -> b     -> [a] -> b
*** Expected type  : (Int -> Int -> Int) -> [Int] -> Int

--- TypeGraphs:
Compiling ./AppInsert2.hs
(4,14): Type error in application
*** Expression     : foldr (+) xs
*** Term           : foldr
*** Type           : (a   -> b   -> b)   -> b     -> [a] -> b
*** Does not match : (Int -> Int -> Int) -> [Int] -> Int
*** Probable fix   : insert a second argument

---------------------------------------------
module AppNotABinFunction1 where

plusEen :: Int -> Int
plusEen x = x + 1

main = 3 `plusEen` 5
---------------------------------------------
--- Algorithm W:
Compiling ./AppNotABinFunction1.hs
(6,8): Type error in infix application
*** Expression     : 3 `plusEen` 5
*** Term           : plusEen
*** Type           : Int -> Int
*** Does not match : Int -> Int -> a

--- Algorithm M:
Compiling ./AppNotABinFunction1.hs
(6,10): Type error in variable
*** Expression     : plusEen
*** Type           : Int -> Int
*** Expected type  : Int -> Int -> a

--- TypeGraphs:
Compiling ./AppNotABinFunction1.hs
(6,8): Type error in infix application
*** Expression     : 3 `plusEen` 5
*** Term           : plusEen
*** Type           : Int -> Int
*** Does not match : Int -> Int -> a
*** Because        : it is not a binary function

---------------------------------------------
module AppNotABinFunction2 where

test :: Bool -> Bool -> Bool
test x y = (x && y) `not` (x || y)
---------------------------------------------
--- Algorithm W:
Compiling ./AppNotABinFunction2.hs
(4,12): Type error in infix application
*** Expression     : (x&&y) `not` (x||y)
*** Term           : not
*** Type           : Bool -> Bool
*** Does not match : Bool -> Bool -> Bool

--- Algorithm M:
Compiling ./AppNotABinFunction2.hs
(4,21): Type error in variable
*** Expression     : not
*** Type           : Bool -> Bool
*** Expected type  : Bool -> Bool -> Bool

--- TypeGraphs:
Compiling ./AppNotABinFunction2.hs
(4,12): Type error in infix application
*** Expression     : (x&&y) `not` (x||y)
*** Term           : not
*** Type           : Bool -> Bool
*** Does not match : Bool -> Bool -> Bool
*** Because        : it is not a binary function

---------------------------------------------
module AppNotAFunction1 where

main = do putStrLn $ "hello" "world"
---------------------------------------------
--- Algorithm W:
Compiling ./AppNotAFunction1.hs
(3,22): Type error in application
*** Expression     : "hello" "world"
*** Term           : "hello"
*** Type           : String
*** Does not match : String -> String

--- Algorithm M:
Compiling ./AppNotAFunction1.hs
(3,22): Type error in literal
*** Expression     : "hello"
*** Type           : String
*** Expected type  : String -> String

--- TypeGraphs:
Compiling ./AppNotAFunction1.hs
(3,22): Type error in application
*** Expression     : "hello" "world"
*** Term           : "hello"
*** Type           : String
*** Does not match : String -> String
*** Because        : it is not a function

---------------------------------------------
module AppNotAFunction2 where

main x = if even x
           then [ 1 .. x ]
           else x 3
---------------------------------------------
--- Algorithm W:
Compiling ./AppNotAFunction2.hs
(5,17): Type error in application
*** Expression     : x 3
*** Term           : x
*** Type           : Int
*** Does not match : Int -> [Int]

--- Algorithm M:
Compiling ./AppNotAFunction2.hs
(5,17): Type error in variable
*** Expression     : x
*** Type           : Int
*** Expected type  : Int -> [Int]

--- TypeGraphs:
Compiling ./AppNotAFunction2.hs
(5,17): Type error in application
*** Expression     : x 3
*** Term           : x
*** Type           : Int
*** Does not match : Int -> [Int]
*** Because        : it is not a function

---------------------------------------------
module AppNotEnough1 where

sumInts :: [Int] -> Int
sumInts xs = foldr (+) 0 
---------------------------------------------
--- Algorithm W:
Compiling ./AppNotEnough1.hs
(4,1): Type error in function binding
*** Term           : foldr (+) 0
*** Type           : [Int] -> Int
*** Does not match : Int

--- Algorithm M:
Compiling ./AppNotEnough1.hs
(4,14): Type error in variable
*** Expression     : foldr
*** Type           : (a   -> b   -> b)   -> b   -> [a] -> b
*** Expected type  : (Int -> Int -> Int) -> Int -> Int

--- TypeGraphs:
Compiling ./AppNotEnough1.hs
(4,14): Type error in application
*** Expression     : foldr (+) 0
*** Term           : foldr
*** Type           : (a   -> b   -> b)   -> b   -> [a] -> b
*** Does not match : (Int -> Int -> Int) -> Int -> Int
*** Probable fix   : insert a third argument

---------------------------------------------
module AppNotEnough2 where

main = [ i | i <- [1..10], (==) i ]
---------------------------------------------
--- Algorithm W:
Compiling ./AppNotEnough2.hs
(3,28): Type error in boolean qualifier
*** Expression     : (==) i
*** Type           : Int -> Bool
*** Does not match : Bool

--- Algorithm M:
Compiling ./AppNotEnough2.hs
(3,28): Type error in infix application
*** Expression     : (==)
*** Type           : Int -> Int -> Bool
*** Expected type  : Int -> Bool

--- TypeGraphs:
Compiling ./AppNotEnough2.hs
(3,28): Type error in application
*** Expression     : (==) i
*** Term           : (==)
*** Type           : Int -> Int -> Bool
*** Does not match : Int -> Bool
*** Because        : not enough arguments are given

---------------------------------------------
module AppRemove1 where

main = map 3 even [1..10]
---------------------------------------------
--- Algorithm W:
Compiling ./AppRemove1.hs
(3,8): Type error in application
*** Expression     : map 3 even [ 1 .. 10 ]
*** Term           : map
*** Type           : (a -> b) -> [a]           -> [b]
*** Does not match : Int      -> (Int -> Bool) -> [Int] -> c

--- Algorithm M:
Compiling ./AppRemove1.hs
(3,8): Type error in variable
*** Expression     : map
*** Type           : (a -> b) -> [a]           -> [b]
*** Expected type  : Int      -> (Int -> Bool) -> [Int] -> c

--- TypeGraphs:
Compiling ./AppRemove1.hs
(3,8): Type error in application
*** Expression     : map 3 even [ 1 .. 10 ]
*** Term           : map
*** Type           : (a -> b) -> [a]           -> [b]
*** Does not match : Int      -> (Int -> Bool) -> [Int] -> c
*** Probable fix   : remove first argument

---------------------------------------------
module AppRemove2 where

f :: Int -> Int
f x = x

main = f 3 True False
---------------------------------------------
--- Algorithm W:
Compiling ./AppRemove2.hs
(6,8): Type error in application
*** Expression     : f 3 True False
*** Term           : f
*** Type           : Int -> Int
*** Does not match : Int -> Bool -> Bool -> a

--- Algorithm M:
Compiling ./AppRemove2.hs
(6,8): Type error in variable
*** Expression     : f
*** Type           : Int -> Int
*** Expected type  : Int -> Bool -> Bool -> a

--- TypeGraphs:
Compiling ./AppRemove2.hs
(6,8): Type error in application
*** Expression     : f 3 True False
*** Term           : f
*** Type           : Int -> Int
*** Does not match : Int -> Bool -> Bool -> a
*** Probable fix   : remove second and third argument

---------------------------------------------
module AppReorder1 where

main :: [Int]
main = map [1 .. 10] fac

fac :: Int -> Int
fac = undefined
---------------------------------------------
--- Algorithm W:
Compiling ./AppReorder1.hs
(4,8): Type error in application
*** Expression     : map [ 1 .. 10 ] fac
*** Term           : map
*** Type           : (a -> b) -> [a]          -> [b  ]
*** Does not match : [Int]    -> (Int -> Int) -> [Int]

--- Algorithm M:
Compiling ./AppReorder1.hs
(4,22): Type error in variable
*** Expression     : fac
*** Type           : Int -> Int
*** Expected type  : [a]

(4,12): Type error in enumeration
*** Expression     : [ 1 .. 10 ]
*** Type           : [Int]
*** Expected type  : a -> Int

--- TypeGraphs:
Compiling ./AppReorder1.hs
(4,8): Type error in application
*** Expression     : map [ 1 .. 10 ] fac
*** Term           : map
*** Type           : (a -> b) -> [a]          -> [b  ]
*** Does not match : [Int]    -> (Int -> Int) -> [Int]
*** Probable fix   : re-order arguments

---------------------------------------------
module AppReorder2 where

sumInts :: [Int] -> Int
sumInts = foldr 0 (+) 
---------------------------------------------
--- Algorithm W:
Compiling ./AppReorder2.hs
(4,11): Type error in application
*** Expression     : foldr 0 (+)
*** Term           : foldr
*** Type           : (a -> b -> b) -> b                   -> [a  ] -> b
*** Does not match : Int           -> (Int -> Int -> Int) -> [Int] -> Int

--- Algorithm M:
Compiling ./AppReorder2.hs
(4,19): Type error in infix application
*** Expression     : (+)
*** Type           : Int -> Int -> Int
*** Expected type  : Int

(4,17): Type error in literal
*** Expression     : 0
*** Type           : Int
*** Expected type  : Int -> Int -> Int

--- TypeGraphs:
Compiling ./AppReorder2.hs
(4,11): Type error in application
*** Expression     : foldr 0 (+)
*** Term           : foldr
*** Type           : (a -> b -> b) -> b                   -> [a  ] -> b
*** Does not match : Int           -> (Int -> Int -> Int) -> [Int] -> Int
*** Probable fix   : re-order arguments

---------------------------------------------
module AppSubterm1 where

main :: [Int]
main = filter p [1 .. 10]
  where p x y = x || y
---------------------------------------------
--- Algorithm W:
Compiling ./AppSubterm1.hs
(4,8): Type error in application
*** Expression     : filter p [ 1 .. 10 ]
*** Term           : filter
*** Type           : (a    -> Bool)         -> [a  ] -> [a  ]
*** Does not match : (Bool -> Bool -> Bool) -> [Int] -> [Int]

--- Algorithm M:
Compiling ./AppSubterm1.hs
(4,15): Type error in variable
*** Expression     : p
*** Type           : Bool -> Bool -> Bool
*** Expected type  : Int  -> Bool

--- TypeGraphs:
Compiling ./AppSubterm1.hs
(4,8): Type error in application
*** Expression     : filter p [ 1 .. 10 ]
*** Term           : p
*** Type           : Bool -> Bool -> Bool
*** Expected type  : a    -> Bool

---------------------------------------------
module AppSubterm2 where

f :: Int -> Int -> Int -> Int
f a b c = 2 * (2 * a + b) + c 

main :: Int -> Int
main x = f 0 (x==1) x
---------------------------------------------
--- Algorithm W:
Compiling ./AppSubterm2.hs
(7,10): Type error in application
*** Expression     : f 0 (x==1) x
*** Term           : f
*** Type           : Int -> Int  -> Int -> Int
*** Does not match : Int -> Bool -> Int -> Int

--- Algorithm M:
Compiling ./AppSubterm2.hs
(7,16): Type error in variable
*** Expression     : ==
*** Type           : Int -> Int -> Bool
*** Expected type  : Int -> Int -> Int

--- TypeGraphs:
Compiling ./AppSubterm2.hs
(7,10): Type error in application
*** Expression     : f 0 (x==1) x
*** Term           : (x==1)
*** Type           : Bool
*** Expected type  : Int

---------------------------------------------
module AppSwap1 where

isEven :: Int -> Bool
isEven i = [0,2..] `elemInt` i

elemInt :: Int -> [Int] -> Bool
elemInt i []     = False
elemInt i (x:xs) = i == x || elemInt i xs               
---------------------------------------------
--- Algorithm W:
Compiling ./AppSwap1.hs
(4,12): Type error in infix application
*** Expression     : [ 0, 2 ..  ] `elemInt` i
*** Term           : elemInt
*** Type           : Int   -> [Int] -> Bool
*** Does not match : [Int] -> Int   -> Bool

--- Algorithm M:
Compiling ./AppSwap1.hs
(4,30): Type error in variable
*** Expression     : i
*** Type           : Int
*** Expected type  : [Int]

(4,12): Type error in enumeration
*** Expression     : [ 0, 2 ..  ]
*** Type           : [Int]
*** Expected type  : Int

--- TypeGraphs:
Compiling ./AppSwap1.hs
(4,12): Type error in infix application
*** Expression     : [ 0, 2 ..  ] `elemInt` i
*** Term           : elemInt
*** Type           : Int   -> [Int] -> Bool
*** Does not match : [Int] -> Int   -> Bool
*** Probable fix   : swap the two arguments

---------------------------------------------
module AppSwap2 where

type IntTable a = [(Int,a)]

zeroValue :: String
zeroValue = dictionary ? 0

(?) :: Int -> IntTable b -> b
(?) = undefined

dictionary :: IntTable String
dictionary = [ (0,"nul"), (1,"een"), (2,"twee") ]
---------------------------------------------
--- Algorithm W:
Compiling ./AppSwap2.hs
(6,13): Type error in infix application
*** Expression     : dictionary?0
*** Term           : ?
*** Type           : Int             -> IntTable a -> a
*** Does not match : IntTable String -> Int        -> String

--- Algorithm M:
Compiling ./AppSwap2.hs
(6,26): Type error in literal
*** Expression     : 0
*** Type           : Int
*** Expected type  : IntTable String

(6,13): Type error in variable
*** Expression     : dictionary
*** Type           : IntTable String
*** Expected type  : Int

--- TypeGraphs:
Compiling ./AppSwap2.hs
(6,13): Type error in infix application
*** Expression     : dictionary?0
*** Term           : ?
*** Type           : Int             -> IntTable a -> a
*** Does not match : IntTable String -> Int        -> String
*** Probable fix   : swap the two arguments

---------------------------------------------
module AppTooManyArguments1 where

fac :: Int -> Int
fac 0 = 1
fac n = n * (fac n 1)
---------------------------------------------
--- Algorithm W:
Compiling ./AppTooManyArguments1.hs
(5,14): Type error in application
*** Expression     : fac n 1
*** Term           : fac
*** Type           : Int -> Int
*** Does not match : Int -> Int -> Int

--- Algorithm M:
Compiling ./AppTooManyArguments1.hs
(5,14): Type error in variable
*** Expression     : fac
*** Type           : Int -> Int
*** Expected type  : Int -> Int -> Int

--- TypeGraphs:
Compiling ./AppTooManyArguments1.hs
(5,14): Type error in application
*** Expression     : fac n 1
*** Term           : fac
*** Type           : Int -> Int
*** Does not match : Int -> Int -> Int
*** Because        : too many arguments are given

---------------------------------------------
module AppTooManyArguments2 where

main :: [Int]
main = filter even [0,2..] [1,3..]
---------------------------------------------
--- Algorithm W:
Compiling ./AppTooManyArguments2.hs
(4,8): Type error in application
*** Expression     : filter even [ 0, 2 ..  ] [ 1, 3 ..  ]
*** Term           : filter
*** Type           : (a   -> Bool) -> [a  ] -> [a]
*** Does not match : (Int -> Bool) -> [Int] -> [Int] -> [Int]

--- Algorithm M:
Compiling ./AppTooManyArguments2.hs
(4,8): Type error in variable
*** Expression     : filter
*** Type           : (a   -> Bool) -> [a  ] -> [a]
*** Expected type  : (Int -> Bool) -> [Int] -> [Int] -> [Int]

--- TypeGraphs:
Compiling ./AppTooManyArguments2.hs
(4,8): Type error in application
*** Expression     : filter even [ 0, 2 ..  ] [ 1, 3 ..  ]
*** Term           : filter
*** Type           : (a   -> Bool) -> [a  ] -> [a]
*** Does not match : (Int -> Bool) -> [Int] -> [Int] -> [Int]
*** Because        : too many arguments are given

---------------------------------------------
module FBHasTooMany1 where

f :: Int 
f x = x + x
---------------------------------------------
--- Algorithm W:
Compiling ./FBHasTooMany1.hs
(4,1): Type error in explicitly typed binding
*** Term           : f
*** Type           : Int
*** Expected type  : Int -> Int

--- Algorithm M:
Compiling ./FBHasTooMany1.hs
(4,1): Type error in explicitly typed binding
*** Term           : f
*** Type           : Int
*** Expected type  : Int -> Int

--- TypeGraphs:
Compiling ./FBHasTooMany1.hs
(4,1): Type error in explicitly typed binding
*** Term           : f
*** Type           : Int
*** Expected type  : Int -> Int
*** Because        : the function binding has 1 pattern, but its type signature does not allow patterns

---------------------------------------------
module FBHasTooMany2 where

f :: Int 
f x y = x + y
---------------------------------------------
--- Algorithm W:
Compiling ./FBHasTooMany2.hs
(4,1): Type error in explicitly typed binding
*** Term           : f
*** Type           : Int
*** Expected type  : Int -> Int -> Int

--- Algorithm M:
Compiling ./FBHasTooMany2.hs
(4,1): Type error in explicitly typed binding
*** Term           : f
*** Type           : Int
*** Expected type  : Int -> Int -> Int

--- TypeGraphs:
Compiling ./FBHasTooMany2.hs
(4,1): Type error in explicitly typed binding
*** Term           : f
*** Type           : Int
*** Expected type  : Int -> Int -> Int
*** Because        : the function binding has 2 patterns, but its type signature does not allow patterns

---------------------------------------------
module FBHasTooMany3 where

max3 :: Int -> Int -> Int
max3 x y z = x `max` (y `max` z) 
---------------------------------------------
--- Algorithm W:
Compiling ./FBHasTooMany3.hs
(4,1): Type error in explicitly typed binding
*** Term           : max3
*** Type           : Int -> Int -> Int
*** Expected type  : Int -> Int -> Int -> Int

--- Algorithm M:
Compiling ./FBHasTooMany3.hs
(4,1): Type error in explicitly typed binding
*** Term           : max3
*** Type           : Int -> Int -> Int
*** Expected type  : Int -> Int -> Int -> Int

--- TypeGraphs:
Compiling ./FBHasTooMany3.hs
(4,1): Type error in explicitly typed binding
*** Term           : max3
*** Type           : Int -> Int -> Int
*** Expected type  : Int -> Int -> Int -> Int
*** Because        : the function binding has 3 patterns, but its type signature allows at most 2

---------------------------------------------
module SimilarFunction1 where

main :: [Int]
main = xs : ys

xs = []

ys = [1,2,3]
---------------------------------------------
--- Algorithm W:
Compiling ./SimilarFunction1.hs
(4,8): Type error in infix application
*** Expression     : xs:ys
*** Term           : :
*** Type           : a   -> [a  ] -> [a  ]
*** Does not match : [b] -> [Int] -> [Int]

--- Algorithm M:
Compiling ./SimilarFunction1.hs
(4,8): Type error in variable
*** Expression     : xs
*** Type           : [a]
*** Expected type  : Int

--- TypeGraphs:
Compiling ./SimilarFunction1.hs
(4,11): Type error in constructor
*** Expression     : :
*** Type           : a   -> [a  ] -> [a  ]
*** Expected type  : [b] -> [Int] -> [Int]
*** Probable fix   : use (++) instead

---------------------------------------------
module SimilarFunction2 where

keerPi :: Float -> Float
keerPi x = pi * x 

pi :: Float
pi = 3.1415927
---------------------------------------------
--- Algorithm W:
Compiling ./SimilarFunction2.hs
(4,12): Type error in infix application
*** Expression     : pi*x
*** Term           : *
*** Type           : Int   -> Int   -> Int
*** Does not match : Float -> Float -> Float

--- Algorithm M:
Compiling ./SimilarFunction2.hs
(4,15): Type error in variable
*** Expression     : *
*** Type           : Int   -> Int   -> Int
*** Expected type  : Float -> Float -> Float

--- TypeGraphs:
Compiling ./SimilarFunction2.hs
(4,15): Type error in variable
*** Expression     : *
*** Type           : Int   -> Int   -> Int
*** Expected type  : Float -> Float -> Float
*** Probable fix   : use (*.) instead

---------------------------------------------
module SimilarFunction3 where

floatSum :: [Float] -> Float
floatSum = foldr (+) 0.0 
---------------------------------------------
--- Algorithm W:
Compiling ./SimilarFunction3.hs
(4,12): Type error in application
*** Expression     : foldr (+) 0.0
*** Term           : foldr
*** Type           : (a   -> b   -> b)   -> b     -> [a    ] -> b
*** Does not match : (Int -> Int -> Int) -> Float -> [Float] -> Float

--- Algorithm M:
Compiling ./SimilarFunction3.hs
(4,19): Type error in variable
*** Expression     : +
*** Type           : Int   -> Int   -> Int
*** Expected type  : Float -> Float -> Float

--- TypeGraphs:
Compiling ./SimilarFunction3.hs
(4,19): Type error in variable
*** Expression     : +
*** Type           : Int   -> Int   -> Int
*** Expected type  : Float -> Float -> Float
*** Probable fix   : use (+.) instead

---------------------------------------------
module SimilarLiteral1 where

floatSum :: [Float] -> Float
floatSum = foldr (+.) 0

(+.) :: Float -> Float -> Float
(+.) = undefined
---------------------------------------------
--- Algorithm W:
Compiling ./SimilarLiteral1.hs
(4,12): Type error in application
*** Expression     : foldr (+.) 0
*** Term           : foldr
*** Type           : (a     -> b     -> b)     -> b   -> [a    ] -> b
*** Does not match : (Float -> Float -> Float) -> Int -> [Float] -> Float

--- Algorithm M:
Compiling ./SimilarLiteral1.hs
(4,23): Type error in literal
*** Expression     : 0
*** Type           : Int
*** Expected type  : Float

--- TypeGraphs:
Compiling ./SimilarLiteral1.hs
(4,23): Type error in literal
*** Expression     : 0
*** Type           : Int
*** Expected type  : Float
*** Probable fix   : use a float literal instead

---------------------------------------------
module SimilarLiteral2 where

f 1 x = 0.0
f n x = (n*x) + f (n-1) x
---------------------------------------------
--- Algorithm W:
Compiling ./SimilarLiteral2.hs
(4,9): Type error in infix application
*** Expression     : (n*x)+f (n-1) x
*** Term           : +
*** Type           : Int -> Int   -> Int
*** Does not match : Int -> Float -> Float

--- Algorithm M:
Compiling ./SimilarLiteral2.hs
(4,15): Type error in variable
*** Expression     : +
*** Type           : Int -> Int   -> Int
*** Expected type  : Int -> Float -> Float

--- TypeGraphs:
Compiling ./SimilarLiteral2.hs
(3,9): Type error in literal
*** Expression     : 0.0
*** Type           : Float
*** Expected type  : Int
*** Probable fix   : use an int literal instead

---------------------------------------------
module SimilarLiteral3 where

startsWithA :: String -> Bool
startsWithA s = case s of  
                  []      -> False
                  "A" : _ -> True
                  _       -> False
---------------------------------------------
--- Algorithm W:
Compiling ./SimilarLiteral3.hs
(6,19): Type error in case pattern
*** Pattern        : "A" : _
*** Type           : [String]
*** Does not match : [Char  ]

--- Algorithm M:
Compiling ./SimilarLiteral3.hs
(6,19): Type error in literal pattern
*** Pattern        : "A"
*** Type           : String
*** Expected type  : Char

--- TypeGraphs:
Compiling ./SimilarLiteral3.hs
(6,19): Type error in literal pattern
*** Pattern        : "A"
*** Type           : String
*** Expected type  : Char
*** Probable fix   : use a char literal instead

---------------------------------------------
module SimilarNegation where

test :: Float
test = - (3.0 +. 6.0)

test' :: Int
test' = -. 3

test'' :: Float -> Float
test'' (- 1.0) = 1.0
test'' x       = x +. 1.0

test''' :: Int -> Bool
test''' (-. 1) = True
test''' _      = False

(+.) :: Float -> Float -> Float
(+.) = undefined
---------------------------------------------
--- Algorithm W:
Compiling ./SimilarNegation.hs
(14,1): Type error in pattern of function binding
*** Pattern        : (-.1)
*** Type           : Float
*** Does not match : Int

(14,10): Type error in pattern negation 
*** Pattern        : -.1
*** Term           : 1
*** Type           : Int
*** Does not match : Float

(10,1): Type error in pattern of function binding
*** Pattern        : (-1.0)
*** Type           : Int
*** Does not match : Float

(10,9): Type error in pattern negation 
*** Pattern        : -1.0
*** Term           : 1.0
*** Type           : Float
*** Does not match : Int

(7,7): Type error in right hand side
*** Expression     : -.3
*** Type           : Float
*** Does not match : Int

(7,9): Type error in negation
*** Expression     : -.3
*** Term           : 3
*** Type           : Int
*** Does not match : Float

(4,6): Type error in right hand side
*** Expression     : -(3.0+.6.0)
*** Type           : Int
*** Does not match : Float

(4,8): Type error in negation
*** Expression     : -(3.0+.6.0)
*** Term           : (3.0+.6.0)
*** Type           : Float
*** Does not match : Int

--- Algorithm M:
Compiling ./SimilarNegation.hs
(14,10): Type error in pattern negation 
*** Pattern        : -.1
*** Term           : 1
*** Type           : Int
*** Does not match : Float

(14,10): Type error in pattern negation
*** Pattern        : -.1
*** Type           : Float
*** Expected type  : Int

(10,9): Type error in pattern negation 
*** Pattern        : -1.0
*** Term           : 1.0
*** Type           : Float
*** Does not match : Int

(10,9): Type error in pattern negation
*** Pattern        : -1.0
*** Type           : Int
*** Expected type  : Float

(7,12): Type error in literal
*** Expression     : 3
*** Type           : Int
*** Expected type  : Float

(7,9): Type error in negation
*** Expression     : -.3
*** Type           : Float
*** Expected type  : Int

(4,15): Type error in variable
*** Expression     : +.
*** Type           : Float -> Float -> Float
*** Expected type  : Float -> Float -> Int

(4,8): Type error in negation
*** Expression     : -(3.0+.6.0)
*** Type           : Int
*** Expected type  : Float

--- TypeGraphs:
Compiling ./SimilarNegation.hs
(4,8): Type error in negation
*** Expression     : -(3.0+.6.0)
*** Term           : (3.0+.6.0)
*** Type           : Float
*** Does not match : Int
*** Probable fix   : use float negation (-.) instead

(7,9): Type error in negation
*** Expression     : -.3
*** Term           : 3
*** Type           : Int
*** Does not match : Float
*** Probable fix   : use int negation (-) instead

(10,9): Type error in pattern negation 
*** Pattern        : -1.0
*** Term           : 1.0
*** Type           : Float
*** Does not match : Int
*** Probable fix   : use float negation (-.) instead

(14,10): Type error in pattern negation 
*** Pattern        : -.1
*** Term           : 1
*** Type           : Int
*** Does not match : Float
*** Probable fix   : use int negation (-) instead

---------------------------------------------
module TupleInsert1 where

ifthenelse :: (Bool,a,a) -> a
ifthenelse (b,t,e) = if b then t else e

main :: Int
main = ifthenelse (5,3)
---------------------------------------------
--- Algorithm W:
Compiling ./TupleInsert1.hs
(7,8): Type error in application
*** Expression     : ifthenelse (5,3)
*** Term           : ifthenelse
*** Type           : (Bool, a, a) -> a
*** Does not match : (Int, Int)   -> Int

--- Algorithm M:
Compiling ./TupleInsert1.hs
(7,19): Type error in tuple
*** Expression     : (5,3)
*** Type           : (Int, Int)
*** Expected type  : (Bool, Int, Int)

--- TypeGraphs:
Compiling ./TupleInsert1.hs
(7,19): Type error in tuple
*** Expression     : (5,3)
*** Type           : (Int, Int)
*** Expected type  : (Bool, Int, Int)
*** Probable fix   : insert a first element to the tuple

---------------------------------------------
module TupleInsert2 where

main :: (String,Int,Int,Bool)
main = ("hallo",True)
---------------------------------------------
--- Algorithm W:
Compiling ./TupleInsert2.hs
(4,6): Type error in right hand side
*** Expression     : ("hallo",True)
*** Type           : (String, Bool)
*** Does not match : (String, Int, Int, Bool)

--- Algorithm M:
Compiling ./TupleInsert2.hs
(4,8): Type error in tuple
*** Expression     : ("hallo",True)
*** Type           : (String, Bool)
*** Expected type  : (String, Int, Int, Bool)

--- TypeGraphs:
Compiling ./TupleInsert2.hs
(4,8): Type error in tuple
*** Expression     : ("hallo",True)
*** Type           : (String, Bool)
*** Expected type  : (String, Int, Int, Bool)
*** Probable fix   : insert a second and third element to the tuple

---------------------------------------------
module TupleRemove1 where

f :: Int -> (Int,Int)
f 0 = (1,1)
f i = let (a,b) = f (i-1)
      in if a == b 
           then (True,a+b,a)
           else (a,b)
---------------------------------------------
--- Algorithm W:
Compiling ./TupleRemove1.hs
(5,1): Type error in function binding
*** Term           : let {(a,b)=f (i-1)} in if a==b then (...,a+b,a) else (a,b)
*** Type           : (Bool, Int, Int)
*** Does not match : (Int, Int)

(6,10): Type error in else branch of conditional
*** Expression     : if a==b then (True,a+b,a) else (a,b)
*** Term           : (a,b)
*** Type           : (Int, Int)
*** Does not match : (Bool, Int, Int)

--- Algorithm M:
Compiling ./TupleRemove1.hs
(7,17): Type error in tuple
*** Expression     : (True,a+b,a)
*** Type           : (Bool, Int, Int)
*** Expected type  : (Int, Int)

--- TypeGraphs:
Compiling ./TupleRemove1.hs
(7,17): Type error in tuple
*** Expression     : (True,a+b,a)
*** Type           : (Bool, Int, Int)
*** Expected type  : (Int, Int)
*** Probable fix   : remove first element of tuple

---------------------------------------------
module TupleRemove2 where

first :: (a,a) -> a
first (a,b) = a

main :: Int
main = first (1,2,"hello","world") 
---------------------------------------------
--- Algorithm W:
Compiling ./TupleRemove2.hs
(7,8): Type error in application
*** Expression     : first (1,2,"hello","world")
*** Term           : first
*** Type           : (a, a)                     -> a
*** Does not match : (Int, Int, String, String) -> Int

--- Algorithm M:
Compiling ./TupleRemove2.hs
(7,14): Type error in tuple
*** Expression     : (1,2,"hello","world")
*** Type           : (Int, Int, String, String)
*** Expected type  : (Int, Int)

--- TypeGraphs:
Compiling ./TupleRemove2.hs
(7,14): Type error in tuple
*** Expression     : (1,2,"hello","world")
*** Type           : (Int, Int, String, String)
*** Expected type  : (Int, Int)
*** Probable fix   : remove third and fourth element of tuple

---------------------------------------------
module TupleReorder1 where

f :: (Int,Bool) -> Int
f (i,b) = if b then i else 0

main :: Int
main = f (True,5)
---------------------------------------------
--- Algorithm W:
Compiling ./TupleReorder1.hs
(7,8): Type error in application
*** Expression     : f (True,5)
*** Term           : f
*** Type           : (Int , Bool) -> Int
*** Does not match : (Bool, Int ) -> Int

--- Algorithm M:
Compiling ./TupleReorder1.hs
(7,16): Type error in literal
*** Expression     : 5
*** Type           : Int
*** Expected type  : Bool

(7,11): Type error in constructor
*** Expression     : True
*** Type           : Bool
*** Expected type  : Int

--- TypeGraphs:
Compiling ./TupleReorder1.hs
(7,10): Type error in tuple
*** Expression     : (True,5)
*** Type           : (Bool, Int )
*** Expected type  : (Int , Bool)
*** Probable fix   : re-order elements of tuple

---------------------------------------------
module TupleReorder2 where

shuffle :: (a,b,c) -> (b,c,a)
shuffle (a,b,c) = (b,c,a)

main :: (Int,Int,Bool)
main = shuffle (1,True,2)
---------------------------------------------
--- Algorithm W:
Compiling ./TupleReorder2.hs
(7,6): Type error in right hand side
*** Expression     : shuffle (1,True,2)
*** Type           : (Bool, Int, Int )
*** Does not match : (Int , Int, Bool)

--- Algorithm M:
Compiling ./TupleReorder2.hs
(7,19): Type error in constructor
*** Expression     : True
*** Type           : Bool
*** Expected type  : Int

(7,17): Type error in literal
*** Expression     : 1
*** Type           : Int
*** Expected type  : Bool

--- TypeGraphs:
Compiling ./TupleReorder2.hs
(7,16): Type error in tuple
*** Expression     : (1,True,2)
*** Type           : (Int , Bool, Int)
*** Expected type  : (Bool, Int , Int)
*** Probable fix   : re-order elements of tuple

---------------------------------------------
module TupleSize1 where

f :: Int -> (Int,Int)
f 0 = (1,1)
f i = let (a,b) = f (i-1)
      in (a+b,a,b)
---------------------------------------------
--- Algorithm W:
Compiling ./TupleSize1.hs
(5,1): Type error in function binding
*** Term           : let {(a,b)=f (i-1)} in (a+b,a,b)
*** Type           : (Int, Int, Int)
*** Does not match : (Int, Int)

--- Algorithm M:
Compiling ./TupleSize1.hs
(6,10): Type error in tuple
*** Expression     : (a+b,a,b)
*** Type           : (Int, Int, Int)
*** Expected type  : (Int, Int)

--- TypeGraphs:
Compiling ./TupleSize1.hs
(6,10): Type error in tuple
*** Expression     : (a+b,a,b)
*** Type           : (Int, Int, Int)
*** Expected type  : (Int, Int)
*** Because        : a 3-tuple does not match a 2-tuple

---------------------------------------------
module TupleSize2 where

f :: [a] -> [b] -> a
f as bs = let (x,y,z) = head (zip as bs)
          in x
---------------------------------------------
--- Algorithm W:
Compiling ./TupleSize2.hs
(4,23): Type error in right hand side
*** Expression     : head (zip as bs)
*** Type           : (a, b)
*** Does not match : (c, d, e)

--- Algorithm M:
Compiling ./TupleSize2.hs
(4,31): Type error in variable
*** Expression     : zip
*** Type           : [a] -> [b] -> [(a, b)   ]
*** Expected type  : [c] -> [d] -> [(e, f, g)]

--- TypeGraphs:
Compiling ./TupleSize2.hs
(4,15): Type error in pattern tuple
*** Pattern        : (x,y,z)
*** Type           : (a, b, c)
*** Expected type  : (d, e)
*** Because        : a 3-tuple does not match a 2-tuple

---------------------------------------------
module TupleSize3 where

main = fst (1,2,"hello","world") 
---------------------------------------------
--- Algorithm W:
Compiling ./TupleSize3.hs
(3,8): Type error in application
*** Expression     : fst (1,2,"hello","world")
*** Term           : fst
*** Type           : (a, b)                     -> a
*** Does not match : (Int, Int, String, String) -> c

--- Algorithm M:
Compiling ./TupleSize3.hs
(3,12): Type error in tuple
*** Expression     : (1,2,"hello","world")
*** Type           : (Int, Int, String, String)
*** Expected type  : (a, b)

--- TypeGraphs:
Compiling ./TupleSize3.hs
(3,12): Type error in tuple
*** Expression     : (1,2,"hello","world")
*** Type           : (Int, Int, String, String)
*** Expected type  : (a, b)
*** Because        : a 4-tuple does not match a 2-tuple

