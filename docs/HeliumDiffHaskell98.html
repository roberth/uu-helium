<HTML>

<HEAD>
 <TITLE>
  Helium, differences when compared to Haskell 98
 </TITLE>
</HEAD>

<BODY>

<H1>Helium: differences with Haskell 98</H1>


<H2>Not supported</H2>
<UL>

<LI>Labeled fields in data types (a.k.a. records)
<LI><TT>newtype</TT> declarations
<LI>Qualified imports and renaming an imported module with <TT>as</TT>
<LI>Import and export lists, such as <TT>import Prelude(map)</TT>
<LI><TT>class</TT>, <TT>instance</TT> and <TT>default</TT> declarations
<LI>Strictness annotations
<LI><TT>n+k</TT> patterns
<LI>(,) and (,,) etc. to construct a tuple (type), i.e. you cannot write <TT>(,) 3 4</TT>
<LI><TT>[]</TT> as type constructor, i.e. you cannot write <TT>x :: [] Int</TT>
<LI>Literate programming
</UL>

<H2>Different</H2>
<UL>
<LI>The <A HREF="http://www.cs.uu.nl/helium/docs/LayoutRule.html">layout rule</A> is somewhat simpler.
<LI>A show function is generated for each data type and type synonym. For instance, the function <TT>showMaybe</TT> is 
automatically created for the data type <TT>Maybe</TT>. If the data type has parameters, then the
show function gets extra arguments, e.g. <TT>showMaybe showInt (Just 3)</TT>.
<LI>Instances for </TT>Show</TT> and </TT>Eq</TT> can be derived for data types. These instances are needed to 
use overloaded functions, such as <TT>show</TT> and <TT>(==)</TT>
<LI>If your <TT>main</TT> function is not of type IO, then the value is printed with the show functions. The show functions
    can print anything, e.g. functions are printed as <TT>&lt&lt function &gt&gt</TT>. Therefore, there is
    a difference between <TT>main = expression</TT> and <TT>main = show expression</TT>. In the
    latter case, the expression must be in the <TT>Show</TT> class.
<LI>The module system is very simple:
	<UL>
	<LI>Everything is always exported: data types, functions, synonyms, instances.
	<LI>Everything that is imported is exported as well.
	<LI>It is not allowed to import something via two (different) import declarations.
	    This means that if you have a module A and both B and C import A, and then a fourth
	    module D imports both B and C, then you will get clashes for all the names in A.
	    from module A. However, it is no problem if module A is the Prelude
	<LI>You can hide functions in an import declaration with <TT>hiding</TT>, except for the
    	show functions that are generated for a data type. Other entities, such as types and constructors,
        cannot be hidden.
	<LI>The Prelude is always imported. You can hide functions from
	    the Prelude by explicitly writing an import declaration: <TT>import Prelude hiding (map, filter)</TT>
	</UL>
<LI>The following character sequences are supported in characters and strings:
		\\, \n, \a, \b, \f, \r, \t, \v, \", \'.
	Other escape sequences like the ones with numbers are not supported.
<LI>Numeric literals are not overloaded (even when using the --overloading flag). Thus, <TT>3</TT> is of type <TT>Int</TT> and
    <TT>3.0</TT> is of type <TT>Float</TT>.
<LI>In Helium, type variables are always of kind star (*).
<LI>A more restrictive syntax for operator sections. For instance,
	<TT>(+2*3)</TT> is not allowed, this should be <TT>(+(2*3))</TT>.
<LI>A slightly more restrictive syntax for left-hand sides of function definitions.
For example, in Helium the parentheses in the following definitions
are necessary whereas in Haskell they are not:
<PRE>
(x:xs) ++ ys = ...
(x:xs) = ...</PRE>
Helium rejects a definition if operator precedence is necessary to understand the
left-hand side. See the end of <A HREF="http://www.haskell.org/onlinereport/decls.html#sect4.4">section 4.4</A> (A note
about syntax) of the Haskell Report to see why we have done this.
<LI>Fixity declarations are only allowed at top-level
</UL>

</BODY>

</HTML>
