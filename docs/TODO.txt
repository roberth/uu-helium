DOCUMENTATIE

! commentaar over List en Maybe
! tutorial

INTERPRETER
* functies definieren? 
* autoload feature (zie e-mails van Stephen Milborrow)?

DAAN
! file IO exceptions; * EOF in getChar. How? catch werkt niet
! strictheid van error
! let f x = f (x+1) in f 0

COMPILER
* Hint bij "abs -42"

---- ONBELANGRIJK ----
                
* bij het exporteren van een functie moeten ook de types geexporteerd worden. Hoe?
	we moeten ook weten waar iets oorspronkelijk vandaan komt (definitieplek)
* import Module(N) moet ook de show importeren: import Module (N, showN)
! XML uitvoer van errors en warnings t.b.v. interpreter
! Alle mogelijke fouten/warnings/hints uitleggen adhv voorbeeldje (DICTAAT?)
* AG geeft geen ExitFailure bij een fout (en make gaat vrolijk verder).
* read functies voor andere types dan Int
* clashes with HeliumLang ==> clash with built-in (MANUAL)
* generiek maken show voor tupels (Daan)
* import SomeModule(SomeDataType(..)) is impossible in core
* JCreator: Rijk-Jan
* show implementeren met shows, ShowS; efficienter
* domein kopen

---- DONE ----================================================================================

* springen naar internet browser bij :i map http://www.cs.uu.nl/~afie/helium/tourofprelude.html#map
! User manual grafische hint A4
* catchen van exception van writeFile/openFileEx etc.
! installer voor Windows 
! Tour of Haskell syntax controleren
* hint opties doorspelen naar Helium

COMMAND Interpreter

* interpreter gooit temp files weg a/h begin na iedere expressie
* foutmeldingen over Interpreter.hs afvangen
* Ctrl-C stopt niet alleen lvmrun maar ook hint


! parse error tests (zie Thompson)
* unexpected '\n' als je een string niet beeindigd. kan dat newline worden?
* ParseCommon.literal: "Daan moet eigenlijk niet interpreteren" (by Arjan)
* bij chasing niet de hele module parsen
* operator definitie in pp haakjes er omheen
! User manual helium A4
! User manual lvmrun A5
* pretty printer voor foutmeldingen
* lvmrun compileren met -O
! pattern-match failure beter presenteren (niet alleen begin)
DONE infix constructoren infix tonen
DONE module header overbodig en dus optioneel in parser
DONE corrupte lvm mededeling is lelijk
DONE Als -O compileren dan moet ook coreasm met optimalisatie gecompileerd worden
DONE Sections

2. Should (:) be Expr_Con ":" or Expr_Infix Nothing ":" Nothing?
   (I currently adopt the first solution; otherwise InfixCon3 is broken.)

* Directory structuur
helium +- src   +- main (Main.hs, Args.hs, Version.hs, Compile.hs)
       |- lib   |- hint
       |- bin   |- staticanalysis
       |- test  |- codegeneration
       |- demo  |- uha
                |- utils
                |- parser

* tellers op WWW
* Logger uit in web-versie
* systeemverschillen (bijv. dir sep) in modules (UNIX, Windows)
* MacOS X version
* Linux version
* Sun Solaris version
* eqInt
* Tour of the Helium Prelude
* systeemverschillen vangen met configure
* Sockets werken niet op MacOS X (als logger uit dan geen -package net etcetera)
* parse errors loggen
* showFloat moet altijd .0 printen bij geheel getal en haakjes bij negatief getal en - moet -. worden
* optimaliseren indirectionDecls. alleen die overhouden die gebruikt worden


======================== DONE ======================== 

* interpreter kan module die Main heet niet inlezen?! "module imports itself"

- MATCHFLOAT showFloat, sqrt, round, truncate, ceiling, floor, intToFlat

helium Main ook accepteren (als .hs bestaat)

Float: show, sqrt, round, pattern-matching, unaire -.

showTuple6 t/m 10"

2. StaticAnalysis.ag, Collect.ag:
   Need to collect toplevel names myself because "keys @topleveltypes"
   is (too?) strict, so it tries to construct the types as well, which
   might crash the compiler if non-type-inference-sa fails due to malformed
   types.
   Is MyAssocList not lazy enough?
   Can we in some way (other than using "keys @topleveltypes")
   avoid code duplication here?

4. Main.getImports.runHParser and Main.startCompilation.runHParser:
   "foutmeldingen" (Arjan knows what this means)

2. Insert a function main:
   if no main is present,
     main = error "This is a Helium library (i.e. no main function is defined)."
   else
     rename main to main_
     if main :: IO a
       main = unsafePerformIO main_
     else if main :: a (i.e. is a value; not a function)
       main = unsafePerformIO (return main_)
     else
       main = unsafePerformIO (putStrLn "<<function>>")

1. Write a kind of generic show on lvm types using reflection and type information.

Prelude niet expliciet importeerbaar? Want showInt, enumFrom etc. MOETEN er zijn.

verschillen met Haskell 98

regelnr UNIX bij inlezen DOS-file

patternMatchFail is nodig door compilatie van pattern-matching (StaticAnalysis.ag)
  [ HeliumLang ]

Prelude gewone module die je mag veranderen (dus alles waar de compiler van 
	afhangt naar HeliumLang (enumFrom..., concatMap, show...))

Lijstje van recursieve imports opbouwen in make

power :: Float -> Int -> Float
Float: +., -., *. /. ==. <. enzovoort

hlc Main.o zorgt ervoor dat Main.hs gecompileerd wordt???

parse errors mooier laten zien

* unsafe(Strict?)PerformIO bouwen als type IO ()

! Main.hs: startCompilation opsplitsen in brokjes en exitWith weggooien

X alle error's als internalError?
X concatMap & enum... in vertaling [ | ] en [ .. ]
X impliciet Prelude importeren
X Daan: expliciete export van constructoren (Bool(T, F)) werkt niet
X fixity duplicatie check
X wel fix, geen def
X IO niet als synoniem exporteren
X primitives loskoppelen
X look in search path
X add hlc.exe and lvmrun's path to search path
X impliciete exports
X doorexporteren
X type synoniemen ..porteren
X fixities ..porteren


15/8
tracked down Bool-bug: instructions (eqint, neint, ...)
  assume False has tag 0 and True has tag 1.
discovered and fixed a bug in Prelude: negative integers
  were printed between brackets, without minus sign

16/8
implicit exports
list and unit moved from built-in to HeliumLang.core
im-/export type synonyms
in progress: remove unused message for toplevel declarations

17/8
removed unused message for toplevel declarations
removed Primitives.hs; all primitives now moved to HeliumLang.core
export fixities (daan-compatible)
 and implemented import fixities
fixed a bug, causing the compiler to run into infinite recursion (not even
 "Fail: <<loop>>"), when compiling the prelude with [Char] substituted by
 String (after introduction of type synonyms). It was caused by faulty
 termination conditions in SolveGreedy.writeIntType
fixed another bug concerning faulty termination conditions and causing
 infinite recursion as well (not even "Fail: <<loop>>"), in the mutually
 recursive functions SolveConstraints.applySubst and
 SolveGreedy.findSubstForVar
duplicated fixity
fixed a stack overflow. the instance Ord Name in SAUtils inadvertedly
 was defined using < rather than <= or compare
fix but no def

19/8
support module export:
 "module Exporter(module Exporter, module Import1, ...)"
don't export imported entities when export list is omitted
Fixed bug in function Main.make:
 module Test1 where
  x = 2
 module Test2 where
  import Test1
 module Test3 where
  import Test1
 Now, module Test3 was not recompiled if module Test1 was changed
 Fix: make recompiled attribute chained
20/8
report error if importing one function from two different modules
  (note: importing a function twice, even in two import declarations is allowed!)
extensively tested the module system and fixed bugs
21/8
Rewrote most tests because all primitives (but tuples) are in HeliumLang now
Fixed bugs revealed by the tests (yes - a whole day of testing and debugging)
22/8
My birthday
Added checks for precence of functions and types needed for literals done
Rewrote last tests
fixed some bugs
Add checks for precence of functions and types needed for
  special constructs:
    Example           UHA tree location                       Requirement
    f x = x           Declaration.FunctionBindings            a -> b
    
    f a b c           Expression.NormalApplication            a -> b
    a `f` b           Expression.InfixApplication             a -> b
    if then else      Expression.If                           Bool
    \x -> x           Expression.Lambda                       a -> b
    [a, b, c]         Expression.List                         [a]
    [ x | x <- ... ]  Expression.Comprehension                [a]
    [a..]             Expression.Enum                         [a], Int
    [a..b]                                                    enumFrom,
    [a,b..]                                                   enumFromTo
    [a,b..c]                                                  enumFromThen
                                                              enumFromThenTo
    - x               Expression.Negate                       Int, primNegInt
    
    expr              Statement.Expression                    IO a
    x <- [a, b, c]    Statement.Generator                     IO a
    
    expr              Qualifier.Guard                         Bool
    x <- [a, b, c]    Qualifier.Generator                     [a], concatMap
    
    | g ->, | g =     GuardedExpression.GuardedExpression     Bool
    
    Con a b           Pattern.Constructor                     a -> b
    a :- b            Pattern.InfixConstructor                a -> b
    [a, b, c]         Pattern.List                            [a]
    1, 2, 3           Literal.Int                             Int
    'a'               Literal.Char                            Char
    1.0               Literal.Float                           Float
    "abc"             Literal.String                          String
Propagate range one level up
SimpleType has no range
23/8
Rewrote tests again because I now use LvmLang.core and LvmIO.core, rather than
  putting everything in HeliumLang.core.
Fixed bugs revealed by the tests (yes - again most of the day testing and
  debugging)
Many small fixes, started writing HeliumGUI
Improved CoreParse import and export syntax
Split Main.hs into Main.hs, Make.hs and Args.hs
24/8
ParseDeclExp.aexp: Refactored and eliminated try's
Wrote HeliumGUI.core, containing message box support and HelloWorld!
Refactored Main.hs into Main.hs, Args.hs and Make.hs
26/8
Fixed re-export bug in lvm (modulePublic is now called after
lvmImport as well, rather than before only)

! waar worden parse errors gegooid? ze komen niet in Main

! one-liners


! show:
	1. (show :: [Int] -> String) xs    ==>   showList showInt xs
	2. reflectie/type informatie
	3. A second look at overloading

	OVERLOADING

	idee: voor show: schrijf expliciete type op en intern worden daar functieaanroepen van
	gemaakt

	(show :: [Int] -> String) xs    ==>   showList showInt xs

	showList, showInt etc niet zichtbaar voor gebruiker, vb. show$List 

! Speciale types ondersteunen in derivingShow.hs (tuples, lijsten...)

! stat. analyse van deriving Show

kan ToCore weer losgekoppeld worden?

3. Add import/export Bool(..) (for some info, see ToCoreModule.ag)

================= NO PRIORITY

4. Typo in lvm.pdf, page 17, line 7 (between the tables):
     The first characters gives ...
                        ^
   should be
     The first character gives ...

2. Parser.constr    is considered inefficient by Arjan
1. Scope.addToScope is considered inefficient by Arjan
